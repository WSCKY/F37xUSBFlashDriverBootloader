L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\src\stm32f37x_rcc.c"
N/**
N  ******************************************************************************
N  * @file    stm32f37x_rcc.c
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file provides firmware functions to manage the following 
N  *          functionalities of the Reset and clock control (RCC) peripheral:
N  *           + Internal/external clocks, PLL, CSS and MCO configuration
N  *           + System, AHB and APB busses clocks configuration
N  *           + Peripheral clocks configuration
N  *           + Interrupts and flags management
N  *
N @verbatim
N
N ===============================================================================
N                        ##### RCC specific features #####
N ===============================================================================
N    [..] After reset the device is running from HSI (8 MHz) with Flash 0 WS, 
N         all peripherals are off except internal SRAM, Flash and SWD.
N         (#) There is no prescaler on High speed (AHB) and Low speed (APB) busses;
N             all peripherals mapped on these busses are running at HSI speed.
N         (#) The clock for all peripherals is switched off, except the SRAM and FLASH.
N         (#) All GPIOs are in input floating state, except the SWD pins which
N             are assigned to be used for debug purpose.
N    [..] Once the device started from reset, the user application has to:
N         (#) Configure the clock source to be used to drive the System clock
N             (if the application needs higher frequency/performance)
N         (#) Configure the System clock frequency and Flash settings
N         (#) Configure the AHB and APB busses prescalers
N         (#) Enable the clock for the peripheral(s) to be used
N         (#) Configure the clock source(s) for peripherals which clocks are not
N             derived from the System clock (SDADC, CEC, I2C, USART, RTC and IWDG)
N
N @endverbatim
N  
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x_rcc.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_rcc.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the RCC 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_RCC_H
N#define __STM32F37X_RCC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
L 1 "..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include\stm32f37x.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral registers definitions, bits 
N  *          definitions and memory mapping for STM32F37x devices.
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_STDPERIPH_DRIVER"
N  *              - To change few application-specific parameters such as the HSE 
N  *                crystal frequency
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral registers declarations and bits definition
N  *           - Macros to access peripheral registers hardware
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * FOR MORE INFORMATION PLEASE READ CAREFULLY THE LICENSE AGREEMENT FILE
N  * LOCATED IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  ******************************************************************************  
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f37x
N  * @{
N  */
N    
N#ifndef __STM32F37x_H
N#define __STM32F37x_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif /* __cplusplus */
N  
N/** @addtogroup Library_configuration_section
N  * @{
N  */
N  
N/* Uncomment the line below according to the target STM32 device used in your
N   application 
N  */
N
N#if !defined (STM32F37X) 
X#if !1L 
S  #define STM32F37X
N#endif
N
N/*  Tip: To avoid modifying this file each time you need to switch between these
N        devices, you can define the device in your toolchain compiler preprocessor.
N  */
N
N#if !defined (STM32F37X)
X#if !1L
S #error "Please select first the target STM32F37X device used in your application (in stm32f37x.h file)"
N#endif
N
N#if !defined  (USE_STDPERIPH_DRIVER)
X#if !1L
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_STDPERIPH_DRIVER*/
N#endif /* USE_STDPERIPH_DRIVER */
N
N/**
N * @brief In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application 
N   
N   Tip: To avoid modifying this file each time you need to use different HSE, you
N        can define the HSE value in your toolchain compiler preprocessor.
N  */           
N#if !defined  (HSE_VALUE) 
X#if !0L 
N #define HSE_VALUE            ((uint32_t)16000000) /*!< Value of the External oscillator in Hz */
N#endif /* HSE_VALUE */
N/**
N * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
N   Timeout value 
N   */
N#if !defined  (HSE_STARTUP_TIMEOUT) 
X#if !0L 
N #define HSE_STARTUP_TIMEOUT  ((uint16_t)0x0500)   /*!< Time out for HSE start up */
N#endif /* HSE_STARTUP_TIMEOUT */
N/**
N * @brief In the following line adjust the Internal High Speed oscillator (HSI) Startup 
N   Timeout value 
N   */
N#define HSI_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSI start up */
N
N#if !defined  (HSI_VALUE) 
X#if !0L 
N #define HSI_VALUE  ((uint32_t)8000000)
N#endif /* HSI_VALUE */                      /*!< Value of the Internal High Speed oscillator in Hz.
N                                            The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#if !defined  (LSI_VALUE) 
X#if !0L 
N #define LSI_VALUE  ((uint32_t)40000)    
N#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
N                                             The real value may vary depending on the variations
N                                             in voltage and temperature.  */
N#if !defined  (LSE_VALUE)
X#if !0L
N #define LSE_VALUE  ((uint32_t)32768)    /*!< Value of the External Low Speed oscillator in Hz */
N#endif /* LSE_VALUE */     
N
N/**
N * @brief STM32F37x Standard Peripherals Library version number V1.0.0
N   */
N#define __STM32F37X_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */                                  
N#define __STM32F37X_STDPERIPH_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version */
N#define __STM32F37X_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
N#define __STM32F37X_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
N#define __STM32F37X_STDPERIPH_VERSION       ( (__STM32F37X_STDPERIPH_VERSION_MAIN << 24)\
N                                             |(__STM32F37X_STDPERIPH_VERSION_SUB1 << 16)\
N                                             |(__STM32F37X_STDPERIPH_VERSION_SUB2 << 8)\
N                                             |(__STM32F37X_STDPERIPH_VERSION_RC))
X#define __STM32F37X_STDPERIPH_VERSION       ( (__STM32F37X_STDPERIPH_VERSION_MAIN << 24)                                             |(__STM32F37X_STDPERIPH_VERSION_SUB1 << 16)                                             |(__STM32F37X_STDPERIPH_VERSION_SUB2 << 8)                                             |(__STM32F37X_STDPERIPH_VERSION_RC))
N                                             
N/**
N  * @}
N  */
N
N/** @addtogroup Configuration_section_for_CMSIS
N  * @{
N  */
N
N/**
N * @brief Configuration of the Cortex-M4 Processor and Core Peripherals 
N */
N#define __CM4_REV                 0x0001  /*!< Core revision r0p1                            */
N#define __MPU_PRESENT             1         /*!< STM32F37X provide an MPU */
N#define __NVIC_PRIO_BITS          4         /*!< STM32F37X uses 4 Bits for the Priority Levels */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used */
N#define __FPU_PRESENT             1         /*!< STM32F37X provide an FPU */
N
N
N/**
N * @brief STM32F37X Interrupt Number Definition, according to the selected device 
N *        in @ref Library_configuration_section 
N */
Ntypedef enum IRQn
N{
N/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
N  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
N  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
N  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
N  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
N/******  STM32 specific Interrupt Numbers **********************************************************************/
N  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
N  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
N  TAMPER_STAMP_IRQn           = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line 19          */
N  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line 20                     */
N  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
N  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
N  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
N  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
N  EXTI2_TS_IRQn               = 8,      /*!< EXTI Line2 Interrupt and Touch Sense Interrupt                    */
N  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
N  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
N  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 Interrupt                                          */
N  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 Interrupt                                          */
N  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 Interrupt                                          */
N  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 Interrupt                                          */
N  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 Interrupt                                          */
N  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 Interrupt                                          */
N  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 Interrupt                                          */
N  ADC1_IRQn                   = 18,     /*!< ADC1 Interrupts                                                   */
N  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                  */
N  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                 */
N  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                 */
N  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                 */
N  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
N  TIM15_IRQn                  = 24,     /*!< TIM15 global Interrupt                                            */
N  TIM16_IRQn                  = 25,     /*!< TIM16 global Interrupt                                            */
N  TIM17_IRQn                  = 26,     /*!< TIM17 global Interrupt                                            */
N  TIM18_DAC2_IRQn             = 27,     /*!< TIM18 global Interrupt and DAC2 underrun Interrupt                */
N  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
N  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
N  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
N  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
N  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
N  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
N  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
N  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
N  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
N  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
N  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
N  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
N  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
N  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
N  CEC_IRQn                    = 42,     /*!< CEC Interrupt                                                     */    
N  TIM12_IRQn                  = 43,     /*!< TIM12 global interrupt                                            */
N  TIM13_IRQn                  = 44,     /*!< TIM13 global interrupt                                            */
N  TIM14_IRQn                  = 45,     /*!< TIM14 global interrupt                                            */
N  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
N  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
N  TIM6_DAC1_IRQn              = 54,     /*!< TIM6 global and DAC1 Cahnnel1 & Cahnnel2 underrun error Interrupts*/
N  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                             */
N  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                                   */
N  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                                   */
N  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                                   */
N  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                                   */
N  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                                   */
N  SDADC1_IRQn                 = 61,     /*!< ADC Sigma Delta 1 global Interrupt                                */
N  SDADC2_IRQn                 = 62,     /*!< ADC Sigma Delta 2 global Interrupt                                */
N  SDADC3_IRQn                 = 63,     /*!< ADC Sigma Delta 1 global Interrupt                                */
N  COMP_IRQn                   = 64,     /*!< COMP1 and COMP2 global Interrupt                                  */
N  USB_HP_IRQn                 = 74,     /*!< USB High Priority global Interrupt                                */
N  USB_LP_IRQn                 = 75,     /*!< USB Low Priority global Interrupt                                 */
N  USBWakeUp_IRQn              = 76,     /*!< USB Wakeup Interrupt                                              */
N  TIM19_IRQn                  = 78,     /*!< TIM19 global Interrupt                                            */
N  FPU_IRQn                    = 81      /*!< Floating point Interrupt                                          */
N} IRQn_Type;
N
N/**
N  * @}
N  */
N
N#include "core_cm4.h"            /* Cortex-M4 processor and core peripherals */
L 1 "D:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x04)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM4_CMSIS_VERSION_SUB   (0x00)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) |                                     __CM4_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1)
X    #if (1 == 1)
N      #define __FPU_USED       1
N    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
N    #endif
N  #else
S    #define __FPU_USED         0
N  #endif
N
N#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "D:\MDK\install\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5050157
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 188 "D:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm4.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "D:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050169 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x04) >= 0x03) || (__CORTEX_SC >= 300)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
S
S  result = value;                      // r will be reversed bits of v; first get LSB of v
S  for (value >>= 1; value; value >>= 1)
S  {
S    result <<= 1;
S    result |= value & 1;
S    s--;
S  }
S  result <<= s;                       // shift when v's highest bits are zero
S  return(result);
S}
N#endif
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x04) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function executes a exclusive LDR instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function executes a exclusive LDR instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function executes a exclusive LDR instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function executes a exclusive STR instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function executes a exclusive STR instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function executes a exclusive STR instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Rotate Right with Extend (32 bit)
N
N    This function moves each bit of a bitstring right by one bit.
N    The carry input is shifted in at the left end of the bitstring.
N
N    \param [in]    value  Value to rotate
N    \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  LDRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged LDRT instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged LDRT instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged LDRT instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/** \brief  STRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged STRT instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged STRT instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged STRT instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb 0xF":::"memory");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb 0xF":::"memory");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb 0xF":::"memory");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2));
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S#else
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
S
S  result = value;                      // r will be reversed bits of v; first get LSB of v
S  for (value >>= 1; value; value >>= 1)
S  {
S    result <<= 1;
S    result |= value & 1;
S    s--;
S  }
S  result <<= s;                       // shift when v's highest bits are zero
S#endif
S  return(result);
S}
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ             __builtin_clz
S
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__((always_inline)) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit.
S    The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RRX(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDRBT(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDRHT(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDRT(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRBT(uint8_t value, volatile uint8_t *addr)
S{
S   __ASM volatile ("strbt %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRHT(uint16_t value, volatile uint16_t *addr)
S{
S   __ASM volatile ("strht %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRT(uint32_t value, volatile uint32_t *addr)
S{
S   __ASM volatile ("strt %1, %0" : "=Q" (*addr) : "r" (value) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 189 "D:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm4.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "D:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050169 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x04) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Set Base Priority with condition
N
N    This function assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N    or the new value increases the BASEPRI priority level.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
X#if       ((0x04) == 0x04) || ((0x04) == 0x07)
N
N/** \brief  Get FPSCR
N
N    This function returns the current value of the Floating Point Status/Control register.
N
N    \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0);
N#endif
N}
N
N
N/** \brief  Set FPSCR
N
N    This function assigns the given value to the Floating Point Status/Control register.
N
N    \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Set Base Priority with condition
S
S    This function assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S	or the new value increases the BASEPRI priority level.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
S{
S  __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 190 "D:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm4.h" 2
N#include <core_cmSimd.h>                 /* Compiler specific SIMD Intrinsics               */
L 1 "D:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32)      ) >> 32))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32)      ) >> 32))
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SSAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S#define __USAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLALD (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLALDX (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLSLD (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLSLDX (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S#define __PKHBT(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHBT(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S#define __PKHTB(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  if (ARG3 == 0) \
S    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
S  else \
S    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHTB(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   if (ARG3 == 0)     __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  );   else     __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
S{
S int32_t result;
S
S __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
S return(result);
S}
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/* not yet supported */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 191 "D:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include\core_cm4.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM4_H_DEPENDANT
N#define __CORE_CM4_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M4 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N  - Core FPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31                                             /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30                                             /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29                                             /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28                                             /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27                                             /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N#define APSR_GE_Pos                        16                                             /*!< APSR: GE Position */
N#define APSR_GE_Msk                        (0xFUL << APSR_GE_Pos)                         /*!< APSR: GE Mask */
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0                                             /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
N    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
N    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31                                             /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30                                             /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29                                             /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28                                             /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27                                             /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25                                             /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24                                             /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_GE_Pos                        16                                             /*!< xPSR: GE Position */
N#define xPSR_GE_Msk                        (0xFUL << xPSR_GE_Pos)                         /*!< xPSR: GE Mask */
N
N#define xPSR_ISR_Pos                        0                                             /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_FPCA_Pos                    2                                             /*!< CONTROL: FPCA Position */
N#define CONTROL_FPCA_Msk                   (1UL << CONTROL_FPCA_Pos)                      /*!< CONTROL: FPCA Mask */
N
N#define CONTROL_SPSEL_Pos                   1                                             /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0                                             /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile const  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile const  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile const  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile const  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile const  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile const  uint32_t ICTR;                     
N  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
X  volatile uint32_t ACTLR;                    
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
N#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
N
N#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
N#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile const  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile const  uint32_t LSR;                      
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile const  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile const  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile const  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile const  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile const  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile const  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile const  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile const  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile const  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile const  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile const  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile const  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile const  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile const  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile const  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile const  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile const  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile const  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile const  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile const  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile const  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile const  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile const  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
N    \brief      Type definitions for the Floating Point Unit (FPU)
N  @{
N */
N
N/** \brief  Structure type to access the Floating Point Unit (FPU).
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
X  volatile uint32_t FPCCR;                    
N  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
X  volatile uint32_t FPCAR;                    
N  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
X  volatile uint32_t FPDSCR;                   
N  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
X  volatile const  uint32_t MVFR0;                    
N  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
X  volatile const  uint32_t MVFR1;                    
N} FPU_Type;
N
N/* Floating-Point Context Control Register */
N#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
N#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
N
N#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
N#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
N
N#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
N#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
N
N#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
N#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
N
N#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
N#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
N
N#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
N#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
N
N#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
N#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
N
N#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
N#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
N
N#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
N#define FPU_FPCCR_LSPACT_Msk               (1UL /*<< FPU_FPCCR_LSPACT_Pos*/)              /*!< FPCCR: Lazy state preservation active bit Mask */
N
N/* Floating-Point Context Address Register */
N#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
N#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
N
N/* Floating-Point Default Status Control Register */
N#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
N#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
N
N#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
N#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
N
N#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
N#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
N
N#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
N#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
N
N/* Media and FP Feature Register 0 */
N#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
N#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
N
N#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
N#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
N
N#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
N#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
N
N#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
N#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
N
N#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
N#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
N
N#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
N#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
N
N#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
N#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
N
N#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
N#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL /*<< FPU_MVFR0_A_SIMD_registers_Pos*/)  /*!< MVFR0: A_SIMD registers bits Mask */
N
N/* Media and FP Feature Register 1 */
N#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
N#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
N
N#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
N#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
N
N#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
N#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
N
N#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
N#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL /*<< FPU_MVFR1_FtZ_mode_Pos*/)          /*!< MVFR1: FtZ mode bits Mask */
N
N/*@} end of group CMSIS_FPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M4 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N#if (__FPU_PRESENT == 1)
X#if (1 == 1)
N  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
N  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16) | (7UL << 8)));              
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16) |
N                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8));
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if((int32_t)IRQn < 0) {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - 4)) & (uint32_t)0xFFUL);
N  }
N  else {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - 4)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if((int32_t)IRQn < 0) {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - 4)));
N  }
N  else {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - 4)));
N  }
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4)) ? (uint32_t)(4) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4)) ? (uint32_t)(4) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);                                                           
N  while(1) { __NOP(); }                                             /* wait until reset */
X  while(1) { __nop(); }                                              
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
X  if ((ticks - 1UL) > (0xFFFFFFUL )) { return (1UL); }     
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 4) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0].u32 == 0UL) { __NOP(); }
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0UL) { __nop(); }
N    ITM->PORT[0].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 240 "..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include\stm32f37x.h" 2
N#include "system_stm32f37x.h"    /* STM32F37x System Header */
L 1 "..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include\system_stm32f37x.h" 1
N/**
N  ******************************************************************************
N  * @file    system_stm32f37x.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer System Header File.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f37x_system
N  * @{
N  */  
N  
N/**
N  * @brief Define to prevent recursive inclusion
N  */
N#ifndef __SYSTEM_STM32F37X_H
N#define __SYSTEM_STM32F37X_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/** @addtogroup STM32F37x_System_Includes
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N
N/** @addtogroup STM32F37x_System_Exported_types
N  * @{
N  */
N
Nextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F37x_System_Exported_Constants
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F37x_System_Exported_Macros
N  * @{
N  */
N
N/**
N  * @}
N  */
N
N/** @addtogroup STM32F37x_System_Exported_Functions
N  * @{
N  */
N  
Nextern void SystemInit(void);
Nextern void SystemCoreClockUpdate(void);
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__SYSTEM_STM32F37X_H */
N
N/**
N  * @}
N  */
N  
N/**
N  * @}
N  */  
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 241 "..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include\stm32f37x.h" 2
N#include <stdint.h>
N
N/** @addtogroup Exported_types
N  * @{
N  */  
N/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
Ntypedef int32_t  s32;
Ntypedef int16_t s16;
Ntypedef int8_t  s8;
N
Ntypedef const int32_t sc32;  /*!< Read Only */
Ntypedef const int16_t sc16;  /*!< Read Only */
Ntypedef const int8_t sc8;   /*!< Read Only */
N
Ntypedef __IO int32_t  vs32;
Xtypedef volatile int32_t  vs32;
Ntypedef __IO int16_t  vs16;
Xtypedef volatile int16_t  vs16;
Ntypedef __IO int8_t   vs8;
Xtypedef volatile int8_t   vs8;
N
Ntypedef __I int32_t vsc32;  /*!< Read Only */
Xtypedef volatile const int32_t vsc32;   
Ntypedef __I int16_t vsc16;  /*!< Read Only */
Xtypedef volatile const int16_t vsc16;   
Ntypedef __I int8_t vsc8;   /*!< Read Only */
Xtypedef volatile const int8_t vsc8;    
N
Ntypedef uint32_t  u32;
Ntypedef uint16_t u16;
Ntypedef uint8_t  u8;
N
Ntypedef const uint32_t uc32;  /*!< Read Only */
Ntypedef const uint16_t uc16;  /*!< Read Only */
Ntypedef const uint8_t uc8;   /*!< Read Only */
N
Ntypedef __IO uint32_t  vu32;
Xtypedef volatile uint32_t  vu32;
Ntypedef __IO uint16_t vu16;
Xtypedef volatile uint16_t vu16;
Ntypedef __IO uint8_t  vu8;
Xtypedef volatile uint8_t  vu8;
N
Ntypedef __I uint32_t vuc32;  /*!< Read Only */
Xtypedef volatile const uint32_t vuc32;   
Ntypedef __I uint16_t vuc16;  /*!< Read Only */
Xtypedef volatile const uint16_t vuc16;   
Ntypedef __I uint8_t vuc8;   /*!< Read Only */
Xtypedef volatile const uint8_t vuc8;    
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_registers_structures
N  * @{
N  */   
N
N/** 
N  * @brief Analog to Digital Converter  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t SR;    /*!< ADC status register,                         Address offset: 0x00 */
X  volatile uint32_t SR;     
N  __IO uint32_t CR1;   /*!< ADC control register 1,                      Address offset: 0x04 */
X  volatile uint32_t CR1;    
N  __IO uint32_t CR2;   /*!< ADC control register 2,                      Address offset: 0x08 */
X  volatile uint32_t CR2;    
N  __IO uint32_t SMPR1; /*!< ADC sample time register 1,                  Address offset: 0x0C */
X  volatile uint32_t SMPR1;  
N  __IO uint32_t SMPR2; /*!< ADC sample time register 2,                  Address offset: 0x10 */
X  volatile uint32_t SMPR2;  
N  __IO uint32_t JOFR1; /*!< ADC injected channel data offset register 1, Address offset: 0x14 */
X  volatile uint32_t JOFR1;  
N  __IO uint32_t JOFR2; /*!< ADC injected channel data offset register 2, Address offset: 0x18 */
X  volatile uint32_t JOFR2;  
N  __IO uint32_t JOFR3; /*!< ADC injected channel data offset register 3, Address offset: 0x1C */
X  volatile uint32_t JOFR3;  
N  __IO uint32_t JOFR4; /*!< ADC injected channel data offset register 4, Address offset: 0x20 */
X  volatile uint32_t JOFR4;  
N  __IO uint32_t HTR;   /*!< ADC watchdog higher threshold register,      Address offset: 0x24 */
X  volatile uint32_t HTR;    
N  __IO uint32_t LTR;   /*!< ADC watchdog lower threshold register,       Address offset: 0x28 */
X  volatile uint32_t LTR;    
N  __IO uint32_t SQR1;  /*!< ADC regular sequence register 1,             Address offset: 0x2C */
X  volatile uint32_t SQR1;   
N  __IO uint32_t SQR2;  /*!< ADC regular sequence register 2,             Address offset: 0x30 */
X  volatile uint32_t SQR2;   
N  __IO uint32_t SQR3;  /*!< ADC regular sequence register 3,             Address offset: 0x34 */
X  volatile uint32_t SQR3;   
N  __IO uint32_t JSQR;  /*!< ADC injected sequence register,              Address offset: 0x38 */
X  volatile uint32_t JSQR;   
N  __IO uint32_t JDR1;  /*!< ADC injected data register 1,                Address offset: 0x3C */
X  volatile uint32_t JDR1;   
N  __IO uint32_t JDR2;  /*!< ADC injected data register 2,                Address offset: 0x40 */
X  volatile uint32_t JDR2;   
N  __IO uint32_t JDR3;  /*!< ADC injected data register 3,                Address offset: 0x44 */
X  volatile uint32_t JDR3;   
N  __IO uint32_t JDR4;  /*!< ADC injected data register 4,                Address offset: 0x48 */
X  volatile uint32_t JDR4;   
N  __IO uint32_t DR;    /*!< ADC regular data register,                   Address offset: 0x4C */
X  volatile uint32_t DR;     
N} ADC_TypeDef;
N  
N
N/** 
N  * @brief Controller Area Network TxMailBox 
N  */
Ntypedef struct
N{
N  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
X  volatile uint32_t TIR;   
N  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
X  volatile uint32_t TDTR;  
N  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
X  volatile uint32_t TDLR;  
N  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
X  volatile uint32_t TDHR;  
N} CAN_TxMailBox_TypeDef;
N
N/** 
N  * @brief Controller Area Network FIFOMailBox 
N  */
Ntypedef struct
N{
N  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
X  volatile uint32_t RIR;   
N  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
X  volatile uint32_t RDTR;  
N  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
X  volatile uint32_t RDLR;  
N  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
X  volatile uint32_t RDHR;  
N} CAN_FIFOMailBox_TypeDef;
N  
N/** 
N  * @brief Controller Area Network FilterRegister 
N  */
Ntypedef struct
N{
N  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR1;  
N  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
X  volatile uint32_t FR2;  
N} CAN_FilterRegister_TypeDef;
N
N/** 
N  * @brief Controller Area Network 
N  */
Ntypedef struct
N{
N  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
X  volatile uint32_t              MCR;                  
N  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
X  volatile uint32_t              MSR;                  
N  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
X  volatile uint32_t              TSR;                  
N  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
X  volatile uint32_t              RF0R;                 
N  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
X  volatile uint32_t              RF1R;                 
N  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
X  volatile uint32_t              IER;                  
N  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
X  volatile uint32_t              ESR;                  
N  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
X  volatile uint32_t              BTR;                  
N  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
N  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
N  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
N  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
N  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
X  volatile uint32_t              FMR;                  
N  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
X  volatile uint32_t              FM1R;                 
N  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
N  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
X  volatile uint32_t              FS1R;                 
N  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
N  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
X  volatile uint32_t              FFA1R;                
N  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
N  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
X  volatile uint32_t              FA1R;                 
N  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */
N  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
N} CAN_TypeDef;
N
N/** 
N  * @brief Consumer Electronics Control     
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;           /*!< CEC control register,              Address offset:0x00 */
X  volatile uint32_t CR;            
N  __IO uint32_t CFGR;         /*!< CEC configuration register,        Address offset:0x04 */
X  volatile uint32_t CFGR;          
N  __IO uint32_t TXDR;         /*!< CEC Tx data register ,             Address offset:0x08 */
X  volatile uint32_t TXDR;          
N  __IO uint32_t RXDR;         /*!< CEC Rx Data Register,              Address offset:0x0C */
X  volatile uint32_t RXDR;          
N  __IO uint32_t ISR;          /*!< CEC Interrupt and Status Register, Address offset:0x10 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IER;          /*!< CEC interrupt enable register,     Address offset:0x14 */
X  volatile uint32_t IER;           
N}CEC_TypeDef;
N
N/** 
N  * @brief Analog Comparators 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CSR;    /*!< Comparator control Status register, Address offset: 0x00 */
X  volatile uint32_t CSR;     
N} COMP_TypeDef;
N
N/** 
N  * @brief CRC calculation unit 
N  */
N
Ntypedef struct
N{
N  __IO uint32_t DR;          /*!< CRC Data register,                           Address offset: 0x00 */
X  volatile uint32_t DR;           
N  __IO uint8_t  IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
X  volatile uint8_t  IDR;          
N  uint8_t       RESERVED0;   /*!< Reserved,                                                    0x05 */
N  uint16_t      RESERVED1;   /*!< Reserved,                                                    0x06 */
N  __IO uint32_t CR;          /*!< CRC Control register,                        Address offset: 0x08 */
X  volatile uint32_t CR;           
N  uint32_t      RESERVED2;   /*!< Reserved,                                                    0x0C */
N  __IO uint32_t INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
X  volatile uint32_t INIT;         
N  __IO uint32_t POL;         /*!< CRC polynomial register,                     Address offset: 0x14 */
X  volatile uint32_t POL;          
N} CRC_TypeDef;
N
N/** 
N  * @brief Digital to Analog Converter
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;       /*!< DAC control register,                                    Address offset: 0x00 */
X  volatile uint32_t CR;        
N  __IO uint32_t SWTRIGR;  /*!< DAC software trigger register,                           Address offset: 0x04 */
X  volatile uint32_t SWTRIGR;   
N  __IO uint32_t DHR12R1;  /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
X  volatile uint32_t DHR12R1;   
N  __IO uint32_t DHR12L1;  /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
X  volatile uint32_t DHR12L1;   
N  __IO uint32_t DHR8R1;   /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
X  volatile uint32_t DHR8R1;    
N  __IO uint32_t DHR12R2;  /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
X  volatile uint32_t DHR12R2;   
N  __IO uint32_t DHR12L2;  /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
X  volatile uint32_t DHR12L2;   
N  __IO uint32_t DHR8R2;   /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
X  volatile uint32_t DHR8R2;    
N  __IO uint32_t DHR12RD;  /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
X  volatile uint32_t DHR12RD;   
N  __IO uint32_t DHR12LD;  /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
X  volatile uint32_t DHR12LD;   
N  __IO uint32_t DHR8RD;   /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
X  volatile uint32_t DHR8RD;    
N  __IO uint32_t DOR1;     /*!< DAC channel1 data output register,                       Address offset: 0x2C */
X  volatile uint32_t DOR1;      
N  __IO uint32_t DOR2;     /*!< DAC channel2 data output register,                       Address offset: 0x30 */
X  volatile uint32_t DOR2;      
N  __IO uint32_t SR;       /*!< DAC status register,                                     Address offset: 0x34 */
X  volatile uint32_t SR;        
N} DAC_TypeDef;
N
N/** 
N  * @brief Debug MCU
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IDCODE;  /*!< MCU device ID code,               Address offset: 0x00 */
X  volatile uint32_t IDCODE;   
N  __IO uint32_t CR;      /*!< Debug MCU configuration register, Address offset: 0x04 */
X  volatile uint32_t CR;       
N  __IO uint32_t APB1FZ;  /*!< Debug MCU APB1 freeze register,   Address offset: 0x08 */
X  volatile uint32_t APB1FZ;   
N  __IO uint32_t APB2FZ;  /*!< Debug MCU APB2 freeze register,   Address offset: 0x0C */
X  volatile uint32_t APB2FZ;   
N}DBGMCU_TypeDef;
N
N/** 
N  * @brief DMA Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CCR;          /*!< DMA channel x configuration register                                           */
X  volatile uint32_t CCR;           
N  __IO uint32_t CNDTR;        /*!< DMA channel x number of data register                                          */
X  volatile uint32_t CNDTR;         
N  __IO uint32_t CPAR;         /*!< DMA channel x peripheral address register                                      */
X  volatile uint32_t CPAR;          
N  __IO uint32_t CMAR;         /*!< DMA channel x memory address register                                          */
X  volatile uint32_t CMAR;          
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  __IO uint32_t ISR;          /*!< DMA interrupt status register,                            Address offset: 0x00 */
X  volatile uint32_t ISR;           
N  __IO uint32_t IFCR;         /*!< DMA interrupt flag clear register,                        Address offset: 0x04 */
X  volatile uint32_t IFCR;          
N} DMA_TypeDef;
N
N/** 
N  * @brief External Interrupt/Event Controller
N  */
N
Ntypedef struct
N{
N  __IO uint32_t IMR;          /*!<EXTI Interrupt mask register,                             Address offset: 0x00 */
X  volatile uint32_t IMR;           
N  __IO uint32_t EMR;          /*!<EXTI Event mask register,                                 Address offset: 0x04 */
X  volatile uint32_t EMR;           
N  __IO uint32_t RTSR;         /*!<EXTI Rising trigger selection register ,                  Address offset: 0x08 */
X  volatile uint32_t RTSR;          
N  __IO uint32_t FTSR;         /*!<EXTI Falling trigger selection register,                  Address offset: 0x0C */
X  volatile uint32_t FTSR;          
N  __IO uint32_t SWIER;        /*!<EXTI Software interrupt event register,                   Address offset: 0x10 */
X  volatile uint32_t SWIER;         
N  __IO uint32_t PR;           /*!<EXTI Pending register,                                    Address offset: 0x14 */
X  volatile uint32_t PR;            
N}EXTI_TypeDef;
N
N/** 
N  * @brief FLASH Registers
N  */
N
Ntypedef struct
N{
N  __IO uint32_t ACR;          /*!< FLASH access control register,              Address offset: 0x00 */
X  volatile uint32_t ACR;           
N  __IO uint32_t KEYR;         /*!< FLASH key register,                         Address offset: 0x04 */
X  volatile uint32_t KEYR;          
N  __IO uint32_t OPTKEYR;      /*!< FLASH option key register,                  Address offset: 0x08 */
X  volatile uint32_t OPTKEYR;       
N  __IO uint32_t SR;           /*!< FLASH status register,                      Address offset: 0x0C */
X  volatile uint32_t SR;            
N  __IO uint32_t CR;           /*!< FLASH control register,                     Address offset: 0x10 */
X  volatile uint32_t CR;            
N  __IO uint32_t AR;           /*!< FLASH address register,                     Address offset: 0x14 */
X  volatile uint32_t AR;            
N  uint32_t      RESERVED;     /*!< Reserved, 0x18                                                   */
N  __IO uint32_t OBR;          /*!< FLASH Option byte register,                 Address offset: 0x1C */
X  volatile uint32_t OBR;           
N  __IO uint32_t WRPR;         /*!< FLASH Write register,                       Address offset: 0x20 */
X  volatile uint32_t WRPR;          
N  
N} FLASH_TypeDef;
N
N/** 
N  * @brief Option Bytes Registers
N  */
Ntypedef struct
N{
N  __IO uint16_t RDP;          /*!<FLASH option byte Read protection,             Address offset: 0x00 */
X  volatile uint16_t RDP;           
N  __IO uint16_t USER;         /*!<FLASH option byte user options,                Address offset: 0x02 */
X  volatile uint16_t USER;          
N  uint16_t RESERVED0;         /*!< Reserved,                                                     0x04 */
N  uint16_t RESERVED1;         /*!< Reserved,                                                     0x06 */
N  __IO uint16_t WRP0;         /*!<FLASH option byte write protection 0,          Address offset: 0x08 */
X  volatile uint16_t WRP0;          
N  __IO uint16_t WRP1;         /*!<FLASH option byte write protection 1,          Address offset: 0x0C */
X  volatile uint16_t WRP1;          
N  __IO uint16_t WRP2;         /*!<FLASH option byte write protection 2,          Address offset: 0x10 */
X  volatile uint16_t WRP2;          
N  __IO uint16_t WRP3;         /*!<FLASH option byte write protection 3,          Address offset: 0x12 */
X  volatile uint16_t WRP3;          
N} OB_TypeDef;
N
N/** 
N  * @brief General Purpose I/O
N  */
N
Ntypedef struct
N{
N  __IO uint32_t MODER;        /*!< GPIO port mode register,                                  Address offset: 0x00 */
X  volatile uint32_t MODER;         
N  __IO uint16_t OTYPER;       /*!< GPIO port output type register,                           Address offset: 0x04 */
X  volatile uint16_t OTYPER;        
N  uint16_t RESERVED0;         /*!< Reserved,                                                                 0x06 */
N  __IO uint32_t OSPEEDR;      /*!< GPIO port output speed register,                          Address offset: 0x08 */
X  volatile uint32_t OSPEEDR;       
N  __IO uint32_t PUPDR;        /*!< GPIO port pull-up/pull-down register,                     Address offset: 0x0C */
X  volatile uint32_t PUPDR;         
N  __IO uint16_t IDR;          /*!< GPIO port input data register,                            Address offset: 0x10 */
X  volatile uint16_t IDR;           
N  uint16_t RESERVED1;         /*!< Reserved,                                                                 0x12 */
N  __IO uint16_t ODR;          /*!< GPIO port output data register,                           Address offset: 0x14 */
X  volatile uint16_t ODR;           
N  uint16_t RESERVED2;         /*!< Reserved,                                                                 0x16 */
N  __IO uint32_t BSRR;         /*!< GPIO port bit set/reset registerBSRR,                     Address offset: 0x18 */
X  volatile uint32_t BSRR;          
N  __IO uint32_t LCKR;         /*!< GPIO port configuration lock register,                    Address offset: 0x1C */
X  volatile uint32_t LCKR;          
N  __IO uint32_t AFR[2];       /*!< GPIO alternate function low register,                Address offset: 0x20-0x24 */
X  volatile uint32_t AFR[2];        
N  __IO uint16_t BRR;          /*!< GPIO bit reset register,                                  Address offset: 0x28 */
X  volatile uint16_t BRR;           
N  uint16_t RESERVED3;         /*!< Reserved,                                                                 0x2A */
N}GPIO_TypeDef;
N
N/** 
N  * @brief System configuration controller
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t CFGR1;       /*!< SYSCFG configuration register 1,                      Address offset: 0x00 */
X  volatile uint32_t CFGR1;        
N       uint32_t RESERVED;    /*!< Reserved,                                                             0x04 */
N  __IO uint32_t EXTICR[4];   /*!< SYSCFG control register,                              Adress offset: 0x14-0x08 */
X  volatile uint32_t EXTICR[4];    
N  __IO uint32_t CFGR2;       /*!< SYSCFG configuration register 2,                      Address offset: 0x18 */
X  volatile uint32_t CFGR2;        
N} SYSCFG_TypeDef;
N
N/** 
N  * @brief Inter-integrated Circuit Interface
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;      /*!< I2C Control register 1,            Address offset: 0x00 */
X  volatile uint32_t CR1;       
N  __IO uint32_t CR2;      /*!< I2C Control register 2,            Address offset: 0x04 */  
X  volatile uint32_t CR2;         
N  __IO uint32_t OAR1;     /*!< I2C Own address 1 register,        Address offset: 0x08 */
X  volatile uint32_t OAR1;      
N  __IO uint32_t OAR2;     /*!< I2C Own address 2 register,        Address offset: 0x0C */
X  volatile uint32_t OAR2;      
N  __IO uint32_t TIMINGR;  /*!< I2C Timing register,               Address offset: 0x10 */
X  volatile uint32_t TIMINGR;   
N  __IO uint32_t TIMEOUTR; /*!< I2C Timeout register,              Address offset: 0x14 */
X  volatile uint32_t TIMEOUTR;  
N  __IO uint32_t ISR;      /*!< I2C Interrupt and status register, Address offset: 0x18 */
X  volatile uint32_t ISR;       
N  __IO uint32_t ICR;      /*!< I2C Interrupt clear register,      Address offset: 0x1C */
X  volatile uint32_t ICR;       
N  __IO uint32_t PECR;     /*!< I2C PEC register,                  Address offset: 0x20 */
X  volatile uint32_t PECR;      
N  __IO uint32_t RXDR;     /*!< I2C Receive data register,         Address offset: 0x24 */
X  volatile uint32_t RXDR;      
N  __IO uint32_t TXDR;     /*!< I2C Transmit data register,        Address offset: 0x28 */  
X  volatile uint32_t TXDR;        
N}I2C_TypeDef;
N
N/** 
N  * @brief Independent WATCHDOG
N  */
N
Ntypedef struct
N{
N  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
X  volatile uint32_t KR;    
N  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
X  volatile uint32_t PR;    
N  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
X  volatile uint32_t RLR;   
N  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
X  volatile uint32_t SR;    
N  __IO uint32_t WINR; /*!< IWDG Window register,    Address offset: 0x10 */ 
X  volatile uint32_t WINR;   
N} IWDG_TypeDef;
N
N/** 
N  * @brief Power Control
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
X  volatile uint32_t CSR;   
N} PWR_TypeDef;
N
N/** 
N  * @brief Reset and Clock Control
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;         /*!< RCC clock control register,                                  Address offset: 0x00 */
X  volatile uint32_t CR;          
N  __IO uint32_t CFGR;       /*!< RCC clock configuration register,                            Address offset: 0x04 */
X  volatile uint32_t CFGR;        
N  __IO uint32_t CIR;        /*!< RCC clock interrupt register,                                Address offset: 0x08 */
X  volatile uint32_t CIR;         
N  __IO uint32_t APB2RSTR;   /*!< RCC APB2 peripheral reset register,                          Address offset: 0x0C */
X  volatile uint32_t APB2RSTR;    
N  __IO uint32_t APB1RSTR;   /*!< RCC APB1 peripheral reset register,                          Address offset: 0x10 */
X  volatile uint32_t APB1RSTR;    
N  __IO uint32_t AHBENR;     /*!< RCC AHB peripheral clock register,                           Address offset: 0x14 */
X  volatile uint32_t AHBENR;      
N  __IO uint32_t APB2ENR;    /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x18 */
X  volatile uint32_t APB2ENR;     
N  __IO uint32_t APB1ENR;    /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x1C */
X  volatile uint32_t APB1ENR;     
N  __IO uint32_t BDCR;       /*!< RCC Backup domain control register,                          Address offset: 0x20 */ 
X  volatile uint32_t BDCR;         
N  __IO uint32_t CSR;        /*!< RCC clock control & status register,                         Address offset: 0x24 */
X  volatile uint32_t CSR;         
N  __IO uint32_t AHBRSTR;    /*!< RCC AHB peripheral reset register,                           Address offset: 0x28 */
X  volatile uint32_t AHBRSTR;     
N  __IO uint32_t CFGR2;      /*!< RCC clock configuration register 2,                          Address offset: 0x2C */
X  volatile uint32_t CFGR2;       
N  __IO uint32_t CFGR3;      /*!< RCC clock configuration register 3,                          Address offset: 0x30 */ 
X  volatile uint32_t CFGR3;        
N} RCC_TypeDef;
N
N/** 
N  * @brief Real-Time Clock
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t TR;         /*!< RTC time register,                                        Address offset: 0x00 */
X  volatile uint32_t TR;          
N  __IO uint32_t DR;         /*!< RTC date register,                                        Address offset: 0x04 */
X  volatile uint32_t DR;          
N  __IO uint32_t CR;         /*!< RTC control register,                                     Address offset: 0x08 */
X  volatile uint32_t CR;          
N  __IO uint32_t ISR;        /*!< RTC initialization and status register,                   Address offset: 0x0C */
X  volatile uint32_t ISR;         
N  __IO uint32_t PRER;       /*!< RTC prescaler register,                                   Address offset: 0x10 */
X  volatile uint32_t PRER;        
N  __IO uint32_t WUTR;       /*!< RTC wakeup timer register,                                Address offset: 0x14 */
X  volatile uint32_t WUTR;        
N  uint32_t RESERVED0;       /*!< Reserved, 0x18                                                                 */
N  __IO uint32_t ALRMAR;     /*!< RTC alarm A register,                                     Address offset: 0x1C */
X  volatile uint32_t ALRMAR;      
N  __IO uint32_t ALRMBR;     /*!< RTC alarm B register,                                     Address offset: 0x20 */
X  volatile uint32_t ALRMBR;      
N  __IO uint32_t WPR;        /*!< RTC write protection register,                            Address offset: 0x24 */
X  volatile uint32_t WPR;         
N  __IO uint32_t SSR;        /*!< RTC sub second register,                                  Address offset: 0x28 */
X  volatile uint32_t SSR;         
N  __IO uint32_t SHIFTR;     /*!< RTC shift control register,                               Address offset: 0x2C */
X  volatile uint32_t SHIFTR;      
N  __IO uint32_t TSTR;       /*!< RTC time stamp time register,                             Address offset: 0x30 */
X  volatile uint32_t TSTR;        
N  __IO uint32_t TSDR;       /*!< RTC time stamp date register,                             Address offset: 0x34 */
X  volatile uint32_t TSDR;        
N  __IO uint32_t TSSSR;      /*!< RTC time-stamp sub second register,                       Address offset: 0x38 */
X  volatile uint32_t TSSSR;       
N  __IO uint32_t CALR;       /*!< RTC calibration register,                                 Address offset: 0x3C */
X  volatile uint32_t CALR;        
N  __IO uint32_t TAFCR;      /*!< RTC tamper and alternate function configuration register, Address offset: 0x40 */
X  volatile uint32_t TAFCR;       
N  __IO uint32_t ALRMASSR;   /*!< RTC alarm A sub second register,                          Address offset: 0x44 */
X  volatile uint32_t ALRMASSR;    
N  __IO uint32_t ALRMBSSR;   /*!< RTC alarm B sub second register,                          Address offset: 0x48 */
X  volatile uint32_t ALRMBSSR;    
N  uint32_t RESERVED7;       /*!< Reserved, 0x4C                                                                 */
N  __IO uint32_t BKP0R;      /*!< RTC backup register 0,                                    Address offset: 0x50 */
X  volatile uint32_t BKP0R;       
N  __IO uint32_t BKP1R;      /*!< RTC backup register 1,                                    Address offset: 0x54 */
X  volatile uint32_t BKP1R;       
N  __IO uint32_t BKP2R;      /*!< RTC backup register 2,                                    Address offset: 0x58 */
X  volatile uint32_t BKP2R;       
N  __IO uint32_t BKP3R;      /*!< RTC backup register 3,                                    Address offset: 0x5C */
X  volatile uint32_t BKP3R;       
N  __IO uint32_t BKP4R;      /*!< RTC backup register 4,                                    Address offset: 0x60 */
X  volatile uint32_t BKP4R;       
N  __IO uint32_t BKP5R;      /*!< RTC backup register 5,                                    Address offset: 0x64 */
X  volatile uint32_t BKP5R;       
N  __IO uint32_t BKP6R;      /*!< RTC backup register 6,                                    Address offset: 0x68 */
X  volatile uint32_t BKP6R;       
N  __IO uint32_t BKP7R;      /*!< RTC backup register 7,                                    Address offset: 0x6C */
X  volatile uint32_t BKP7R;       
N  __IO uint32_t BKP8R;      /*!< RTC backup register 8,                                    Address offset: 0x70 */
X  volatile uint32_t BKP8R;       
N  __IO uint32_t BKP9R;      /*!< RTC backup register 9,                                    Address offset: 0x74 */
X  volatile uint32_t BKP9R;       
N  __IO uint32_t BKP10R;     /*!< RTC backup register 10,                                   Address offset: 0x78 */
X  volatile uint32_t BKP10R;      
N  __IO uint32_t BKP11R;     /*!< RTC backup register 11,                                   Address offset: 0x7C */
X  volatile uint32_t BKP11R;      
N  __IO uint32_t BKP12R;     /*!< RTC backup register 12,                                   Address offset: 0x80 */
X  volatile uint32_t BKP12R;      
N  __IO uint32_t BKP13R;     /*!< RTC backup register 13,                                   Address offset: 0x84 */
X  volatile uint32_t BKP13R;      
N  __IO uint32_t BKP14R;     /*!< RTC backup register 14,                                   Address offset: 0x88 */
X  volatile uint32_t BKP14R;      
N  __IO uint32_t BKP15R;     /*!< RTC backup register 15,                                   Address offset: 0x8C */
X  volatile uint32_t BKP15R;      
N  __IO uint32_t BKP16R;     /*!< RTC backup register 16,                                   Address offset: 0x90 */
X  volatile uint32_t BKP16R;      
N  __IO uint32_t BKP17R;     /*!< RTC backup register 17,                                   Address offset: 0x94 */
X  volatile uint32_t BKP17R;      
N  __IO uint32_t BKP18R;     /*!< RTC backup register 18,                                   Address offset: 0x98 */
X  volatile uint32_t BKP18R;      
N  __IO uint32_t BKP19R;     /*!< RTC backup register 19,                                   Address offset: 0x9C */
X  volatile uint32_t BKP19R;      
N  __IO uint32_t BKP20R;     /*!< RTC backup register 20,                                   Address offset: 0xA0 */
X  volatile uint32_t BKP20R;      
N  __IO uint32_t BKP21R;     /*!< RTC backup register 21,                                   Address offset: 0xA4 */
X  volatile uint32_t BKP21R;      
N  __IO uint32_t BKP22R;     /*!< RTC backup register 22,                                   Address offset: 0xA8 */
X  volatile uint32_t BKP22R;      
N  __IO uint32_t BKP23R;     /*!< RTC backup register 23,                                   Address offset: 0xAC */
X  volatile uint32_t BKP23R;      
N  __IO uint32_t BKP24R;     /*!< RTC backup register 24,                                   Address offset: 0xB0 */
X  volatile uint32_t BKP24R;      
N  __IO uint32_t BKP25R;     /*!< RTC backup register 25,                                   Address offset: 0xB4 */
X  volatile uint32_t BKP25R;      
N  __IO uint32_t BKP26R;     /*!< RTC backup register 26,                                   Address offset: 0xB8 */
X  volatile uint32_t BKP26R;      
N  __IO uint32_t BKP27R;     /*!< RTC backup register 27,                                   Address offset: 0xBC */
X  volatile uint32_t BKP27R;      
N  __IO uint32_t BKP28R;     /*!< RTC backup register 28,                                   Address offset: 0xC0 */
X  volatile uint32_t BKP28R;      
N  __IO uint32_t BKP29R;     /*!< RTC backup register 29,                                   Address offset: 0xC4 */
X  volatile uint32_t BKP29R;      
N  __IO uint32_t BKP30R;     /*!< RTC backup register 30,                                   Address offset: 0xC8 */
X  volatile uint32_t BKP30R;      
N  __IO uint32_t BKP31R;     /*!< RTC backup register 31,                                   Address offset: 0xCC */
X  volatile uint32_t BKP31R;      
N} RTC_TypeDef;
N
N
N/** 
N  * @brief Sigma-Delta Analog to Digital Converter (SDADC)  
N  */
N
Ntypedef struct
N{
N  __IO uint32_t CR1;          /*!< SDADC control register 1,                        Address offset: 0x00 */
X  volatile uint32_t CR1;           
N  __IO uint32_t CR2;          /*!< SDADC control register 2,                        Address offset: 0x04 */
X  volatile uint32_t CR2;           
N  __IO uint32_t ISR;          /*!< SDADC interrupt and status register,             Address offset: 0x08 */
X  volatile uint32_t ISR;           
N  __IO uint32_t CLRISR;       /*!< SDADC clear interrupt and status register,       Address offset: 0x0C */
X  volatile uint32_t CLRISR;        
N  __IO uint32_t RESERVED0;    /*!< Reserved, 0x10                                                        */
X  volatile uint32_t RESERVED0;     
N  __IO uint32_t JCHGR;        /*!< SDADC injected channel group selection register, Address offset: 0x14 */
X  volatile uint32_t JCHGR;         
N  __IO uint32_t RESERVED1;    /*!< Reserved, 0x18                                                        */
X  volatile uint32_t RESERVED1;     
N  __IO uint32_t RESERVED2;    /*!< Reserved, 0x1C                                                        */
X  volatile uint32_t RESERVED2;     
N  __IO uint32_t CONF0R;       /*!< SDADC configuration 0 register,                  Address offset: 0x20 */
X  volatile uint32_t CONF0R;        
N  __IO uint32_t CONF1R;       /*!< SDADC configuration 1 register,                  Address offset: 0x24 */
X  volatile uint32_t CONF1R;        
N  __IO uint32_t CONF2R;       /*!< SDADC configuration 2 register,                  Address offset: 0x28 */
X  volatile uint32_t CONF2R;        
N  __IO uint32_t RESERVED3[5]; /*!< Reserved, 0x2C - 0x3C                                                 */
X  volatile uint32_t RESERVED3[5];  
N  __IO uint32_t CONFCHR1;     /*!< SDADC channel configuration register 1,          Address offset: 0x40 */
X  volatile uint32_t CONFCHR1;      
N  __IO uint32_t CONFCHR2;     /*!< SDADC channel configuration register 2,          Address offset: 0x44 */
X  volatile uint32_t CONFCHR2;      
N  __IO uint32_t RESERVED4[6]; /*!< Reserved, 0x48 - 0x5C                                                 */
X  volatile uint32_t RESERVED4[6];  
N  __IO uint32_t JDATAR;       /*!< SDADC data register for injected group,          Address offset: 0x60 */
X  volatile uint32_t JDATAR;        
N  __IO uint32_t RDATAR;       /*!< SDADC data register for the regular channel,     Address offset: 0x64 */
X  volatile uint32_t RDATAR;        
N  __IO uint32_t RESERVED5[2]; /*!< Reserved, 0x68 - 0x6C                                                 */
X  volatile uint32_t RESERVED5[2];  
N  __IO uint32_t JDATA12R;     /*!< SDADC1 and SDADC2 injected data register,        Address offset: 0x70 */
X  volatile uint32_t JDATA12R;      
N  __IO uint32_t RDATA12R;     /*!< SDADC1 and SDADC2 regular data register,         Address offset: 0x74 */
X  volatile uint32_t RDATA12R;      
N  __IO uint32_t JDATA13R;     /*!< SDADC1 and SDADC3 injected data register,        Address offset: 0x78 */
X  volatile uint32_t JDATA13R;      
N  __IO uint32_t RDATA13R;     /*!< SDADC1 and SDADC3 regular data register,         Address offset: 0x7C */
X  volatile uint32_t RDATA13R;      
N} SDADC_TypeDef;
N
N/** 
N  * @brief Serial Peripheral Interface
N  */
N  
Ntypedef struct
N{
N  __IO uint16_t CR1;      /*!< SPI Control register 1 (not used in I2S mode),       Address offset: 0x00 */
X  volatile uint16_t CR1;       
N  uint16_t  RESERVED0;    /*!< Reserved, 0x02                                                            */
N  __IO uint16_t CR2;      /*!< SPI Control register 2,                              Address offset: 0x04 */
X  volatile uint16_t CR2;       
N  uint16_t  RESERVED1;    /*!< Reserved, 0x06                                                            */
N  __IO uint16_t SR;       /*!< SPI Status register,                                 Address offset: 0x08 */
X  volatile uint16_t SR;        
N  uint16_t  RESERVED2;    /*!< Reserved, 0x0A                                                            */
N  __IO uint16_t DR;       /*!< SPI data register,                                   Address offset: 0x0C */
X  volatile uint16_t DR;        
N  uint16_t  RESERVED3;    /*!< Reserved, 0x0E                                                            */
N  __IO uint16_t CRCPR;    /*!< SPI CRC polynomial register (not used in I2S mode),  Address offset: 0x10 */
X  volatile uint16_t CRCPR;     
N  uint16_t  RESERVED4;    /*!< Reserved, 0x12                                                            */
N  __IO uint16_t RXCRCR;   /*!< SPI Rx CRC register (not used in I2S mode),          Address offset: 0x14 */
X  volatile uint16_t RXCRCR;    
N  uint16_t  RESERVED5;    /*!< Reserved, 0x16                                                            */
N  __IO uint16_t TXCRCR;   /*!< SPI Tx CRC register (not used in I2S mode),          Address offset: 0x18 */
X  volatile uint16_t TXCRCR;    
N  uint16_t  RESERVED6;    /*!< Reserved, 0x1A                                                            */ 
N  __IO uint16_t I2SCFGR;  /*!< SPI_I2S configuration register,                      Address offset: 0x1C */
X  volatile uint16_t I2SCFGR;   
N  uint16_t  RESERVED7;    /*!< Reserved, 0x1E                                                            */
N  __IO uint16_t I2SPR;    /*!< SPI_I2S prescaler register,                          Address offset: 0x20 */
X  volatile uint16_t I2SPR;     
N  uint16_t  RESERVED8;    /*!< Reserved, 0x22                                                            */    
N} SPI_TypeDef;
N
N
N/** 
N  * @brief TIM
N  */
Ntypedef struct
N{
N  __IO uint16_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
X  volatile uint16_t CR1;          
N  uint16_t      RESERVED0;   /*!< Reserved, 0x02                                            */
N  __IO uint16_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
X  volatile uint16_t CR2;          
N  uint16_t      RESERVED1;   /*!< Reserved, 0x06                                            */
N  __IO uint16_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
X  volatile uint16_t SMCR;         
N  uint16_t      RESERVED2;   /*!< Reserved, 0x0A                                            */
N  __IO uint16_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
X  volatile uint16_t DIER;         
N  uint16_t      RESERVED3;   /*!< Reserved, 0x0E                                            */
N  __IO uint16_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
X  volatile uint16_t SR;           
N  uint16_t      RESERVED4;   /*!< Reserved, 0x12                                            */
N  __IO uint16_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
X  volatile uint16_t EGR;          
N  uint16_t      RESERVED5;   /*!< Reserved, 0x16                                            */
N  __IO uint16_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
X  volatile uint16_t CCMR1;        
N  uint16_t      RESERVED6;   /*!< Reserved, 0x1A                                            */
N  __IO uint16_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
X  volatile uint16_t CCMR2;        
N  uint16_t      RESERVED7;   /*!< Reserved, 0x1E                                            */
N  __IO uint16_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
X  volatile uint16_t CCER;         
N  uint16_t      RESERVED8;   /*!< Reserved, 0x22                                            */
N  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
X  volatile uint32_t CNT;          
N  __IO uint16_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
X  volatile uint16_t PSC;          
N  uint16_t      RESERVED9;   /*!< Reserved, 0x2A                                            */
N  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
X  volatile uint32_t ARR;          
N  __IO uint16_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
X  volatile uint16_t RCR;          
N  uint16_t      RESERVED10;  /*!< Reserved, 0x32                                            */
N  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
X  volatile uint32_t CCR1;         
N  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
X  volatile uint32_t CCR2;         
N  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
X  volatile uint32_t CCR3;         
N  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
X  volatile uint32_t CCR4;         
N  __IO uint16_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
X  volatile uint16_t BDTR;         
N  uint16_t      RESERVED11;  /*!< Reserved, 0x46                                            */
N  __IO uint16_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
X  volatile uint16_t DCR;          
N  uint16_t      RESERVED12;  /*!< Reserved, 0x4A                                            */
N  __IO uint16_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
X  volatile uint16_t DMAR;         
N  uint16_t      RESERVED13;  /*!< Reserved, 0x4E                                            */
N  __IO uint16_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
X  volatile uint16_t OR;           
N  uint16_t      RESERVED14;  /*!< Reserved, 0x52                                            */
N} TIM_TypeDef;
N
N/** 
N  * @brief Touch Sensing Controller (TSC)
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;            /*!< TSC control register,                                     Address offset: 0x00 */
X  volatile uint32_t CR;             
N  __IO uint32_t IER;           /*!< TSC interrupt enable register,                            Address offset: 0x04 */
X  volatile uint32_t IER;            
N  __IO uint32_t ICR;           /*!< TSC interrupt clear register,                             Address offset: 0x08 */
X  volatile uint32_t ICR;            
N  __IO uint32_t ISR;           /*!< TSC interrupt status register,                            Address offset: 0x0C */
X  volatile uint32_t ISR;            
N  __IO uint32_t IOHCR;         /*!< TSC I/O hysteresis control register,                      Address offset: 0x10 */
X  volatile uint32_t IOHCR;          
N  uint32_t      RESERVED1;     /*!< Reserved,                                                 Address offset: 0x14 */
N  __IO uint32_t IOASCR;        /*!< TSC I/O analog switch control register,                   Address offset: 0x18 */
X  volatile uint32_t IOASCR;         
N  uint32_t      RESERVED2;     /*!< Reserved,                                                 Address offset: 0x1C */
N  __IO uint32_t IOSCR;         /*!< TSC I/O sampling control register,                        Address offset: 0x20 */
X  volatile uint32_t IOSCR;          
N  uint32_t      RESERVED3;     /*!< Reserved,                                                 Address offset: 0x24 */
N  __IO uint32_t IOCCR;         /*!< TSC I/O channel control register,                         Address offset: 0x28 */
X  volatile uint32_t IOCCR;          
N  uint32_t      RESERVED4;     /*!< Reserved,                                                 Address offset: 0x2C */
N  __IO uint32_t IOGCSR;        /*!< TSC I/O group control status register,                    Address offset: 0x30 */
X  volatile uint32_t IOGCSR;         
N  __IO uint32_t IOGXCR[8];     /*!< TSC I/O group x counter register,                         Address offset: 0x34-50 */
X  volatile uint32_t IOGXCR[8];      
N} TSC_TypeDef;
N/** 
N  * @brief Universal Synchronous Asynchronous Receiver Transmitter
N  */
N  
Ntypedef struct
N{
N  __IO uint32_t CR1;    /*!< USART Control register 1,                 Address offset: 0x00 */ 
X  volatile uint32_t CR1;      
N  __IO uint32_t CR2;    /*!< USART Control register 2,                 Address offset: 0x04 */ 
X  volatile uint32_t CR2;      
N  __IO uint32_t CR3;    /*!< USART Control register 3,                 Address offset: 0x08 */
X  volatile uint32_t CR3;     
N  __IO uint16_t BRR;    /*!< USART Baud rate register,                 Address offset: 0x0C */
X  volatile uint16_t BRR;     
N  uint16_t  RESERVED1;  /*!< Reserved, 0x0E                                                 */  
N  __IO uint16_t GTPR;   /*!< USART Guard time and prescaler register,  Address offset: 0x10 */
X  volatile uint16_t GTPR;    
N  uint16_t  RESERVED2;  /*!< Reserved, 0x12                                                 */
N  __IO uint32_t RTOR;   /*!< USART Receiver Time Out register,         Address offset: 0x14 */  
X  volatile uint32_t RTOR;      
N  __IO uint16_t RQR;    /*!< USART Request register,                   Address offset: 0x18 */
X  volatile uint16_t RQR;     
N  uint16_t  RESERVED3;  /*!< Reserved, 0x1A                                                 */
N  __IO uint32_t ISR;    /*!< USART Interrupt and status register,      Address offset: 0x1C */
X  volatile uint32_t ISR;     
N  __IO uint32_t ICR;    /*!< USART Interrupt flag Clear register,      Address offset: 0x20 */
X  volatile uint32_t ICR;     
N  __IO uint16_t RDR;    /*!< USART Receive Data register,              Address offset: 0x24 */
X  volatile uint16_t RDR;     
N  uint16_t  RESERVED4;  /*!< Reserved, 0x26                                                 */
N  __IO uint16_t TDR;    /*!< USART Transmit Data register,             Address offset: 0x28 */
X  volatile uint16_t TDR;     
N  uint16_t  RESERVED5;  /*!< Reserved, 0x2A                                                 */
N} USART_TypeDef; 
N
N/** 
N  * @brief Window WATCHDOG
N  */
Ntypedef struct
N{
N  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
X  volatile uint32_t CR;    
N  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
X  volatile uint32_t CFR;   
N  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
X  volatile uint32_t SR;    
N} WWDG_TypeDef;
N
N  
N/** @addtogroup Peripheral_memory_map
N  * @{
N  */
N
N#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
N#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
N#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
N
N#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */
N#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */
N
N
N/*!< Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000)
N#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)
N#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x08000000)
N
N/*!< APB1 peripherals */
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
N#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
N#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC1_BASE             (APB1PERIPH_BASE + 0x7400)
N#define CEC_BASE              (APB1PERIPH_BASE + 0x7800)
N#define DAC2_BASE             (APB1PERIPH_BASE + 0x9800)
N#define TIM18_BASE            (APB1PERIPH_BASE + 0x9C00)
N
N/*!< APB2 peripherals */
N#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x0000)
N#define COMP_BASE             (APB2PERIPH_BASE + 0x001C)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define TIM15_BASE            (APB2PERIPH_BASE + 0x4000)
N#define TIM16_BASE            (APB2PERIPH_BASE + 0x4400)
N#define TIM17_BASE            (APB2PERIPH_BASE + 0x4800)
N#define TIM19_BASE            (APB2PERIPH_BASE + 0x5C00)
N#define SDADC1_BASE           (APB2PERIPH_BASE + 0x6000)
N#define SDADC2_BASE           (APB2PERIPH_BASE + 0x6400)
N#define SDADC3_BASE           (APB2PERIPH_BASE + 0x6800)
N
N/*!< AHB1 peripherals */
N#define DMA1_BASE             (AHB1PERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHB1PERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHB1PERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHB1PERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHB1PERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHB1PERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHB1PERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHB1PERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHB1PERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHB1PERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHB1PERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHB1PERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHB1PERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHB1PERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHB1PERIPH_BASE + 0x1000)
N#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x2000) /*!< Flash registers base address */
N#define OB_BASE               ((uint32_t)0x1FFFF800)     /*!< Flash Option Bytes base address */
N#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000)
N#define TSC_BASE              (AHB1PERIPH_BASE + 0x00004000)
N
N/*!< AHB2 peripherals */
N#define GPIOA_BASE            (AHB2PERIPH_BASE + 0x0000)
N#define GPIOB_BASE            (AHB2PERIPH_BASE + 0x0400)
N#define GPIOC_BASE            (AHB2PERIPH_BASE + 0x0800)
N#define GPIOD_BASE            (AHB2PERIPH_BASE + 0x0C00)
N#define GPIOE_BASE            (AHB2PERIPH_BASE + 0x1000)
N#define GPIOF_BASE            (AHB2PERIPH_BASE + 0x1400)
N
N#define DBGMCU_BASE          ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */
N/**
N  * @}
N  */
N
N/** @addtogroup Peripheral_declaration
N  * @{
N  */
N#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
N#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
N#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
N#define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#define USART2              ((USART_TypeDef *) USART2_BASE)
N#define USART3              ((USART_TypeDef *) USART3_BASE)
N#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
N#define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#define DAC1                ((DAC_TypeDef *) DAC1_BASE)
N#define DAC2                ((DAC_TypeDef *) DAC2_BASE)
N#define CEC                 ((CEC_TypeDef *) CEC_BASE)
N#define COMP                ((COMP_TypeDef *) COMP_BASE)
N#define TIM18               ((TIM_TypeDef *) TIM18_BASE)
N#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
N#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#define USART1              ((USART_TypeDef *) USART1_BASE)
N#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
N#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
N#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
N#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#define TIM19               ((TIM_TypeDef *) TIM19_BASE)
N#define SDADC1              ((SDADC_TypeDef *) SDADC1_BASE)
N#define SDADC2              ((SDADC_TypeDef *) SDADC2_BASE)
N#define SDADC3              ((SDADC_TypeDef *) SDADC3_BASE)
N#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
N#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N#define OB                  ((OB_TypeDef *) OB_BASE)
N#define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#define TSC                 ((TSC_TypeDef *) TSC_BASE)
N#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N
N/**
N  * @}
N  */
N
N/** @addtogroup Exported_constants
N  * @{
N  */
N
N  /** @addtogroup Peripheral_Registers_Bits_Definition
N  * @{
N  */
N
N/******************************************************************************/
N/*                         Peripheral Registers_Bits_Definition               */
N/******************************************************************************/
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Analog to Digital Converter SAR (ADC)               */
N/*                                                                            */
N/******************************************************************************/
N
N/********************  Bit definition for ADC_SR register  ********************/
N#define  ADC_SR_AWD                          ((uint32_t)0x00000001)  /*!< Analog watchdog flag */
N#define  ADC_SR_EOC                          ((uint32_t)0x00000002)  /*!< End of conversion */
N#define  ADC_SR_JEOC                         ((uint32_t)0x00000004)  /*!< Injected channel end of conversion */
N#define  ADC_SR_JSTRT                        ((uint32_t)0x00000008)  /*!< Injected channel Start flag */
N#define  ADC_SR_STRT                         ((uint32_t)0x00000010)  /*!< Regular channel Start flag */
N
N/*******************  Bit definition for ADC_CR1 register  ********************/
N#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)  /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
N#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)  /*!< Bit 0 */
N#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)  /*!< Bit 1 */
N#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)  /*!< Bit 2 */
N#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)  /*!< Bit 3 */
N#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)  /*!< Bit 4 */
N#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)  /*!< Interrupt enable for EOC */
N#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)  /*!< Analog Watchdog interrupt enable */
N#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)  /*!< Interrupt enable for injected channels */
N#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)  /*!< Scan mode */
N#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)  /*!< Enable the watchdog on a single channel in scan mode */
N#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)  /*!< Automatic injected group conversion */
N#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)  /*!< Discontinuous mode on regular channels */
N#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)  /*!< Discontinuous mode on injected channels */
N#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)  /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */
N#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)  /*!< Bit 0 */
N#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)  /*!< Bit 1 */
N#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)  /*!< Bit 2 */
N#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)  /*!< Analog watchdog enable on injected channels */
N#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)  /*!< Analog watchdog enable on regular channels */
N
N/*******************  Bit definition for ADC_CR2 register  ********************/
N#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)  /*!< A/D Converter ON / OFF */
N#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)  /*!< Continuous Conversion */
N#define  ADC_CR2_CAL                         ((uint32_t)0x00000004)  /*!< A/D Calibration */
N#define  ADC_CR2_RSTCAL                      ((uint32_t)0x00000008)  /*!< Reset Calibration */
N#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)  /*!< Direct Memory access mode */
N#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)  /*!< Data Alignment */
N#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x00007000)  /*!< JEXTSEL[2:0] bits (External event select for injected group) */
N#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00001000)  /*!< Bit 0 */
N#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00002000)  /*!< Bit 1 */
N#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00004000)  /*!< Bit 2 */
N#define  ADC_CR2_JEXTTRIG                    ((uint32_t)0x00008000)  /*!< External Trigger Conversion mode for injected channels */
N#define  ADC_CR2_EXTSEL                      ((uint32_t)0x000E0000)  /*!< EXTSEL[2:0] bits (External Event Select for regular group) */
N#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x00020000)  /*!< Bit 0 */
N#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x00040000)  /*!< Bit 1 */
N#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x00080000)  /*!< Bit 2 */
N#define  ADC_CR2_EXTTRIG                     ((uint32_t)0x00100000)  /*!< External Trigger Conversion mode for regular channels */
N#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00200000)  /*!< Start Conversion of injected channels */
N#define  ADC_CR2_SWSTART                     ((uint32_t)0x00400000)  /*!< Start Conversion of regular channels */
N#define  ADC_CR2_TSVREFE                     ((uint32_t)0x00800000)  /*!< Temperature Sensor and VREFINT Enable */
N
N/******************  Bit definition for ADC_SMPR1 register  *******************/
N#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)  /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */
N#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)  /*!< Bit 0 */
N#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)  /*!< Bit 1 */
N#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)  /*!< Bit 2 */
N#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)  /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */
N#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)  /*!< Bit 0 */
N#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)  /*!< Bit 1 */
N#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)  /*!< Bit 2 */
N#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)  /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */
N#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)  /*!< Bit 0 */
N#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)  /*!< Bit 1 */
N#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)  /*!< Bit 2 */
N#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)  /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */
N#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)  /*!< Bit 0 */
N#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)  /*!< Bit 1 */
N#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)  /*!< Bit 2 */
N#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)  /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */
N#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)  /*!< Bit 0 */
N#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)  /*!< Bit 1 */
N#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)  /*!< Bit 2 */
N#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)  /*!< SMP15[2:0] bits (Channel 15 Sample time selection) */
N#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */
N#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
N#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */
N#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
N#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
N#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
N
N/******************  Bit definition for ADC_SMPR2 register  *******************/
N#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */
N#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
N#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */
N#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */
N#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */
N#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */
N#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */
N#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */
N#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */
N#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */
N#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */
N#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
N#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */
N
N/******************  Bit definition for ADC_JOFR1 register  *******************/
N#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 1 */
N
N/******************  Bit definition for ADC_JOFR2 register  *******************/
N#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 2 */
N
N/******************  Bit definition for ADC_JOFR3 register  *******************/
N#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 3 */
N
N/******************  Bit definition for ADC_JOFR4 register  *******************/
N#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 4 */
N
N/*******************  Bit definition for ADC_HTR register  ********************/
N#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog high threshold */
N
N/*******************  Bit definition for ADC_LTR register  ********************/
N#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog low threshold */
N
N/*******************  Bit definition for ADC_SQR1 register  *******************/
N#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */
N#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */
N#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
N#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */
N#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
N#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */
N#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */
N#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */
N
N/*******************  Bit definition for ADC_SQR2 register  *******************/
N#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */
N#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */
N#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
N#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */
N#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
N#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */
N#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */
N#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
N#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */
N#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
N#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
N#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
N#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
N
N/*******************  Bit definition for ADC_SQR3 register  *******************/
N#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */
N#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */
N#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
N#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */
N#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
N#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */
N#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
N#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */
N#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
N#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */
N#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
N#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
N#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
N#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
N#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
N
N/*******************  Bit definition for ADC_JSQR register  *******************/
N#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */  
N#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
N#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
N#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */
N#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
N#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */
N#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
N#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
N#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
N#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
N#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
N#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
N#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */
N#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
N
N/*******************  Bit definition for ADC_JDR1 register  *******************/
N#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR2 register  *******************/
N#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR3 register  *******************/
N#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
N
N/*******************  Bit definition for ADC_JDR4 register  *******************/
N#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
N
N/********************  Bit definition for ADC_DR register  ********************/
N#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Analog Comparators (COMP)                             */
N/*                                                                            */
N/******************************************************************************/
N
N/***********************  Bit definition for COMP_CSR register  ***************/
N/* COMP1 bits definition */
N#define COMP_CSR_COMP1EN               ((uint32_t)0x00000001) /*!< COMP1 enable */
N#define COMP_CSR_COMP1SW1              ((uint32_t)0x00000002) /*!< SW1 switch control */
N#define COMP_CSR_COMP1MODE             ((uint32_t)0x0000000C) /*!< COMP1 power mode */
N#define COMP_CSR_COMP1MODE_0           ((uint32_t)0x00000004) /*!< COMP1 power mode bit 0 */
N#define COMP_CSR_COMP1MODE_1           ((uint32_t)0x00000008) /*!< COMP1 power mode bit 1 */
N#define COMP_CSR_COMP1INSEL            ((uint32_t)0x00000070) /*!< COMP1 inverting input select */
N#define COMP_CSR_COMP1INSEL_0          ((uint32_t)0x00000010) /*!< COMP1 inverting input select bit 0 */
N#define COMP_CSR_COMP1INSEL_1          ((uint32_t)0x00000020) /*!< COMP1 inverting input select bit 1 */
N#define COMP_CSR_COMP1INSEL_2          ((uint32_t)0x00000040) /*!< COMP1 inverting input select bit 2 */
N#define COMP_CSR_COMP1OUTSEL           ((uint32_t)0x00000700) /*!< COMP1 output select */
N#define COMP_CSR_COMP1OUTSEL_0         ((uint32_t)0x00000100) /*!< COMP1 output select bit 0 */
N#define COMP_CSR_COMP1OUTSEL_1         ((uint32_t)0x00000200) /*!< COMP1 output select bit 1 */
N#define COMP_CSR_COMP1OUTSEL_2         ((uint32_t)0x00000400) /*!< COMP1 output select bit 2 */
N#define COMP_CSR_COMP1POL              ((uint32_t)0x00000800) /*!< COMP1 output polarity */
N#define COMP_CSR_COMP1HYST             ((uint32_t)0x00003000) /*!< COMP1 hysteresis */
N#define COMP_CSR_COMP1HYST_0           ((uint32_t)0x00001000) /*!< COMP1 hysteresis bit 0 */
N#define COMP_CSR_COMP1HYST_1           ((uint32_t)0x00002000) /*!< COMP1 hysteresis bit 1 */
N#define COMP_CSR_COMP1OUT              ((uint32_t)0x00004000) /*!< COMP1 output level */
N#define COMP_CSR_COMP1LOCK             ((uint32_t)0x00008000) /*!< COMP1 lock */
N/* COMP2 bits definition */
N#define COMP_CSR_COMP2EN               ((uint32_t)0x00010000) /*!< COMP2 enable */
N#define COMP_CSR_COMP2MODE             ((uint32_t)0x000C0000) /*!< COMP2 power mode */
N#define COMP_CSR_COMP2MODE_0           ((uint32_t)0x00040000) /*!< COMP2 power mode bit 0 */
N#define COMP_CSR_COMP2MODE_1           ((uint32_t)0x00080000) /*!< COMP2 power mode bit 1 */
N#define COMP_CSR_COMP2INSEL            ((uint32_t)0x00700000) /*!< COMP2 inverting input select */
N#define COMP_CSR_COMP2INSEL_0          ((uint32_t)0x00100000) /*!< COMP2 inverting input select bit 0 */
N#define COMP_CSR_COMP2INSEL_1          ((uint32_t)0x00200000) /*!< COMP2 inverting input select bit 1 */
N#define COMP_CSR_COMP2INSEL_2          ((uint32_t)0x00400000) /*!< COMP2 inverting input select bit 2 */
N#define COMP_CSR_WNDWEN                ((uint32_t)0x00800000) /*!< Comparators window mode enable */
N#define COMP_CSR_COMP2OUTSEL           ((uint32_t)0x07000000) /*!< COMP2 output select */
N#define COMP_CSR_COMP2OUTSEL_0         ((uint32_t)0x01000000) /*!< COMP2 output select bit 0 */
N#define COMP_CSR_COMP2OUTSEL_1         ((uint32_t)0x02000000) /*!< COMP2 output select bit 1 */
N#define COMP_CSR_COMP2OUTSEL_2         ((uint32_t)0x04000000) /*!< COMP2 output select bit 2 */
N#define COMP_CSR_COMP2POL              ((uint32_t)0x08000000) /*!< COMP2 output polarity */
N#define COMP_CSR_COMP2HYST             ((uint32_t)0x30000000) /*!< COMP2 hysteresis */
N#define COMP_CSR_COMP2HYST_0           ((uint32_t)0x10000000) /*!< COMP2 hysteresis bit 0 */
N#define COMP_CSR_COMP2HYST_1           ((uint32_t)0x20000000) /*!< COMP2 hysteresis bit 1 */
N#define COMP_CSR_COMP2OUT              ((uint32_t)0x40000000) /*!< COMP2 output level */
N#define COMP_CSR_COMP2LOCK             ((uint32_t)0x80000000) /*!< COMP2 lock */
N
N/******************************************************************************/
N/*                                                                            */
N/*                   Controller Area Network (CAN )                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CAN_MCR register  ********************/
N#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!<Initialization Request */
N#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!<Sleep Mode Request */
N#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!<Transmit FIFO Priority */
N#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!<Receive FIFO Locked Mode */
N#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!<No Automatic Retransmission */
N#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!<Automatic Wakeup Mode */
N#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!<Automatic Bus-Off Management */
N#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!<Time Triggered Communication Mode */
N#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!<bxCAN software master reset */
N
N/*******************  Bit definition for CAN_MSR register  ********************/
N#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!<Initialization Acknowledge */
N#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!<Sleep Acknowledge */
N#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!<Error Interrupt */
N#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!<Wakeup Interrupt */
N#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!<Sleep Acknowledge Interrupt */
N#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!<Transmit Mode */
N#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!<Receive Mode */
N#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!<Last Sample Point */
N#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!<CAN Rx Signal */
N
N/*******************  Bit definition for CAN_TSR register  ********************/
N#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!<Request Completed Mailbox0 */
N#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!<Transmission OK of Mailbox0 */
N#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!<Arbitration Lost for Mailbox0 */
N#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!<Transmission Error of Mailbox0 */
N#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!<Abort Request for Mailbox0 */
N#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!<Request Completed Mailbox1 */
N#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!<Transmission OK of Mailbox1 */
N#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!<Arbitration Lost for Mailbox1 */
N#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!<Transmission Error of Mailbox1 */
N#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!<Abort Request for Mailbox 1 */
N#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!<Request Completed Mailbox2 */
N#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!<Transmission OK of Mailbox 2 */
N#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!<Arbitration Lost for mailbox 2 */
N#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!<Transmission Error of Mailbox 2 */
N#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!<Abort Request for Mailbox 2 */
N#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!<Mailbox Code */
N
N#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!<TME[2:0] bits */
N#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!<Transmit Mailbox 0 Empty */
N#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!<Transmit Mailbox 1 Empty */
N#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!<Transmit Mailbox 2 Empty */
N
N#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!<LOW[2:0] bits */
N#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!<Lowest Priority Flag for Mailbox 0 */
N#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!<Lowest Priority Flag for Mailbox 1 */
N#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!<Lowest Priority Flag for Mailbox 2 */
N
N/*******************  Bit definition for CAN_RF0R register  *******************/
N#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!<FIFO 0 Message Pending */
N#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!<FIFO 0 Full */
N#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!<FIFO 0 Overrun */
N#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!<Release FIFO 0 Output Mailbox */
N
N/*******************  Bit definition for CAN_RF1R register  *******************/
N#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!<FIFO 1 Message Pending */
N#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!<FIFO 1 Full */
N#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!<FIFO 1 Overrun */
N#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!<Release FIFO 1 Output Mailbox */
N
N/********************  Bit definition for CAN_IER register  *******************/
N#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Empty Interrupt Enable */
N#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!<FIFO Message Pending Interrupt Enable */
N#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!<FIFO Full Interrupt Enable */
N#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!<FIFO Overrun Interrupt Enable */
N#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!<FIFO Message Pending Interrupt Enable */
N#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!<FIFO Full Interrupt Enable */
N#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!<FIFO Overrun Interrupt Enable */
N#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!<Error Warning Interrupt Enable */
N#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!<Error Passive Interrupt Enable */
N#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!<Bus-Off Interrupt Enable */
N#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!<Last Error Code Interrupt Enable */
N#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!<Error Interrupt Enable */
N#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!<Wakeup Interrupt Enable */
N#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!<Sleep Interrupt Enable */
N
N/********************  Bit definition for CAN_ESR register  *******************/
N#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!<Error Warning Flag */
N#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!<Error Passive Flag */
N#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!<Bus-Off Flag */
N
N#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!<LEC[2:0] bits (Last Error Code) */
N#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!<Bit 0 */
N#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!<Bit 1 */
N#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!<Bit 2 */
N
N#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!<Least significant byte of the 9-bit Transmit Error Counter */
N#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!<Receive Error Counter */
N
N/*******************  Bit definition for CAN_BTR register  ********************/
N#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!<Baud Rate Prescaler */
N#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!<Time Segment 1 */
N#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!<Time Segment 2 */
N#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!<Resynchronization Jump Width */
N#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!<Loop Back Mode (Debug) */
N#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!<Silent Mode */
N
N/*!<Mailbox registers */
N/******************  Bit definition for CAN_TI0R register  ********************/
N#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
N#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
N#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/******************  Bit definition for CAN_TDT0R register  *******************/
N#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
N#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/******************  Bit definition for CAN_TDL0R register  *******************/
N#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/******************  Bit definition for CAN_TDH0R register  *******************/
N#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI1R register  *******************/
N#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
N#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
N#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT1R register  ******************/
N#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
N#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL1R register  ******************/
N#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH1R register  ******************/
N#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_TI2R register  *******************/
N#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
N#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
N#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_TDT2R register  ******************/  
N#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
N#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_TDL2R register  ******************/
N#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_TDH2R register  ******************/
N#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI0R register  *******************/
N#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
N#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT0R register  ******************/
N#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
N#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL0R register  ******************/
N#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH0R register  ******************/
N#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*******************  Bit definition for CAN_RI1R register  *******************/
N#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
N#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
N#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
N#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
N
N/*******************  Bit definition for CAN_RDT1R register  ******************/
N#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
N#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
N#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
N
N/*******************  Bit definition for CAN_RDL1R register  ******************/
N#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
N#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
N#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
N#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
N
N/*******************  Bit definition for CAN_RDH1R register  ******************/
N#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
N#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
N#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
N#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
N
N/*!<CAN filter registers */
N/*******************  Bit definition for CAN_FMR register  ********************/
N#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!<Filter Init Mode */
N
N/*******************  Bit definition for CAN_FM1R register  *******************/
N#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!<Filter Mode */
N#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!<Filter Init Mode bit 0 */
N#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!<Filter Init Mode bit 1 */
N#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!<Filter Init Mode bit 2 */
N#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!<Filter Init Mode bit 3 */
N#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!<Filter Init Mode bit 4 */
N#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!<Filter Init Mode bit 5 */
N#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!<Filter Init Mode bit 6 */
N#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!<Filter Init Mode bit 7 */
N#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!<Filter Init Mode bit 8 */
N#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!<Filter Init Mode bit 9 */
N#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!<Filter Init Mode bit 10 */
N#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!<Filter Init Mode bit 11 */
N#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!<Filter Init Mode bit 12 */
N#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!<Filter Init Mode bit 13 */
N
N/*******************  Bit definition for CAN_FS1R register  *******************/
N#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!<Filter Scale Configuration */
N#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!<Filter Scale Configuration bit 0 */
N#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!<Filter Scale Configuration bit 1 */
N#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!<Filter Scale Configuration bit 2 */
N#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!<Filter Scale Configuration bit 3 */
N#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!<Filter Scale Configuration bit 4 */
N#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!<Filter Scale Configuration bit 5 */
N#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!<Filter Scale Configuration bit 6 */
N#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!<Filter Scale Configuration bit 7 */
N#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!<Filter Scale Configuration bit 8 */
N#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!<Filter Scale Configuration bit 9 */
N#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!<Filter Scale Configuration bit 10 */
N#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!<Filter Scale Configuration bit 11 */
N#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!<Filter Scale Configuration bit 12 */
N#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!<Filter Scale Configuration bit 13 */
N
N/******************  Bit definition for CAN_FFA1R register  *******************/
N#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!<Filter FIFO Assignment */
N#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!<Filter FIFO Assignment for Filter 0 */
N#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!<Filter FIFO Assignment for Filter 1 */
N#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!<Filter FIFO Assignment for Filter 2 */
N#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!<Filter FIFO Assignment for Filter 3 */
N#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!<Filter FIFO Assignment for Filter 4 */
N#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!<Filter FIFO Assignment for Filter 5 */
N#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!<Filter FIFO Assignment for Filter 6 */
N#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!<Filter FIFO Assignment for Filter 7 */
N#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!<Filter FIFO Assignment for Filter 8 */
N#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!<Filter FIFO Assignment for Filter 9 */
N#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!<Filter FIFO Assignment for Filter 10 */
N#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!<Filter FIFO Assignment for Filter 11 */
N#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!<Filter FIFO Assignment for Filter 12 */
N#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!<Filter FIFO Assignment for Filter 13 */
N
N/*******************  Bit definition for CAN_FA1R register  *******************/
N#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!<Filter Active */
N#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!<Filter 0 Active */
N#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!<Filter 1 Active */
N#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!<Filter 2 Active */
N#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!<Filter 3 Active */
N#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!<Filter 4 Active */
N#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!<Filter 5 Active */
N#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!<Filter 6 Active */
N#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!<Filter 7 Active */
N#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!<Filter 8 Active */
N#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!<Filter 9 Active */
N#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!<Filter 10 Active */
N#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!<Filter 11 Active */
N#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!<Filter 12 Active */
N#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!<Filter 13 Active */
N
N/*******************  Bit definition for CAN_F0R1 register  *******************/
N#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R1 register  *******************/
N#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R1 register  *******************/
N#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R1 register  *******************/
N#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R1 register  *******************/
N#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R1 register  *******************/
N#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R1 register  *******************/
N#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R1 register  *******************/
N#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R1 register  *******************/
N#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R1 register  *******************/
N#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R1 register  ******************/
N#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R1 register  ******************/
N#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R1 register  ******************/
N#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R1 register  ******************/
N#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F0R2 register  *******************/
N#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F1R2 register  *******************/
N#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F2R2 register  *******************/
N#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F3R2 register  *******************/
N#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F4R2 register  *******************/
N#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F5R2 register  *******************/
N#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F6R2 register  *******************/
N#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F7R2 register  *******************/
N#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F8R2 register  *******************/
N#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F9R2 register  *******************/
N#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F10R2 register  ******************/
N#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F11R2 register  ******************/
N#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F12R2 register  ******************/
N#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/*******************  Bit definition for CAN_F13R2 register  ******************/
N#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
N#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
N#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
N#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
N#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
N#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
N#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
N#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
N#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
N#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
N#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
N#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
N#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
N#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
N#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
N#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
N#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
N#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
N#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
N#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
N#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
N#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
N#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
N#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
N#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
N#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
N#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
N#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
N#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
N#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
N#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
N#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                     CRC calculation unit (CRC)                             */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for CRC_DR register  *********************/
N#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
N
N/*******************  Bit definition for CRC_IDR register  ********************/
N#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
N
N/********************  Bit definition for CRC_CR register  ********************/
N#define  CRC_CR_RESET                        ((uint32_t)0x00000001) /*!< RESET the CRC computation unit bit */
N#define  CRC_CR_POLSIZE                      ((uint32_t)0x00000018) /*!< Polynomial size bits */
N#define  CRC_CR_POLSIZE_0                    ((uint32_t)0x00000008) /*!< Polynomial size bit 0 */
N#define  CRC_CR_POLSIZE_1                    ((uint32_t)0x00000010) /*!< Polynomial size bit 1 */
N#define  CRC_CR_REV_IN                       ((uint32_t)0x00000060) /*!< REV_IN Reverse Input Data bits */
N#define  CRC_CR_REV_IN_0                     ((uint32_t)0x00000020) /*!< Bit 0 */
N#define  CRC_CR_REV_IN_1                     ((uint32_t)0x00000040) /*!< Bit 1 */
N#define  CRC_CR_REV_OUT                      ((uint32_t)0x00000080) /*!< REV_OUT Reverse Output Data bits */
N
N/*******************  Bit definition for CRC_INIT register  *******************/
N#define  CRC_INIT_INIT                       ((uint32_t)0xFFFFFFFF) /*!< Initial CRC value bits */
N
N/*******************  Bit definition for CRC_POL register  ********************/
N#define  CRC_POL_POL                         ((uint32_t)0xFFFFFFFF) /*!< Coefficients of the polynomial */
N
N/******************************************************************************/
N/*                                                                            */
N/*                 Digital to Analog Converter (DAC)                          */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DAC_CR register  ********************/
N#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!< DAC channel1 enable */
N#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!< DAC channel1 output buffer disable */
N#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!< DAC channel1 Trigger enable */
N
N#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!< TSEL1[2:0] (DAC channel1 Trigger selection) */
N#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!< Bit 1 */
N#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!< Bit 2 */
N
N#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!< Bit 0 */
N#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!< Bit 1 */
N
N#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!< MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!< Bit 2 */
N#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!< Bit 3 */
N
N#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!< DAC channel1 DMA enable */
N#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!< DAC channel2 enable */
N#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!< DAC channel2 output buffer disable */
N#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!< DAC channel2 Trigger enable */
N
N#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!< TSEL2[2:0] (DAC channel2 Trigger selection) */
N#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!< Bit 0 */
N#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!< Bit 1 */
N#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!< Bit 2 */
N
N#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
N#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!< Bit 0 */
N#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!< Bit 1 */
N
N#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!< MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
N#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
N#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */
N
N#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!< DAC channel2 DMA enabled */
N
N/*****************  Bit definition for DAC_SWTRIGR register  ******************/
N#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!< DAC channel1 software trigger */
N#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!< DAC channel2 software trigger */
N
N/*****************  Bit definition for DAC_DHR12R1 register  ******************/
N#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!< DAC channel1 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L1 register  ******************/
N#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!< DAC channel1 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R1 register  ******************/
N#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!< DAC channel1 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12R2 register  ******************/
N#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!< DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12L2 register  ******************/
N#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!< DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8R2 register  ******************/
N#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!< DAC channel2 8-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12RD register  ******************/
N#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!< DAC channel1 12-bit Right aligned data */
N#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!< DAC channel2 12-bit Right aligned data */
N
N/*****************  Bit definition for DAC_DHR12LD register  ******************/
N#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!< DAC channel1 12-bit Left aligned data */
N#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!< DAC channel2 12-bit Left aligned data */
N
N/******************  Bit definition for DAC_DHR8RD register  ******************/
N#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!< DAC channel1 8-bit Right aligned data */
N#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!< DAC channel2 8-bit Right aligned data */
N
N/*******************  Bit definition for DAC_DOR1 register  *******************/
N#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel1 data output */
N
N/*******************  Bit definition for DAC_DOR2 register  *******************/
N#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel2 data output */
N
N/********************  Bit definition for DAC_SR register  ********************/
N#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!< DAC channel1 DMA underrun flag */
N#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!< DAC channel2 DMA underrun flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                 Debug MCU (DBGMCU)                         */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for DBGMCU_IDCODE register  *************/
N#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)
N#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)
N
N/********************  Bit definition for DBGMCU_CR register  *****************/
N#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)
N#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)
N#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)
N
N/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
N#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP        ((uint32_t)0x00000001)
N#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP        ((uint32_t)0x00000002)
N#define  DBGMCU_APB1_FZ_DBG_TIM4_STOP        ((uint32_t)0x00000004)
N#define  DBGMCU_APB1_FZ_DBG_TIM5_STOP        ((uint32_t)0x00000008)
N#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP        ((uint32_t)0x00000010)
N#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP        ((uint32_t)0x00000020)
N#define  DBGMCU_APB1_FZ_DBG_TIM12_STOP       ((uint32_t)0x00000040)
N#define  DBGMCU_APB1_FZ_DBG_TIM13_STOP       ((uint32_t)0x00000080)
N#define  DBGMCU_APB1_FZ_DBG_TIM14_STOP       ((uint32_t)0x00000100)
N#define  DBGMCU_APB1_FZ_DBG_TIM18_STOP       ((uint32_t)0x00000200)
N#define  DBGMCU_APB1_FZ_DBG_RTC_STOP         ((uint32_t)0x00000400)
N#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP        ((uint32_t)0x00000800)
N#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP        ((uint32_t)0x00001000)
N#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT   ((uint32_t)0x00200000)
N#define  DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT   ((uint32_t)0x00400000)
N#define  DBGMCU_APB1_FZ_DBG_CAN1_STOP            ((uint32_t)0x02000000)
N
N/********************  Bit definition for DBGMCU_APB2_FZ register  ************/
N#define  DBGMCU_APB2_FZ_DBG_TIM15_STOP       ((uint32_t)0x00000004)
N#define  DBGMCU_APB2_FZ_DBG_TIM16_STOP       ((uint32_t)0x00000008)
N#define  DBGMCU_APB2_FZ_DBG_TIM17_STOP       ((uint32_t)0x00000010)
N#define  DBGMCU_APB2_FZ_DBG_TIM19_STOP       ((uint32_t)0x00000020)
N
N/******************************************************************************/
N/*                                                                            */
N/*                             DMA Controller (DMA)                           */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for DMA_ISR register  ********************/
N#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
N#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
N#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
N#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
N#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */
N#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */
N#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */
N#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */
N#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */
N#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */
N#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */
N#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */
N#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */
N#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */
N#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */
N#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */
N#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */
N#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */
N#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */
N#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */
N#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */
N#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */
N#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */
N#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */
N#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */
N#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */
N#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */
N#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */
N
N/*******************  Bit definition for DMA_IFCR register  *******************/
N#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear */
N#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
N#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
N#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */
N#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */
N#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */
N#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */
N#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */
N#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */
N#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */
N#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */
N#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */
N#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */
N#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */
N#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */
N#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */
N#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */
N#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */
N#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */
N#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */
N#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */
N#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */
N
N/*******************  Bit definition for DMA_CCR register  ********************/
N#define  DMA_CCR_EN                          ((uint32_t)0x00000001)        /*!< Channel enable                      */
N#define  DMA_CCR_TCIE                        ((uint32_t)0x00000002)        /*!< Transfer complete interrupt enable  */
N#define  DMA_CCR_HTIE                        ((uint32_t)0x00000004)        /*!< Half Transfer interrupt enable      */
N#define  DMA_CCR_TEIE                        ((uint32_t)0x00000008)        /*!< Transfer error interrupt enable     */
N#define  DMA_CCR_DIR                         ((uint32_t)0x00000010)        /*!< Data transfer direction             */
N#define  DMA_CCR_CIRC                        ((uint32_t)0x00000020)        /*!< Circular mode                       */
N#define  DMA_CCR_PINC                        ((uint32_t)0x00000040)        /*!< Peripheral increment mode           */
N#define  DMA_CCR_MINC                        ((uint32_t)0x00000080)        /*!< Memory increment mode               */
N
N#define  DMA_CCR_PSIZE                       ((uint32_t)0x00000300)        /*!< PSIZE[1:0] bits (Peripheral size)   */
N#define  DMA_CCR_PSIZE_0                     ((uint32_t)0x00000100)        /*!< Bit 0                               */
N#define  DMA_CCR_PSIZE_1                     ((uint32_t)0x00000200)        /*!< Bit 1                               */
N
N#define  DMA_CCR_MSIZE                       ((uint32_t)0x00000C00)        /*!< MSIZE[1:0] bits (Memory size)       */
N#define  DMA_CCR_MSIZE_0                     ((uint32_t)0x00000400)        /*!< Bit 0                               */
N#define  DMA_CCR_MSIZE_1                     ((uint32_t)0x00000800)        /*!< Bit 1                               */
N
N#define  DMA_CCR_PL                          ((uint32_t)0x00003000)        /*!< PL[1:0] bits(Channel Priority level)*/
N#define  DMA_CCR_PL_0                        ((uint32_t)0x00001000)        /*!< Bit 0                               */
N#define  DMA_CCR_PL_1                        ((uint32_t)0x00002000)        /*!< Bit 1                               */
N
N#define  DMA_CCR_MEM2MEM                     ((uint32_t)0x00004000)        /*!< Memory to memory mode               */
N
N/******************  Bit definition for DMA_CNDTR register  *******************/
N#define  DMA_CNDTR_NDT                       ((uint32_t)0x0000FFFF)        /*!< Number of data to Transfer          */
N
N/******************  Bit definition for DMA_CPAR register  ********************/
N#define  DMA_CPAR_PA                         ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
N
N/******************  Bit definition for DMA_CMAR register  ********************/
N#define  DMA_CMAR_MA                         ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
N
N/******************************************************************************/
N/*                                                                            */
N/*                    External Interrupt/Event Controller (EXTI)              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for EXTI_IMR register  *******************/
N#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
N#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
N#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
N#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
N#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
N#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
N#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
N#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
N#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
N#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
N#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
N#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
N#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
N#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
N#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
N#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
N#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
N#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
N#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
N#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
N#define  EXTI_IMR_MR20                       ((uint32_t)0x00100000)        /*!< Interrupt Mask on line 20 */
N#define  EXTI_IMR_MR21                       ((uint32_t)0x00200000)        /*!< Interrupt Mask on line 21 */
N#define  EXTI_IMR_MR22                       ((uint32_t)0x00400000)        /*!< Interrupt Mask on line 22 */
N#define  EXTI_IMR_MR23                       ((uint32_t)0x00800000)        /*!< Interrupt Mask on line 23 */
N#define  EXTI_IMR_MR24                       ((uint32_t)0x01000000)        /*!< Interrupt Mask on line 24 */
N#define  EXTI_IMR_MR25                       ((uint32_t)0x02000000)        /*!< Interrupt Mask on line 25 */
N#define  EXTI_IMR_MR26                       ((uint32_t)0x04000000)        /*!< Interrupt Mask on line 26 */
N#define  EXTI_IMR_MR27                       ((uint32_t)0x08000000)        /*!< Interrupt Mask on line 27 */
N#define  EXTI_IMR_MR28                       ((uint32_t)0x10000000)        /*!< Interrupt Mask on line 28 */
N
N/*******************  Bit definition for EXTI_EMR register  *******************/
N#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
N#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
N#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
N#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
N#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
N#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
N#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
N#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
N#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
N#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
N#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
N#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
N#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
N#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
N#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
N#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
N#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
N#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
N#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
N#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
N#define  EXTI_EMR_MR20                       ((uint32_t)0x00100000)        /*!< Event Mask on line 20 */
N#define  EXTI_EMR_MR21                       ((uint32_t)0x00200000)        /*!< Event Mask on line 21 */
N#define  EXTI_EMR_MR22                       ((uint32_t)0x00400000)        /*!< Event Mask on line 22 */
N#define  EXTI_EMR_MR23                       ((uint32_t)0x00800000)        /*!< Event Mask on line 23 */
N#define  EXTI_EMR_MR24                       ((uint32_t)0x01000000)        /*!< Event Mask on line 24 */
N#define  EXTI_EMR_MR25                       ((uint32_t)0x02000000)        /*!< Event Mask on line 25 */
N#define  EXTI_EMR_MR26                       ((uint32_t)0x04000000)        /*!< Event Mask on line 26 */
N#define  EXTI_EMR_MR27                       ((uint32_t)0x08000000)        /*!< Event Mask on line 27 */
N#define  EXTI_EMR_MR28                       ((uint32_t)0x10000000)        /*!< Event Mask on line 28 */
N
N/******************  Bit definition for EXTI_RTSR register  *******************/
N#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
N#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
N#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
N#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
N#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
N#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
N#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
N#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
N#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
N#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
N#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
N#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
N#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
N#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
N#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
N#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
N#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
N#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
N#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
N#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
N#define  EXTI_RTSR_TR20                      ((uint32_t)0x00100000)        /*!< Rising trigger event configuration bit of line 20 */
N#define  EXTI_RTSR_TR21                      ((uint32_t)0x00200000)        /*!< Rising trigger event configuration bit of line 21 */
N#define  EXTI_RTSR_TR22                      ((uint32_t)0x00400000)        /*!< Rising trigger event configuration bit of line 22 */
N#define  EXTI_RTSR_TR23                      ((uint32_t)0x00800000)        /*!< Rising trigger event configuration bit of line 23 */
N#define  EXTI_RTSR_TR24                      ((uint32_t)0x01000000)        /*!< Rising trigger event configuration bit of line 24 */
N#define  EXTI_RTSR_TR25                      ((uint32_t)0x02000000)        /*!< Rising trigger event configuration bit of line 25 */
N#define  EXTI_RTSR_TR26                      ((uint32_t)0x04000000)        /*!< Rising trigger event configuration bit of line 26 */
N#define  EXTI_RTSR_TR27                      ((uint32_t)0x08000000)        /*!< Rising trigger event configuration bit of line 27 */
N#define  EXTI_RTSR_TR28                      ((uint32_t)0x10000000)        /*!< Rising trigger event configuration bit of line 28 */
N
N/******************  Bit definition for EXTI_FTSR register  *******************/
N#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
N#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
N#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
N#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
N#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
N#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
N#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
N#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
N#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
N#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
N#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
N#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
N#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
N#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
N#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
N#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
N#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
N#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
N#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
N#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
N#define  EXTI_FTSR_TR20                      ((uint32_t)0x00100000)        /*!< Falling trigger event configuration bit of line 20 */
N#define  EXTI_FTSR_TR21                      ((uint32_t)0x00200000)        /*!< Falling trigger event configuration bit of line 21 */
N#define  EXTI_FTSR_TR22                      ((uint32_t)0x00400000)        /*!< Falling trigger event configuration bit of line 22 */
N#define  EXTI_FTSR_TR23                      ((uint32_t)0x00800000)        /*!< Falling trigger event configuration bit of line 23 */
N#define  EXTI_FTSR_TR24                      ((uint32_t)0x01000000)        /*!< Falling trigger event configuration bit of line 24 */
N#define  EXTI_FTSR_TR25                      ((uint32_t)0x02000000)        /*!< Falling trigger event configuration bit of line 25 */
N#define  EXTI_FTSR_TR26                      ((uint32_t)0x04000000)        /*!< Falling trigger event configuration bit of line 26 */
N#define  EXTI_FTSR_TR27                      ((uint32_t)0x08000000)        /*!< Falling trigger event configuration bit of line 27 */
N#define  EXTI_FTSR_TR28                      ((uint32_t)0x10000000)        /*!< Falling trigger event configuration bit of line 28 */
N
N/******************  Bit definition for EXTI_SWIER register  ******************/
N#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
N#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
N#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
N#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
N#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
N#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
N#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
N#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
N#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
N#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
N#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
N#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
N#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
N#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
N#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
N#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
N#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
N#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
N#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
N#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
N#define  EXTI_SWIER_SWIER20                  ((uint32_t)0x00100000)        /*!< Software Interrupt on line 20 */
N#define  EXTI_SWIER_SWIER21                  ((uint32_t)0x00200000)        /*!< Software Interrupt on line 21 */
N#define  EXTI_SWIER_SWIER22                  ((uint32_t)0x00400000)        /*!< Software Interrupt on line 22 */
N#define  EXTI_SWIER_SWIER23                  ((uint32_t)0x00800000)        /*!< Software Interrupt on line 23 */
N#define  EXTI_SWIER_SWIER24                  ((uint32_t)0x01000000)        /*!< Software Interrupt on line 24 */
N#define  EXTI_SWIER_SWIER25                  ((uint32_t)0x02000000)        /*!< Software Interrupt on line 25 */
N#define  EXTI_SWIER_SWIER26                  ((uint32_t)0x04000000)        /*!< Software Interrupt on line 26 */
N#define  EXTI_SWIER_SWIER27                  ((uint32_t)0x08000000)        /*!< Software Interrupt on line 27 */
N#define  EXTI_SWIER_SWIER28                  ((uint32_t)0x10000000)        /*!< Software Interrupt on line 28 */
N
N/*******************  Bit definition for EXTI_PR register  ********************/
N#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
N#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
N#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
N#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
N#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
N#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
N#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
N#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
N#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
N#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
N#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
N#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
N#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
N#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
N#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
N#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
N#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
N#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
N#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
N#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
N#define  EXTI_PR_PR20                        ((uint32_t)0x00100000)        /*!< Pending bit for line 20 */
N#define  EXTI_PR_PR21                        ((uint32_t)0x00200000)        /*!< Pending bit for line 21 */
N#define  EXTI_PR_PR22                        ((uint32_t)0x00400000)        /*!< Pending bit for line 22 */
N#define  EXTI_PR_PR23                        ((uint32_t)0x00800000)        /*!< Pending bit for line 23 */
N#define  EXTI_PR_PR24                        ((uint32_t)0x01000000)        /*!< Pending bit for line 24 */
N#define  EXTI_PR_PR25                        ((uint32_t)0x02000000)        /*!< Pending bit for line 25 */
N#define  EXTI_PR_PR26                        ((uint32_t)0x04000000)        /*!< Pending bit for line 26 */
N#define  EXTI_PR_PR27                        ((uint32_t)0x08000000)        /*!< Pending bit for line 27 */
N#define  EXTI_PR_PR28                        ((uint32_t)0x10000000)        /*!< Pending bit for line 28 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    FLASH                                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for FLASH_ACR register  ******************/
N#define  FLASH_ACR_LATENCY                   ((uint8_t)0x03)               /*!< LATENCY[2:0] bits (Latency) */
N#define  FLASH_ACR_LATENCY_0                 ((uint8_t)0x01)               /*!< Bit 0 */
N#define  FLASH_ACR_LATENCY_1                 ((uint8_t)0x02)               /*!< Bit 1 */
N
N#define  FLASH_ACR_HLFCYA                    ((uint8_t)0x08)               /*!< Flash Half Cycle Access Enable */
N#define  FLASH_ACR_PRFTBE                    ((uint8_t)0x10)               /*!< Prefetch Buffer Enable */
N#define  FLASH_ACR_PRFTBS                    ((uint8_t)0x20)
N
N/******************  Bit definition for FLASH_KEYR register  ******************/
N#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */
N
N/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
N#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */
N
N/******************  Bit definition for FLASH_SR register  *******************/
N#define  FLASH_SR_BSY                        ((uint32_t)0x00000001)        /*!< Busy */
N#define  FLASH_SR_PGERR                      ((uint32_t)0x00000004)        /*!< Programming Error */
N#define  FLASH_SR_WRPERR                     ((uint32_t)0x00000010)        /*!< Write Protection Error */
N#define  FLASH_SR_EOP                        ((uint32_t)0x00000020)        /*!< End of operation */
N
N/*******************  Bit definition for FLASH_CR register  *******************/
N#define  FLASH_CR_PG                         ((uint32_t)0x00000001)        /*!< Programming */
N#define  FLASH_CR_PER                        ((uint32_t)0x00000002)        /*!< Page Erase */
N#define  FLASH_CR_MER                        ((uint32_t)0x00000004)        /*!< Mass Erase */
N#define  FLASH_CR_OPTPG                      ((uint32_t)0x00000010)        /*!< Option Byte Programming */
N#define  FLASH_CR_OPTER                      ((uint32_t)0x00000020)        /*!< Option Byte Erase */
N#define  FLASH_CR_STRT                       ((uint32_t)0x00000040)        /*!< Start */
N#define  FLASH_CR_LOCK                       ((uint32_t)0x00000080)        /*!< Lock */
N#define  FLASH_CR_OPTWRE                     ((uint32_t)0x00000200)        /*!< Option Bytes Write Enable */
N#define  FLASH_CR_ERRIE                      ((uint32_t)0x00000400)        /*!< Error Interrupt Enable */
N#define  FLASH_CR_EOPIE                      ((uint32_t)0x00001000)        /*!< End of operation interrupt enable */
N#define  FLASH_CR_OBL_LAUNCH                 ((uint32_t)0x00002000)        /*!< OptionBytes Loader Launch */
N
N/*******************  Bit definition for FLASH_AR register  *******************/
N#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */
N
N/******************  Bit definition for FLASH_OBR register  *******************/
N#define  FLASH_OBR_OPTERR                    ((uint32_t)0x00000001)        /*!< Option Byte Error */
N#define  FLASH_OBR_RDPRT1                    ((uint32_t)0x00000002)        /*!< Read protection Level 1 */
N#define  FLASH_OBR_RDPRT2                    ((uint32_t)0x00000004)        /*!< Read protection Level 2 */
N
N#define  FLASH_OBR_USER                      ((uint32_t)0x00003700)        /*!< User Option Bytes */
N#define  FLASH_OBR_IWDG_SW                   ((uint32_t)0x00000100)        /*!< IWDG SW */
N#define  FLASH_OBR_nRST_STOP                 ((uint32_t)0x00000200)        /*!< nRST_STOP */
N#define  FLASH_OBR_nRST_STDBY                ((uint32_t)0x00000400)        /*!< nRST_STDBY */
N
N/******************  Bit definition for FLASH_WRPR register  ******************/
N#define  FLASH_WRPR_WRP                        ((uint32_t)0xFFFFFFFF)      /*!< Write Protect */
N
N/*----------------------------------------------------------------------------*/
N
N/******************  Bit definition for OB_RDP register  **********************/
N#define  OB_RDP_RDP                          ((uint32_t)0x000000FF)        /*!< Read protection option byte */
N#define  OB_RDP_nRDP                         ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */
N
N/******************  Bit definition for OB_USER register  *********************/
N#define  OB_USER_USER                        ((uint32_t)0x00FF0000)        /*!< User option byte */
N#define  OB_USER_nUSER                       ((uint32_t)0xFF000000)        /*!< User complemented option byte */
N
N/******************  Bit definition for FLASH_WRP0 register  ******************/
N#define  OB_WRP0_WRP0                        ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
N#define  OB_WRP0_nWRP0                       ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for FLASH_WRP1 register  ******************/
N#define  OB_WRP1_WRP1                        ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
N#define  OB_WRP1_nWRP1                       ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for FLASH_WRP2 register  ******************/
N#define  OB_WRP2_WRP2                        ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
N#define  OB_WRP2_nWRP2                       ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
N
N/******************  Bit definition for FLASH_WRP3 register  ******************/
N#define  OB_WRP3_WRP3                        ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
N#define  OB_WRP3_nWRP3                       ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
N/******************************************************************************/
N/*                                                                            */
N/*                            General Purpose I/O (GPIO)                      */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for GPIO_MODER register  *****************/
N#define GPIO_MODER_MODER0          ((uint32_t)0x00000003)
N#define GPIO_MODER_MODER0_0        ((uint32_t)0x00000001)
N#define GPIO_MODER_MODER0_1        ((uint32_t)0x00000002)
N#define GPIO_MODER_MODER1          ((uint32_t)0x0000000C)
N#define GPIO_MODER_MODER1_0        ((uint32_t)0x00000004)
N#define GPIO_MODER_MODER1_1        ((uint32_t)0x00000008)
N#define GPIO_MODER_MODER2          ((uint32_t)0x00000030)
N#define GPIO_MODER_MODER2_0        ((uint32_t)0x00000010)
N#define GPIO_MODER_MODER2_1        ((uint32_t)0x00000020)
N#define GPIO_MODER_MODER3          ((uint32_t)0x000000C0)
N#define GPIO_MODER_MODER3_0        ((uint32_t)0x00000040)
N#define GPIO_MODER_MODER3_1        ((uint32_t)0x00000080)
N#define GPIO_MODER_MODER4          ((uint32_t)0x00000300)
N#define GPIO_MODER_MODER4_0        ((uint32_t)0x00000100)
N#define GPIO_MODER_MODER4_1        ((uint32_t)0x00000200)
N#define GPIO_MODER_MODER5          ((uint32_t)0x00000C00)
N#define GPIO_MODER_MODER5_0        ((uint32_t)0x00000400)
N#define GPIO_MODER_MODER5_1        ((uint32_t)0x00000800)
N#define GPIO_MODER_MODER6          ((uint32_t)0x00003000)
N#define GPIO_MODER_MODER6_0        ((uint32_t)0x00001000)
N#define GPIO_MODER_MODER6_1        ((uint32_t)0x00002000)
N#define GPIO_MODER_MODER7          ((uint32_t)0x0000C000)
N#define GPIO_MODER_MODER7_0        ((uint32_t)0x00004000)
N#define GPIO_MODER_MODER7_1        ((uint32_t)0x00008000)
N#define GPIO_MODER_MODER8          ((uint32_t)0x00030000)
N#define GPIO_MODER_MODER8_0        ((uint32_t)0x00010000)
N#define GPIO_MODER_MODER8_1        ((uint32_t)0x00020000)
N#define GPIO_MODER_MODER9          ((uint32_t)0x000C0000)
N#define GPIO_MODER_MODER9_0        ((uint32_t)0x00040000)
N#define GPIO_MODER_MODER9_1        ((uint32_t)0x00080000)
N#define GPIO_MODER_MODER10         ((uint32_t)0x00300000)
N#define GPIO_MODER_MODER10_0       ((uint32_t)0x00100000)
N#define GPIO_MODER_MODER10_1       ((uint32_t)0x00200000)
N#define GPIO_MODER_MODER11         ((uint32_t)0x00C00000)
N#define GPIO_MODER_MODER11_0       ((uint32_t)0x00400000)
N#define GPIO_MODER_MODER11_1       ((uint32_t)0x00800000)
N#define GPIO_MODER_MODER12         ((uint32_t)0x03000000)
N#define GPIO_MODER_MODER12_0       ((uint32_t)0x01000000)
N#define GPIO_MODER_MODER12_1       ((uint32_t)0x02000000)
N#define GPIO_MODER_MODER13         ((uint32_t)0x0C000000)
N#define GPIO_MODER_MODER13_0       ((uint32_t)0x04000000)
N#define GPIO_MODER_MODER13_1       ((uint32_t)0x08000000)
N#define GPIO_MODER_MODER14         ((uint32_t)0x30000000)
N#define GPIO_MODER_MODER14_0       ((uint32_t)0x10000000)
N#define GPIO_MODER_MODER14_1       ((uint32_t)0x20000000)
N#define GPIO_MODER_MODER15         ((uint32_t)0xC0000000)
N#define GPIO_MODER_MODER15_0       ((uint32_t)0x40000000)
N#define GPIO_MODER_MODER15_1       ((uint32_t)0x80000000)
N
N/******************  Bit definition for GPIO_OTYPER register  *****************/
N#define GPIO_OTYPER_OT_0           ((uint32_t)0x00000001)
N#define GPIO_OTYPER_OT_1           ((uint32_t)0x00000002)
N#define GPIO_OTYPER_OT_2           ((uint32_t)0x00000004)
N#define GPIO_OTYPER_OT_3           ((uint32_t)0x00000008)
N#define GPIO_OTYPER_OT_4           ((uint32_t)0x00000010)
N#define GPIO_OTYPER_OT_5           ((uint32_t)0x00000020)
N#define GPIO_OTYPER_OT_6           ((uint32_t)0x00000040)
N#define GPIO_OTYPER_OT_7           ((uint32_t)0x00000080)
N#define GPIO_OTYPER_OT_8           ((uint32_t)0x00000100)
N#define GPIO_OTYPER_OT_9           ((uint32_t)0x00000200)
N#define GPIO_OTYPER_OT_10          ((uint32_t)0x00000400)
N#define GPIO_OTYPER_OT_11          ((uint32_t)0x00000800)
N#define GPIO_OTYPER_OT_12          ((uint32_t)0x00001000)
N#define GPIO_OTYPER_OT_13          ((uint32_t)0x00002000)
N#define GPIO_OTYPER_OT_14          ((uint32_t)0x00004000)
N#define GPIO_OTYPER_OT_15          ((uint32_t)0x00008000)
N
N/****************  Bit definition for GPIO_OSPEEDR register  ******************/
N#define GPIO_OSPEEDER_OSPEEDR0     ((uint32_t)0x00000003)
N#define GPIO_OSPEEDER_OSPEEDR0_0   ((uint32_t)0x00000001)
N#define GPIO_OSPEEDER_OSPEEDR0_1   ((uint32_t)0x00000002)
N#define GPIO_OSPEEDER_OSPEEDR1     ((uint32_t)0x0000000C)
N#define GPIO_OSPEEDER_OSPEEDR1_0   ((uint32_t)0x00000004)
N#define GPIO_OSPEEDER_OSPEEDR1_1   ((uint32_t)0x00000008)
N#define GPIO_OSPEEDER_OSPEEDR2     ((uint32_t)0x00000030)
N#define GPIO_OSPEEDER_OSPEEDR2_0   ((uint32_t)0x00000010)
N#define GPIO_OSPEEDER_OSPEEDR2_1   ((uint32_t)0x00000020)
N#define GPIO_OSPEEDER_OSPEEDR3     ((uint32_t)0x000000C0)
N#define GPIO_OSPEEDER_OSPEEDR3_0   ((uint32_t)0x00000040)
N#define GPIO_OSPEEDER_OSPEEDR3_1   ((uint32_t)0x00000080)
N#define GPIO_OSPEEDER_OSPEEDR4     ((uint32_t)0x00000300)
N#define GPIO_OSPEEDER_OSPEEDR4_0   ((uint32_t)0x00000100)
N#define GPIO_OSPEEDER_OSPEEDR4_1   ((uint32_t)0x00000200)
N#define GPIO_OSPEEDER_OSPEEDR5     ((uint32_t)0x00000C00)
N#define GPIO_OSPEEDER_OSPEEDR5_0   ((uint32_t)0x00000400)
N#define GPIO_OSPEEDER_OSPEEDR5_1   ((uint32_t)0x00000800)
N#define GPIO_OSPEEDER_OSPEEDR6     ((uint32_t)0x00003000)
N#define GPIO_OSPEEDER_OSPEEDR6_0   ((uint32_t)0x00001000)
N#define GPIO_OSPEEDER_OSPEEDR6_1   ((uint32_t)0x00002000)
N#define GPIO_OSPEEDER_OSPEEDR7     ((uint32_t)0x0000C000)
N#define GPIO_OSPEEDER_OSPEEDR7_0   ((uint32_t)0x00004000)
N#define GPIO_OSPEEDER_OSPEEDR7_1   ((uint32_t)0x00008000)
N#define GPIO_OSPEEDER_OSPEEDR8     ((uint32_t)0x00030000)
N#define GPIO_OSPEEDER_OSPEEDR8_0   ((uint32_t)0x00010000)
N#define GPIO_OSPEEDER_OSPEEDR8_1   ((uint32_t)0x00020000)
N#define GPIO_OSPEEDER_OSPEEDR9     ((uint32_t)0x000C0000)
N#define GPIO_OSPEEDER_OSPEEDR9_0   ((uint32_t)0x00040000)
N#define GPIO_OSPEEDER_OSPEEDR9_1   ((uint32_t)0x00080000)
N#define GPIO_OSPEEDER_OSPEEDR10    ((uint32_t)0x00300000)
N#define GPIO_OSPEEDER_OSPEEDR10_0  ((uint32_t)0x00100000)
N#define GPIO_OSPEEDER_OSPEEDR10_1  ((uint32_t)0x00200000)
N#define GPIO_OSPEEDER_OSPEEDR11    ((uint32_t)0x00C00000)
N#define GPIO_OSPEEDER_OSPEEDR11_0  ((uint32_t)0x00400000)
N#define GPIO_OSPEEDER_OSPEEDR11_1  ((uint32_t)0x00800000)
N#define GPIO_OSPEEDER_OSPEEDR12    ((uint32_t)0x03000000)
N#define GPIO_OSPEEDER_OSPEEDR12_0  ((uint32_t)0x01000000)
N#define GPIO_OSPEEDER_OSPEEDR12_1  ((uint32_t)0x02000000)
N#define GPIO_OSPEEDER_OSPEEDR13    ((uint32_t)0x0C000000)
N#define GPIO_OSPEEDER_OSPEEDR13_0  ((uint32_t)0x04000000)
N#define GPIO_OSPEEDER_OSPEEDR13_1  ((uint32_t)0x08000000)
N#define GPIO_OSPEEDER_OSPEEDR14    ((uint32_t)0x30000000)
N#define GPIO_OSPEEDER_OSPEEDR14_0  ((uint32_t)0x10000000)
N#define GPIO_OSPEEDER_OSPEEDR14_1  ((uint32_t)0x20000000)
N#define GPIO_OSPEEDER_OSPEEDR15    ((uint32_t)0xC0000000)
N#define GPIO_OSPEEDER_OSPEEDR15_0  ((uint32_t)0x40000000)
N#define GPIO_OSPEEDER_OSPEEDR15_1  ((uint32_t)0x80000000)
N
N/*******************  Bit definition for GPIO_PUPDR register ******************/
N#define GPIO_PUPDR_PUPDR0          ((uint32_t)0x00000003)
N#define GPIO_PUPDR_PUPDR0_0        ((uint32_t)0x00000001)
N#define GPIO_PUPDR_PUPDR0_1        ((uint32_t)0x00000002)
N#define GPIO_PUPDR_PUPDR1          ((uint32_t)0x0000000C)
N#define GPIO_PUPDR_PUPDR1_0        ((uint32_t)0x00000004)
N#define GPIO_PUPDR_PUPDR1_1        ((uint32_t)0x00000008)
N#define GPIO_PUPDR_PUPDR2          ((uint32_t)0x00000030)
N#define GPIO_PUPDR_PUPDR2_0        ((uint32_t)0x00000010)
N#define GPIO_PUPDR_PUPDR2_1        ((uint32_t)0x00000020)
N#define GPIO_PUPDR_PUPDR3          ((uint32_t)0x000000C0)
N#define GPIO_PUPDR_PUPDR3_0        ((uint32_t)0x00000040)
N#define GPIO_PUPDR_PUPDR3_1        ((uint32_t)0x00000080)
N#define GPIO_PUPDR_PUPDR4          ((uint32_t)0x00000300)
N#define GPIO_PUPDR_PUPDR4_0        ((uint32_t)0x00000100)
N#define GPIO_PUPDR_PUPDR4_1        ((uint32_t)0x00000200)
N#define GPIO_PUPDR_PUPDR5          ((uint32_t)0x00000C00)
N#define GPIO_PUPDR_PUPDR5_0        ((uint32_t)0x00000400)
N#define GPIO_PUPDR_PUPDR5_1        ((uint32_t)0x00000800)
N#define GPIO_PUPDR_PUPDR6          ((uint32_t)0x00003000)
N#define GPIO_PUPDR_PUPDR6_0        ((uint32_t)0x00001000)
N#define GPIO_PUPDR_PUPDR6_1        ((uint32_t)0x00002000)
N#define GPIO_PUPDR_PUPDR7          ((uint32_t)0x0000C000)
N#define GPIO_PUPDR_PUPDR7_0        ((uint32_t)0x00004000)
N#define GPIO_PUPDR_PUPDR7_1        ((uint32_t)0x00008000)
N#define GPIO_PUPDR_PUPDR8          ((uint32_t)0x00030000)
N#define GPIO_PUPDR_PUPDR8_0        ((uint32_t)0x00010000)
N#define GPIO_PUPDR_PUPDR8_1        ((uint32_t)0x00020000)
N#define GPIO_PUPDR_PUPDR9          ((uint32_t)0x000C0000)
N#define GPIO_PUPDR_PUPDR9_0        ((uint32_t)0x00040000)
N#define GPIO_PUPDR_PUPDR9_1        ((uint32_t)0x00080000)
N#define GPIO_PUPDR_PUPDR10         ((uint32_t)0x00300000)
N#define GPIO_PUPDR_PUPDR10_0       ((uint32_t)0x00100000)
N#define GPIO_PUPDR_PUPDR10_1       ((uint32_t)0x00200000)
N#define GPIO_PUPDR_PUPDR11         ((uint32_t)0x00C00000)
N#define GPIO_PUPDR_PUPDR11_0       ((uint32_t)0x00400000)
N#define GPIO_PUPDR_PUPDR11_1       ((uint32_t)0x00800000)
N#define GPIO_PUPDR_PUPDR12         ((uint32_t)0x03000000)
N#define GPIO_PUPDR_PUPDR12_0       ((uint32_t)0x01000000)
N#define GPIO_PUPDR_PUPDR12_1       ((uint32_t)0x02000000)
N#define GPIO_PUPDR_PUPDR13         ((uint32_t)0x0C000000)
N#define GPIO_PUPDR_PUPDR13_0       ((uint32_t)0x04000000)
N#define GPIO_PUPDR_PUPDR13_1       ((uint32_t)0x08000000)
N#define GPIO_PUPDR_PUPDR14         ((uint32_t)0x30000000)
N#define GPIO_PUPDR_PUPDR14_0       ((uint32_t)0x10000000)
N#define GPIO_PUPDR_PUPDR14_1       ((uint32_t)0x20000000)
N#define GPIO_PUPDR_PUPDR15         ((uint32_t)0xC0000000)
N#define GPIO_PUPDR_PUPDR15_0       ((uint32_t)0x40000000)
N#define GPIO_PUPDR_PUPDR15_1       ((uint32_t)0x80000000)
N
N/*******************  Bit definition for GPIO_IDR register  *******************/
N#define GPIO_IDR_0                 ((uint32_t)0x00000001)
N#define GPIO_IDR_1                 ((uint32_t)0x00000002)
N#define GPIO_IDR_2                 ((uint32_t)0x00000004)
N#define GPIO_IDR_3                 ((uint32_t)0x00000008)
N#define GPIO_IDR_4                 ((uint32_t)0x00000010)
N#define GPIO_IDR_5                 ((uint32_t)0x00000020)
N#define GPIO_IDR_6                 ((uint32_t)0x00000040)
N#define GPIO_IDR_7                 ((uint32_t)0x00000080)
N#define GPIO_IDR_8                 ((uint32_t)0x00000100)
N#define GPIO_IDR_9                 ((uint32_t)0x00000200)
N#define GPIO_IDR_10                ((uint32_t)0x00000400)
N#define GPIO_IDR_11                ((uint32_t)0x00000800)
N#define GPIO_IDR_12                ((uint32_t)0x00001000)
N#define GPIO_IDR_13                ((uint32_t)0x00002000)
N#define GPIO_IDR_14                ((uint32_t)0x00004000)
N#define GPIO_IDR_15                ((uint32_t)0x00008000)
N
N/******************  Bit definition for GPIO_ODR register  ********************/
N#define GPIO_ODR_0                 ((uint32_t)0x00000001)
N#define GPIO_ODR_1                 ((uint32_t)0x00000002)
N#define GPIO_ODR_2                 ((uint32_t)0x00000004)
N#define GPIO_ODR_3                 ((uint32_t)0x00000008)
N#define GPIO_ODR_4                 ((uint32_t)0x00000010)
N#define GPIO_ODR_5                 ((uint32_t)0x00000020)
N#define GPIO_ODR_6                 ((uint32_t)0x00000040)
N#define GPIO_ODR_7                 ((uint32_t)0x00000080)
N#define GPIO_ODR_8                 ((uint32_t)0x00000100)
N#define GPIO_ODR_9                 ((uint32_t)0x00000200)
N#define GPIO_ODR_10                ((uint32_t)0x00000400)
N#define GPIO_ODR_11                ((uint32_t)0x00000800)
N#define GPIO_ODR_12                ((uint32_t)0x00001000)
N#define GPIO_ODR_13                ((uint32_t)0x00002000)
N#define GPIO_ODR_14                ((uint32_t)0x00004000)
N#define GPIO_ODR_15                ((uint32_t)0x00008000)
N
N/****************** Bit definition for GPIO_BSRR register  ********************/
N#define GPIO_BSRR_BS_0             ((uint32_t)0x00000001)
N#define GPIO_BSRR_BS_1             ((uint32_t)0x00000002)
N#define GPIO_BSRR_BS_2             ((uint32_t)0x00000004)
N#define GPIO_BSRR_BS_3             ((uint32_t)0x00000008)
N#define GPIO_BSRR_BS_4             ((uint32_t)0x00000010)
N#define GPIO_BSRR_BS_5             ((uint32_t)0x00000020)
N#define GPIO_BSRR_BS_6             ((uint32_t)0x00000040)
N#define GPIO_BSRR_BS_7             ((uint32_t)0x00000080)
N#define GPIO_BSRR_BS_8             ((uint32_t)0x00000100)
N#define GPIO_BSRR_BS_9             ((uint32_t)0x00000200)
N#define GPIO_BSRR_BS_10            ((uint32_t)0x00000400)
N#define GPIO_BSRR_BS_11            ((uint32_t)0x00000800)
N#define GPIO_BSRR_BS_12            ((uint32_t)0x00001000)
N#define GPIO_BSRR_BS_13            ((uint32_t)0x00002000)
N#define GPIO_BSRR_BS_14            ((uint32_t)0x00004000)
N#define GPIO_BSRR_BS_15            ((uint32_t)0x00008000)
N#define GPIO_BSRR_BR_0             ((uint32_t)0x00010000)
N#define GPIO_BSRR_BR_1             ((uint32_t)0x00020000)
N#define GPIO_BSRR_BR_2             ((uint32_t)0x00040000)
N#define GPIO_BSRR_BR_3             ((uint32_t)0x00080000)
N#define GPIO_BSRR_BR_4             ((uint32_t)0x00100000)
N#define GPIO_BSRR_BR_5             ((uint32_t)0x00200000)
N#define GPIO_BSRR_BR_6             ((uint32_t)0x00400000)
N#define GPIO_BSRR_BR_7             ((uint32_t)0x00800000)
N#define GPIO_BSRR_BR_8             ((uint32_t)0x01000000)
N#define GPIO_BSRR_BR_9             ((uint32_t)0x02000000)
N#define GPIO_BSRR_BR_10            ((uint32_t)0x04000000)
N#define GPIO_BSRR_BR_11            ((uint32_t)0x08000000)
N#define GPIO_BSRR_BR_12            ((uint32_t)0x10000000)
N#define GPIO_BSRR_BR_13            ((uint32_t)0x20000000)
N#define GPIO_BSRR_BR_14            ((uint32_t)0x40000000)
N#define GPIO_BSRR_BR_15            ((uint32_t)0x80000000)
N
N/****************** Bit definition for GPIO_LCKR register  ********************/
N#define GPIO_LCKR_LCK0             ((uint32_t)0x00000001)
N#define GPIO_LCKR_LCK1             ((uint32_t)0x00000002)
N#define GPIO_LCKR_LCK2             ((uint32_t)0x00000004)
N#define GPIO_LCKR_LCK3             ((uint32_t)0x00000008)
N#define GPIO_LCKR_LCK4             ((uint32_t)0x00000010)
N#define GPIO_LCKR_LCK5             ((uint32_t)0x00000020)
N#define GPIO_LCKR_LCK6             ((uint32_t)0x00000040)
N#define GPIO_LCKR_LCK7             ((uint32_t)0x00000080)
N#define GPIO_LCKR_LCK8             ((uint32_t)0x00000100)
N#define GPIO_LCKR_LCK9             ((uint32_t)0x00000200)
N#define GPIO_LCKR_LCK10            ((uint32_t)0x00000400)
N#define GPIO_LCKR_LCK11            ((uint32_t)0x00000800)
N#define GPIO_LCKR_LCK12            ((uint32_t)0x00001000)
N#define GPIO_LCKR_LCK13            ((uint32_t)0x00002000)
N#define GPIO_LCKR_LCK14            ((uint32_t)0x00004000)
N#define GPIO_LCKR_LCK15            ((uint32_t)0x00008000)
N#define GPIO_LCKR_LCKK             ((uint32_t)0x00010000)
N
N/****************** Bit definition for GPIO_AFRL register  ********************/
N#define GPIO_AFRL_AFRL0            ((uint32_t)0x0000000F)
N#define GPIO_AFRL_AFRL1            ((uint32_t)0x000000F0)
N#define GPIO_AFRL_AFRL2            ((uint32_t)0x00000F00)
N#define GPIO_AFRL_AFRL3            ((uint32_t)0x0000F000)
N#define GPIO_AFRL_AFRL4            ((uint32_t)0x000F0000)
N#define GPIO_AFRL_AFRL5            ((uint32_t)0x00F00000)
N#define GPIO_AFRL_AFRL6            ((uint32_t)0x0F000000)
N#define GPIO_AFRL_AFRL7            ((uint32_t)0xF0000000)
N
N/****************** Bit definition for GPIO_AFRH register  ********************/
N#define GPIO_AFRH_AFRH0            ((uint32_t)0x0000000F)
N#define GPIO_AFRH_AFRH1            ((uint32_t)0x000000F0)
N#define GPIO_AFRH_AFRH2            ((uint32_t)0x00000F00)
N#define GPIO_AFRH_AFRH3            ((uint32_t)0x0000F000)
N#define GPIO_AFRH_AFRH4            ((uint32_t)0x000F0000)
N#define GPIO_AFRH_AFRH5            ((uint32_t)0x00F00000)
N#define GPIO_AFRH_AFRH6            ((uint32_t)0x0F000000)
N#define GPIO_AFRH_AFRH7            ((uint32_t)0xF0000000)
N
N/****************** Bit definition for GPIO_BRR register  *********************/
N#define GPIO_BRR_BR_0              ((uint32_t)0x00000001)
N#define GPIO_BRR_BR_1              ((uint32_t)0x00000002)
N#define GPIO_BRR_BR_2              ((uint32_t)0x00000004)
N#define GPIO_BRR_BR_3              ((uint32_t)0x00000008)
N#define GPIO_BRR_BR_4              ((uint32_t)0x00000010)
N#define GPIO_BRR_BR_5              ((uint32_t)0x00000020)
N#define GPIO_BRR_BR_6              ((uint32_t)0x00000040)
N#define GPIO_BRR_BR_7              ((uint32_t)0x00000080)
N#define GPIO_BRR_BR_8              ((uint32_t)0x00000100)
N#define GPIO_BRR_BR_9              ((uint32_t)0x00000200)
N#define GPIO_BRR_BR_10             ((uint32_t)0x00000400)
N#define GPIO_BRR_BR_11             ((uint32_t)0x00000800)
N#define GPIO_BRR_BR_12             ((uint32_t)0x00001000)
N#define GPIO_BRR_BR_13             ((uint32_t)0x00002000)
N#define GPIO_BRR_BR_14             ((uint32_t)0x00004000)
N#define GPIO_BRR_BR_15             ((uint32_t)0x00008000)
N
N/******************************************************************************/
N/*                                                                            */
N/*                      Inter-integrated Circuit Interface (I2C)              */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for I2C_CR1 register  *******************/
N#define  I2C_CR1_PE                          ((uint32_t)0x00000001)        /*!< Peripheral enable */
N#define  I2C_CR1_TXIE                        ((uint32_t)0x00000002)        /*!< TX interrupt enable */
N#define  I2C_CR1_RXIE                        ((uint32_t)0x00000004)        /*!< RX interrupt enable */
N#define  I2C_CR1_ADDRIE                      ((uint32_t)0x00000008)        /*!< Address match interrupt enable */
N#define  I2C_CR1_NACKIE                      ((uint32_t)0x00000010)        /*!< NACK received interrupt enable */
N#define  I2C_CR1_STOPIE                      ((uint32_t)0x00000020)        /*!< STOP detection interrupt enable */
N#define  I2C_CR1_TCIE                        ((uint32_t)0x00000040)        /*!< Transfer complete interrupt enable */
N#define  I2C_CR1_ERRIE                       ((uint32_t)0x00000080)        /*!< Errors interrupt enable */
N#define  I2C_CR1_DFN                         ((uint32_t)0x00000F00)        /*!< Digital noise filter */
N#define  I2C_CR1_ANFOFF                      ((uint32_t)0x00001000)        /*!< Analog noise filter OFF */
N#define  I2C_CR1_SWRST                       ((uint32_t)0x00002000)        /*!< Software reset */
N#define  I2C_CR1_TXDMAEN                     ((uint32_t)0x00004000)        /*!< DMA transmission requests enable */
N#define  I2C_CR1_RXDMAEN                     ((uint32_t)0x00008000)        /*!< DMA reception requests enable */
N#define  I2C_CR1_SBC                         ((uint32_t)0x00010000)        /*!< Slave byte control */
N#define  I2C_CR1_NOSTRETCH                   ((uint32_t)0x00020000)        /*!< Clock stretching disable */
N#define  I2C_CR1_WUPEN                       ((uint32_t)0x00040000)        /*!< Wakeup from STOP enable */
N#define  I2C_CR1_GCEN                        ((uint32_t)0x00080000)        /*!< General call enable */
N#define  I2C_CR1_SMBHEN                      ((uint32_t)0x00100000)        /*!< SMBus host address enable */
N#define  I2C_CR1_SMBDEN                      ((uint32_t)0x00200000)        /*!< SMBus device default address enable */
N#define  I2C_CR1_ALERTEN                     ((uint32_t)0x00400000)        /*!< SMBus alert enable */
N#define  I2C_CR1_PECEN                       ((uint32_t)0x00800000)        /*!< PEC enable */
N
N/******************  Bit definition for I2C_CR2 register  ********************/
N#define  I2C_CR2_SADD                        ((uint32_t)0x000003FF)        /*!< Slave address (master mode) */
N#define  I2C_CR2_RD_WRN                      ((uint32_t)0x00000400)        /*!< Transfer direction (master mode) */
N#define  I2C_CR2_ADD10                       ((uint32_t)0x00000800)        /*!< 10-bit addressing mode (master mode) */
N#define  I2C_CR2_HEAD10R                     ((uint32_t)0x00001000)        /*!< 10-bit address header only read direction (master mode) */
N#define  I2C_CR2_START                       ((uint32_t)0x00002000)        /*!< START generation */
N#define  I2C_CR2_STOP                        ((uint32_t)0x00004000)        /*!< STOP generation (master mode) */
N#define  I2C_CR2_NACK                        ((uint32_t)0x00008000)        /*!< NACK generation (slave mode) */
N#define  I2C_CR2_NBYTES                      ((uint32_t)0x00FF0000)        /*!< Number of bytes */
N#define  I2C_CR2_RELOAD                      ((uint32_t)0x01000000)        /*!< NBYTES reload mode */
N#define  I2C_CR2_AUTOEND                     ((uint32_t)0x02000000)        /*!< Automatic end mode (master mode) */
N#define  I2C_CR2_PECBYTE                     ((uint32_t)0x04000000)        /*!< Packet error checking byte */
N
N/*******************  Bit definition for I2C_OAR1 register  ******************/
N#define  I2C_OAR1_OA1                        ((uint32_t)0x000003FF)        /*!< Interface own address 1 */
N#define  I2C_OAR1_OA1MODE                    ((uint32_t)0x00000400)        /*!< Own address 1 10-bit mode */
N#define  I2C_OAR1_OA1EN                      ((uint32_t)0x00008000)        /*!< Own address 1 enable */
N
N/*******************  Bit definition for I2C_OAR2 register  ******************/
N#define  I2C_OAR2_OA2                        ((uint32_t)0x000000FE)        /*!< Interface own address 2 */
N#define  I2C_OAR2_OA2MSK                     ((uint32_t)0x00000700)        /*!< Own address 2 masks */
N#define  I2C_OAR2_OA2EN                      ((uint32_t)0x00008000)        /*!< Own address 2 enable */
N
N/*******************  Bit definition for I2C_TIMINGR register *******************/
N#define  I2C_TIMINGR_SCLL                    ((uint32_t)0x000000FF)        /*!< SCL low period (master mode) */
N#define  I2C_TIMINGR_SCLH                    ((uint32_t)0x0000FF00)        /*!< SCL high period (master mode) */
N#define  I2C_TIMINGR_SDADEL                  ((uint32_t)0x000F0000)        /*!< Data hold time */
N#define  I2C_TIMINGR_SCLDEL                  ((uint32_t)0x00F00000)        /*!< Data setup time */
N#define  I2C_TIMINGR_PRESC                   ((uint32_t)0xF0000000)        /*!< Timings prescaler */
N
N/******************* Bit definition for I2C_TIMEOUTR register *******************/
N#define  I2C_TIMEOUTR_TIMEOUTA               ((uint32_t)0x00000FFF)        /*!< Bus timeout A */
N#define  I2C_TIMEOUTR_TIDLE                  ((uint32_t)0x00001000)        /*!< Idle clock timeout detection */
N#define  I2C_TIMEOUTR_TIMOUTEN               ((uint32_t)0x00008000)        /*!< Clock timeout enable */
N#define  I2C_TIMEOUTR_TIMEOUTB               ((uint32_t)0x0FFF0000)        /*!< Bus timeout B*/
N#define  I2C_TIMEOUTR_TEXTEN                 ((uint32_t)0x80000000)        /*!< Extended clock timeout enable */
N
N/******************  Bit definition for I2C_ISR register  *********************/
N#define  I2C_ISR_TXE                         ((uint32_t)0x00000001)        /*!< Transmit data register empty */
N#define  I2C_ISR_TXIS                        ((uint32_t)0x00000002)        /*!< Transmit interrupt status */
N#define  I2C_ISR_RXNE                        ((uint32_t)0x00000004)        /*!< Receive data register not empty */
N#define  I2C_ISR_ADDR                        ((uint32_t)0x00000008)        /*!< Address matched (slave mode)*/
N#define  I2C_ISR_NACKF                       ((uint32_t)0x00000010)        /*!< NACK received flag */
N#define  I2C_ISR_STOPF                       ((uint32_t)0x00000020)        /*!< STOP detection flag */
N#define  I2C_ISR_TC                          ((uint32_t)0x00000040)        /*!< Transfer complete (master mode) */
N#define  I2C_ISR_TCR                         ((uint32_t)0x00000080)        /*!< Transfer complete reload */
N#define  I2C_ISR_BERR                        ((uint32_t)0x00000100)        /*!< Bus error */
N#define  I2C_ISR_ARLO                        ((uint32_t)0x00000200)        /*!< Arbitration lost */
N#define  I2C_ISR_OVR                         ((uint32_t)0x00000400)        /*!< Overrun/Underrun */
N#define  I2C_ISR_PECERR                      ((uint32_t)0x00000800)        /*!< PEC error in reception */
N#define  I2C_ISR_TIMEOUT                     ((uint32_t)0x00001000)        /*!< Timeout or Tlow detection flag */
N#define  I2C_ISR_ALERT                       ((uint32_t)0x00002000)        /*!< SMBus alert */
N#define  I2C_ISR_BUSY                        ((uint32_t)0x00008000)        /*!< Bus busy */
N#define  I2C_ISR_DIR                         ((uint32_t)0x00010000)        /*!< Transfer direction (slave mode) */
N#define  I2C_ISR_ADDCODE                     ((uint32_t)0x00FE0000)        /*!< Address match code (slave mode) */
N
N/******************  Bit definition for I2C_ICR register  *********************/
N#define  I2C_ICR_ADDRCF                      ((uint32_t)0x00000008)        /*!< Address matched clear flag */
N#define  I2C_ICR_NACKCF                      ((uint32_t)0x00000010)        /*!< NACK clear flag */
N#define  I2C_ICR_STOPCF                      ((uint32_t)0x00000020)        /*!< STOP detection clear flag */
N#define  I2C_ICR_BERRCF                      ((uint32_t)0x00000100)        /*!< Bus error clear flag */
N#define  I2C_ICR_ARLOCF                      ((uint32_t)0x00000200)        /*!< Arbitration lost clear flag */
N#define  I2C_ICR_OVRCF                       ((uint32_t)0x00000400)        /*!< Overrun/Underrun clear flag */
N#define  I2C_ICR_PECCF                       ((uint32_t)0x00000800)        /*!< PAC error clear flag */
N#define  I2C_ICR_TIMOUTCF                    ((uint32_t)0x00001000)        /*!< Timeout clear flag */
N#define  I2C_ICR_ALERTCF                     ((uint32_t)0x00002000)        /*!< Alert clear flag */
N
N/******************  Bit definition for I2C_PECR register  *********************/
N#define  I2C_PECR_PEC                        ((uint32_t)0x000000FF)        /*!< PEC register */
N
N/******************  Bit definition for I2C_RXDR register  *********************/
N#define  I2C_RXDR_RXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit receive data */
N
N/******************  Bit definition for I2C_TXDR register  *********************/
N#define  I2C_TXDR_TXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit transmit data */
N
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Independent WATCHDOG (IWDG)                      */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
N
N/*******************  Bit definition for IWDG_PR register  ********************/
N#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
N#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
N#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
N#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
N
N/*******************  Bit definition for IWDG_RLR register  *******************/
N#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
N
N/*******************  Bit definition for IWDG_SR register  ********************/
N#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
N#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
N#define  IWDG_SR_WVU                         ((uint8_t)0x04)               /*!< Watchdog counter window value update */
N
N/*******************  Bit definition for IWDG_KR register  ********************/
N#define  IWDG_WINR_WIN                       ((uint16_t)0x0FFF)            /*!< Watchdog counter window value */
N
N/******************************************************************************/
N/*                                                                            */
N/*                          HDMI-CEC (CEC)                                    */
N/*                                                                            */
N/******************************************************************************/
N
N/*******************  Bit definition for CEC_CR register  *********************/
N#define  CEC_CR_CECEN                        ((uint32_t)0x00000001)       /*!< CEC Enable                              */
N#define  CEC_CR_TXSOM                        ((uint32_t)0x00000002)       /*!< CEC Tx Start Of Message                 */
N#define  CEC_CR_TXEOM                        ((uint32_t)0x00000004)       /*!< CEC Tx End Of Message                   */
N
N/*******************  Bit definition for CEC_CFGR register  *******************/
N#define  CEC_CFGR_SFT                        ((uint32_t)0x00000007)       /*!< CEC Signal Free Time                    */
N#define  CEC_CFGR_RXTOL                      ((uint32_t)0x00000008)       /*!< CEC Tolerance                           */
N#define  CEC_CFGR_BRESTP                     ((uint32_t)0x00000010)       /*!< CEC Rx Stop                             */
N#define  CEC_CFGR_BREGEN                     ((uint32_t)0x00000020)       /*!< CEC Bit Rising Error generation         */
N#define  CEC_CFGR_LREGEN                     ((uint32_t)0x00000040)       /*!< CEC Long Period Error generation        */
N#define  CEC_CFGR_SFTOPT                     ((uint32_t)0x00000100)       /*!< CEC Signal Free Time optional           */
N#define  CEC_CFGR_BRDNOGEN                   ((uint32_t)0x00000080)       /*!< CEC Broadcast No error generation       */
N#define  CEC_CFGR_OAR                        ((uint32_t)0x7FFF0000)       /*!< CEC Own Address                         */
N#define  CEC_CFGR_LSTN                       ((uint32_t)0x80000000)       /*!< CEC Listen mode                         */
N
N/*******************  Bit definition for CEC_TXDR register  *******************/
N#define  CEC_TXDR_TXD                        ((uint32_t)0x000000FF)       /*!< CEC Tx Data                              */
N
N/*******************  Bit definition for CEC_RXDR register  *******************/
N#define  CEC_TXDR_RXD                        ((uint32_t)0x000000FF)       /*!< CEC Rx Data                              */
N
N/*******************  Bit definition for CEC_ISR register  ********************/
N#define  CEC_ISR_RXBR                        ((uint32_t)0x00000001)       /*!< CEC Rx-Byte Received                      */
N#define  CEC_ISR_RXEND                       ((uint32_t)0x00000002)       /*!< CEC End Of Reception                      */
N#define  CEC_ISR_RXOVR                       ((uint32_t)0x00000004)       /*!< CEC Rx-Overrun                            */
N#define  CEC_ISR_BRE                         ((uint32_t)0x00000008)       /*!< CEC Rx Bit Rising Error                   */
N#define  CEC_ISR_SBPE                        ((uint32_t)0x00000010)       /*!< CEC Rx Short Bit period Error             */
N#define  CEC_ISR_LBPE                        ((uint32_t)0x00000020)       /*!< CEC Rx Long Bit period Error              */
N#define  CEC_ISR_RXACKE                      ((uint32_t)0x00000040)       /*!< CEC Rx Missing Acknowledge                */
N#define  CEC_ISR_ARBLST                      ((uint32_t)0x00000080)       /*!< CEC Arbitration Lost                      */
N#define  CEC_ISR_TXBR                        ((uint32_t)0x00000100)       /*!< CEC Tx Byte Request                       */
N#define  CEC_ISR_TXEND                       ((uint32_t)0x00000200)       /*!< CEC End of Transmission                   */
N#define  CEC_ISR_TXUDR                       ((uint32_t)0x00000400)       /*!< CEC Tx-Buffer Underrun                    */
N#define  CEC_ISR_TXERR                       ((uint32_t)0x00000800)       /*!< CEC Tx-Error                              */
N#define  CEC_ISR_TXACKE                      ((uint32_t)0x00001000)       /*!< CEC Tx Missing Acknowledge                */
N
N/*******************  Bit definition for CEC_IER register  ********************/
N#define  CEC_IER_RXBRIE                      ((uint32_t)0x00000001)       /*!< CEC Rx-Byte Received IT Enable            */
N#define  CEC_IER_RXENDIE                     ((uint32_t)0x00000002)       /*!< CEC End Of Reception IT Enable            */
N#define  CEC_IER_RXOVRIE                     ((uint32_t)0x00000004)       /*!< CEC Rx-Overrun IT Enable                  */
N#define  CEC_IER_BREIEIE                     ((uint32_t)0x00000008)       /*!< CEC Rx Bit Rising Error IT Enable         */
N#define  CEC_IER_SBPEIE                      ((uint32_t)0x00000010)       /*!< CEC Rx Short Bit period Error IT Enable   */
N#define  CEC_IER_LBPEIE                      ((uint32_t)0x00000020)       /*!< CEC Rx Long Bit period Error IT Enable    */
N#define  CEC_IER_RXACKEIE                    ((uint32_t)0x00000040)       /*!< CEC Rx Missing Acknowledge IT Enable      */
N#define  CEC_IER_ARBLSTIE                    ((uint32_t)0x00000080)       /*!< CEC Arbitration Lost IT Enable            */
N#define  CEC_IER_TXBRIE                      ((uint32_t)0x00000100)       /*!< CEC Tx Byte Request  IT Enable            */
N#define  CEC_IER_TXENDIE                     ((uint32_t)0x00000200)       /*!< CEC End of Transmission IT Enable         */
N#define  CEC_IER_TXUDRIE                     ((uint32_t)0x00000400)       /*!< CEC Tx-Buffer Underrun IT Enable          */
N#define  CEC_IER_TXERRIE                     ((uint32_t)0x00000800)       /*!< CEC Tx-Error IT Enable                    */
N#define  CEC_IER_TXACKEIE                    ((uint32_t)0x00001000)       /*!< CEC Tx Missing Acknowledge IT Enable      */
N
N/******************************************************************************/
N/*                                                                            */
N/*                             Power Control                                  */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for PWR_CR register  ********************/
N#define  PWR_CR_LPSDSR                       ((uint16_t)0x0001)     /*!< Low-power deepsleep/sleep/low power run */
N#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
N#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
N#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
N#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
N
N#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
N#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
N#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
N#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
N
N/*!< PVD level configuration */
N#define  PWR_CR_PLS_LEV0                     ((uint16_t)0x0000)     /*!< PVD level 0 */
N#define  PWR_CR_PLS_LEV1                     ((uint16_t)0x0020)     /*!< PVD level 1 */
N#define  PWR_CR_PLS_LEV2                     ((uint16_t)0x0040)     /*!< PVD level 2 */
N#define  PWR_CR_PLS_LEV3                     ((uint16_t)0x0060)     /*!< PVD level 3 */
N#define  PWR_CR_PLS_LEV4                     ((uint16_t)0x0080)     /*!< PVD level 4 */
N#define  PWR_CR_PLS_LEV5                     ((uint16_t)0x00A0)     /*!< PVD level 5 */
N#define  PWR_CR_PLS_LEV6                     ((uint16_t)0x00C0)     /*!< PVD level 6 */
N#define  PWR_CR_PLS_LEV7                     ((uint16_t)0x00E0)     /*!< PVD level 7 */
N
N#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
N#define  PWR_CR_SDADC1EN                     ((uint16_t)0x0200)     /*!< Enable Analog part of the SDADC1 */
N#define  PWR_CR_SDADC2EN                     ((uint16_t)0x0400)     /*!< Enable Analog part of the SDADC2 */
N#define  PWR_CR_SDADC3EN                     ((uint16_t)0x0800)     /*!< Enable Analog part of the SDADC3 */
N
N/*******************  Bit definition for PWR_CSR register  ********************/
N#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
N#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
N#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
N#define  PWR_CSR_VREFINTRDYF                 ((uint16_t)0x0008)     /*!< Internal voltage reference (VREFINT) ready flag */
N
N#define  PWR_CSR_EWUP1                       ((uint16_t)0x0100)     /*!< Enable WKUP pin 1 */
N#define  PWR_CSR_EWUP2                       ((uint16_t)0x0200)     /*!< Enable WKUP pin 2 */
N#define  PWR_CSR_EWUP3                       ((uint16_t)0x0400)     /*!< Enable WKUP pin 3 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                         Reset and Clock Control                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bit definition for RCC_CR register  ********************/
N#define  RCC_CR_HSION                        ((uint32_t)0x00000001)
N#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)
N
N#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)
N#define  RCC_CR_HSITRIM_0                    ((uint32_t)0x00000008)/*!<Bit 0 */
N#define  RCC_CR_HSITRIM_1                    ((uint32_t)0x00000010)/*!<Bit 1 */
N#define  RCC_CR_HSITRIM_2                    ((uint32_t)0x00000020)/*!<Bit 2 */
N#define  RCC_CR_HSITRIM_3                    ((uint32_t)0x00000040)/*!<Bit 3 */
N#define  RCC_CR_HSITRIM_4                    ((uint32_t)0x00000080)/*!<Bit 4 */
N
N#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)
N#define  RCC_CR_HSICAL_0                     ((uint32_t)0x00000100)/*!<Bit 0 */
N#define  RCC_CR_HSICAL_1                     ((uint32_t)0x00000200)/*!<Bit 1 */
N#define  RCC_CR_HSICAL_2                     ((uint32_t)0x00000400)/*!<Bit 2 */
N#define  RCC_CR_HSICAL_3                     ((uint32_t)0x00000800)/*!<Bit 3 */
N#define  RCC_CR_HSICAL_4                     ((uint32_t)0x00001000)/*!<Bit 4 */
N#define  RCC_CR_HSICAL_5                     ((uint32_t)0x00002000)/*!<Bit 5 */
N#define  RCC_CR_HSICAL_6                     ((uint32_t)0x00004000)/*!<Bit 6 */
N#define  RCC_CR_HSICAL_7                     ((uint32_t)0x00008000)/*!<Bit 7 */
N
N#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)
N#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)
N#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)
N#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)
N#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)
N#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)
N
N/********************  Bit definition for RCC_CFGR register  ******************/
N/*!< SW configuration */
N#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
N#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
N
N#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
N#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
N#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
N
N/*!< SWS configuration */
N#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
N#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
N#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
N
N#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
N#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
N#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
N
N/*!< HPRE configuration */
N#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
N#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
N#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
N#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
N#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
N
N#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
N#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
N#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
N#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
N#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
N#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
N#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
N#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
N#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
N
N/*!< PPRE1 configuration */
N#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */
N#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */
N
N#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
N
N/*!< PPRE2 configuration */
N#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */
N#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */
N#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
N#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */
N
N#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
N#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */
N#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */
N#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */
N#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */
N
N/*!< ADCPRE configuration */
N#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x0000C000)
N#define  RCC_CFGR_ADCPRE_0                   ((uint32_t)0x00004000)
N#define  RCC_CFGR_ADCPRE_1                   ((uint32_t)0x00008000)
N
N#define  RCC_CFGR_ADCPRE_DIV2                ((uint32_t)0x00000000)        /*!< ADC CLK divided by 2 */
N#define  RCC_CFGR_ADCPRE_DIV4                ((uint32_t)0x00004000)        /*!< ADC CLK divided by 4 */
N#define  RCC_CFGR_ADCPRE_DIV6                ((uint32_t)0x00008000)        /*!< ADC CLK divided by 6 */
N#define  RCC_CFGR_ADCPRE_DIV8                ((uint32_t)0x0000C000)        /*!< ADC CLK divided by 8 */
N
N#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */
N
N#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */
N
N/*!< PLLMUL configuration */
N#define  RCC_CFGR_PLLMULL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
N#define  RCC_CFGR_PLLMULL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  RCC_CFGR_PLLMULL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
N#define  RCC_CFGR_PLLMULL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */
N#define  RCC_CFGR_PLLMULL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */
N
N#define  RCC_CFGR_PLLSRC_HSI_Div2            ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
N#define  RCC_CFGR_PLLSRC_PREDIV1             ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
N
N#define  RCC_CFGR_PLLXTPRE_PREDIV1           ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
N#define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2      ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
N
N#define  RCC_CFGR_PLLMULL2                   ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
N#define  RCC_CFGR_PLLMULL3                   ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
N#define  RCC_CFGR_PLLMULL4                   ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
N#define  RCC_CFGR_PLLMULL5                   ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
N#define  RCC_CFGR_PLLMULL6                   ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
N#define  RCC_CFGR_PLLMULL7                   ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
N#define  RCC_CFGR_PLLMULL8                   ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
N#define  RCC_CFGR_PLLMULL9                   ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
N#define  RCC_CFGR_PLLMULL10                  ((uint32_t)0x00200000)        /*!< PLL input clock10 */
N#define  RCC_CFGR_PLLMULL11                  ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
N#define  RCC_CFGR_PLLMULL12                  ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
N#define  RCC_CFGR_PLLMULL13                  ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
N#define  RCC_CFGR_PLLMULL14                  ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
N#define  RCC_CFGR_PLLMULL15                  ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
N#define  RCC_CFGR_PLLMULL16                  ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
N
N/*!< USB configuration */
N#define  RCC_CFGR_USBPRE                     ((uint32_t)0x00400000)        /*!< USB prescaler */
N
N/*!< MCO configuration */
N#define  RCC_CFGR_MCO                        ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
N#define  RCC_CFGR_MCO_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
N#define  RCC_CFGR_MCO_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
N#define  RCC_CFGR_MCO_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
N
N#define  RCC_CFGR_MCO_NOCLOCK                ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_CFGR_MCO_LSI                    ((uint32_t)0x02000000)        /*!< LSI clock selected as MCO source */
N#define  RCC_CFGR_MCO_LSE                    ((uint32_t)0x03000000)        /*!< LSE clock selected as MCO source */
N#define  RCC_CFGR_MCO_SYSCLK                 ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
N#define  RCC_CFGR_MCO_HSI                    ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
N#define  RCC_CFGR_MCO_HSE                    ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
N#define  RCC_CFGR_MCO_PLL                    ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
N
N/*!< SDADCPRE configuration */
N#define  RCC_CFGR_SDADCPRE                   ((uint32_t)0xF8000000)        /*!< SDADCPRE[4:0] bits (Sigma Delta ADC prescaler) */
N#define  RCC_CFGR_SDADCPRE_0                 ((uint32_t)0x08000000)        /*!< Bit 0 */
N#define  RCC_CFGR_SDADCPRE_1                 ((uint32_t)0x10000000)        /*!< Bit 1 */
N#define  RCC_CFGR_SDADCPRE_2                 ((uint32_t)0x20000000)        /*!< Bit 2 */
N#define  RCC_CFGR_SDADCPRE_3                 ((uint32_t)0x40000000)        /*!< Bit 3 */
N#define  RCC_CFGR_SDADCPRE_4                 ((uint32_t)0x80000000)        /*!< Bit 4 */
N
N#define  RCC_CFGR_SDADCPRE_DIV1              ((uint32_t)0x00000000)        /*!< SDADC CLK not divided */
N#define  RCC_CFGR_SDADCPRE_DIV2              ((uint32_t)0x80000000)        /*!< SDADC CLK divided by 2 */
N#define  RCC_CFGR_SDADCPRE_DIV4              ((uint32_t)0x88000000)        /*!< SDADC CLK divided by 4 */
N#define  RCC_CFGR_SDADCPRE_DIV6              ((uint32_t)0x90000000)        /*!< SDADC CLK divided by 6 */
N#define  RCC_CFGR_SDADCPRE_DIV8              ((uint32_t)0x98000000)        /*!< SDADC CLK divided by 8 */
N#define  RCC_CFGR_SDADCPRE_DIV10             ((uint32_t)0xA0000000)        /*!< SDADC CLK divided by 10 */
N#define  RCC_CFGR_SDADCPRE_DIV12             ((uint32_t)0xA8000000)        /*!< SDADC CLK divided by 12 */
N#define  RCC_CFGR_SDADCPRE_DIV14             ((uint32_t)0xB0000000)        /*!< SDADC CLK divided by 14 */
N#define  RCC_CFGR_SDADCPRE_DIV16             ((uint32_t)0xB8000000)        /*!< SDADC CLK divided by 16 */
N#define  RCC_CFGR_SDADCPRE_DIV20             ((uint32_t)0xC0000000)        /*!< SDADC CLK divided by 20 */
N#define  RCC_CFGR_SDADCPRE_DIV24             ((uint32_t)0xC8000000)        /*!< SDADC CLK divided by 24 */
N#define  RCC_CFGR_SDADCPRE_DIV28             ((uint32_t)0xD0000000)        /*!< SDADC CLK divided by 28 */
N#define  RCC_CFGR_SDADCPRE_DIV32             ((uint32_t)0xD8000000)        /*!< SDADC CLK divided by 32 */
N#define  RCC_CFGR_SDADCPRE_DIV36             ((uint32_t)0xE0000000)        /*!< SDADC CLK divided by 36 */
N#define  RCC_CFGR_SDADCPRE_DIV40             ((uint32_t)0xE8000000)        /*!< SDADC CLK divided by 40 */
N#define  RCC_CFGR_SDADCPRE_DIV44             ((uint32_t)0xF0000000)        /*!< SDADC CLK divided by 44 */
N#define  RCC_CFGR_SDADCPRE_DIV48             ((uint32_t)0xF8000000)        /*!< SDADC CLK divided by 48 */
N
N/*********************  Bit definition for RCC_CIR register  ********************/
N#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
N#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
N#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
N#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
N#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
N#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
N#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
N#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
N#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
N#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
N#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
N#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
N#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
N#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
N#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
N#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
N#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
N
N/******************  Bit definition for RCC_APB2RSTR register  *****************/
N#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00000001)        /*!< SYSCFG reset */
N#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC1 reset */
N#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI1 reset */
N#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */
N#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 reset */
N#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 reset */
N#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 reset */
N#define  RCC_APB2RSTR_TIM19RST               ((uint32_t)0x00080000)        /*!< TIM19 reset */
N#define  RCC_APB2RSTR_SDADC1RST              ((uint32_t)0x01000000)        /*!< SDADC1 reset */
N#define  RCC_APB2RSTR_SDADC2RST              ((uint32_t)0x02000000)        /*!< SDADC2 reset */
N#define  RCC_APB2RSTR_SDADC3RST              ((uint32_t)0x04000000)        /*!< SDADC3 reset */
N
N/******************  Bit definition for RCC_APB1RSTR register  ******************/
N#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */
N#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */
N#define  RCC_APB1RSTR_TIM4RST                ((uint32_t)0x00000004)        /*!< Timer 4 reset */
N#define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
N#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
N#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
N#define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)        /*!< Timer 12 reset */
N#define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)        /*!< Timer 13 reset */
N#define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< Timer 14 reset */
N#define  RCC_APB1RSTR_TIM18RST               ((uint32_t)0x00000200)        /*!< Timer 18 reset */
N#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */
N#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)        /*!< SPI2 reset */
N#define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI3 reset */
N#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */
N#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)        /*!< USART 3 reset */
N#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
N#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)        /*!< I2C 2 reset */
N#define  RCC_APB1RSTR_USBRST                 ((uint32_t)0x00800000)        /*!< USB reset */
N#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)        /*!< CAN reset */
N#define  RCC_APB1RSTR_DAC2RST                ((uint32_t)0x04000000)        /*!< DAC 2 reset */
N#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< PWR reset */
N#define  RCC_APB1RSTR_DAC1RST                ((uint32_t)0x20000000)        /*!< DAC 1 reset */
N#define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC reset */
N
N/******************  Bit definition for RCC_AHBENR register  ******************/
N#define  RCC_AHBENR_DMA1EN                   ((uint32_t)0x00000001)        /*!< DMA1 clock enable */
N#define  RCC_AHBENR_DMA2EN                   ((uint32_t)0x00000002)        /*!< DMA2 clock enable */
N#define  RCC_AHBENR_SRAMEN                   ((uint32_t)0x00000004)        /*!< SRAM interface clock enable */
N#define  RCC_AHBENR_FLITFEN                  ((uint32_t)0x00000010)        /*!< FLITF clock enable */
N#define  RCC_AHBENR_CRCEN                    ((uint32_t)0x00000040)        /*!< CRC clock enable */
N#define  RCC_AHBENR_GPIOAEN                  ((uint32_t)0x00020000)        /*!< GPIOA clock enable */
N#define  RCC_AHBENR_GPIOBEN                  ((uint32_t)0x00040000)        /*!< GPIOB clock enable */
N#define  RCC_AHBENR_GPIOCEN                  ((uint32_t)0x00080000)        /*!< GPIOC clock enable */
N#define  RCC_AHBENR_GPIODEN                  ((uint32_t)0x00100000)        /*!< GPIOD clock enable */
N#define  RCC_AHBENR_GPIOEEN                  ((uint32_t)0x00200000)        /*!< GPIOE clock enable */
N#define  RCC_AHBENR_GPIOFEN                  ((uint32_t)0x00400000)        /*!< GPIOF clock enable */
N
N#define  RCC_AHBENR_TSEN                     ((uint32_t)0x01000000)        /*!< TS clock enable */
N
N/*****************  Bit definition for RCC_APB2ENR register  ******************/
N#define  RCC_APB2ENR_SYSCFGEN                ((uint32_t)0x00000001)        /*!< SYSCFG clock enable */
N#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)        /*!< ADC1 clock enable */
N#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)        /*!< SPI1 clock enable */
N#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)        /*!< USART1 clock enable */
N#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)        /*!< TIM15 clock enable */
N#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)        /*!< TIM16 clock enable */
N#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)        /*!< TIM17 clock enable */
N#define  RCC_APB2ENR_TIM19EN                 ((uint32_t)0x00080000)        /*!< TIM19 clock enable */
N#define  RCC_APB2ENR_SDADC1EN                ((uint32_t)0x01000000)        /*!< SDADC1 clock enable */
N#define  RCC_APB2ENR_SDADC2EN                ((uint32_t)0x02000000)        /*!< SDADC2 clock enable */
N#define  RCC_APB2ENR_SDADC3EN                ((uint32_t)0x04000000)        /*!< SDADC3 clock enable */
N
N/******************  Bit definition for RCC_APB1ENR register  ******************/
N#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enable */
N#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
N#define  RCC_APB1ENR_TIM4EN                  ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */
N#define  RCC_APB1ENR_TIM5EN                  ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
N#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
N#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
N#define  RCC_APB1ENR_TIM12EN                 ((uint32_t)0x00000040)        /*!< Timer 12 clock enable */
N#define  RCC_APB1ENR_TIM13EN                 ((uint32_t)0x00000080)        /*!< Timer 13 clock enable */
N#define  RCC_APB1ENR_TIM14EN                 ((uint32_t)0x00000100)        /*!< Timer 14 clock enable */
N#define  RCC_APB1ENR_TIM18EN                 ((uint32_t)0x00000200)        /*!< Timer 18 clock enable */
N#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
N#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)        /*!< SPI2 clock enable */
N#define  RCC_APB1ENR_SPI3EN                  ((uint32_t)0x00008000)        /*!< SPI3 clock enable */
N#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */
N#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)        /*!< USART 3 clock enable */
N#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
N#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */
N#define  RCC_APB1ENR_USBEN                   ((uint32_t)0x00800000)        /*!< USB clock enable */
N#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)        /*!< CAN clock enable */
N#define  RCC_APB1ENR_DAC2EN                  ((uint32_t)0x04000000)        /*!< DAC 2 clock enable */
N#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< PWR clock enable */
N#define  RCC_APB1ENR_DAC1EN                  ((uint32_t)0x20000000)        /*!< DAC 1 clock enable */
N#define  RCC_APB1ENR_CECEN                   ((uint32_t)0x40000000)        /*!< CEC clock enable */
N
N/********************  Bit definition for RCC_BDCR register  ******************/
N#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */
N#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */
N#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */
N
N#define  RCC_BDCR_LSEDRV                     ((uint32_t)0x00000018)        /*!< LSEDRV[1:0] bits (LSE Osc. drive capability) */
N#define  RCC_BDCR_LSEDRV_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
N#define  RCC_BDCR_LSEDRV_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
N
N
N#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
N#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
N#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
N
N/*!< RTC configuration */
N#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
N#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */
N#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */
N#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 32 used as RTC clock */
N
N#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */
N#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */
N
N/********************  Bit definition for RCC_CSR register  *******************/
N#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
N#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
N#define  RCC_CSR_V18PWRRSTF                  ((uint32_t)0x00800000)        /*!< V1.8 power domain reset flag */
N#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */
N#define  RCC_CSR_OBL                         ((uint32_t)0x02000000)        /*!< OBL reset flag */
N#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */
N#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
N#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */
N#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
N#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
N#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
N
N/*******************  Bit definition for RCC_AHBRSTR register  ****************/
N#define  RCC_AHBRSTR_GPIOARST                ((uint32_t)0x00020000)         /*!< GPIOA reset */
N#define  RCC_AHBRSTR_GPIOBRST                ((uint32_t)0x00040000)         /*!< GPIOB reset */
N#define  RCC_AHBRSTR_GPIOCRST                ((uint32_t)0x00080000)         /*!< GPIOC reset */
N#define  RCC_AHBRSTR_GPIODRST                ((uint32_t)0x00010000)         /*!< GPIOD reset */
N#define  RCC_AHBRSTR_GPIOFRST                ((uint32_t)0x00040000)         /*!< GPIOF reset */
N#define  RCC_AHBRSTR_TSRST                   ((uint32_t)0x00100000)         /*!< TS reset */
N
N/*******************  Bit definition for RCC_CFGR2 register  ******************/
N/*!< PREDIV1 configuration */
N#define  RCC_CFGR2_PREDIV1                   ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
N#define  RCC_CFGR2_PREDIV1_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR2_PREDIV1_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
N#define  RCC_CFGR2_PREDIV1_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
N#define  RCC_CFGR2_PREDIV1_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
N
N#define  RCC_CFGR2_PREDIV1_DIV1              ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
N#define  RCC_CFGR2_PREDIV1_DIV2              ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
N#define  RCC_CFGR2_PREDIV1_DIV3              ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
N#define  RCC_CFGR2_PREDIV1_DIV4              ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
N#define  RCC_CFGR2_PREDIV1_DIV5              ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
N#define  RCC_CFGR2_PREDIV1_DIV6              ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
N#define  RCC_CFGR2_PREDIV1_DIV7              ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
N#define  RCC_CFGR2_PREDIV1_DIV8              ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
N#define  RCC_CFGR2_PREDIV1_DIV9              ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
N#define  RCC_CFGR2_PREDIV1_DIV10             ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
N#define  RCC_CFGR2_PREDIV1_DIV11             ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
N#define  RCC_CFGR2_PREDIV1_DIV12             ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
N#define  RCC_CFGR2_PREDIV1_DIV13             ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
N#define  RCC_CFGR2_PREDIV1_DIV14             ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
N#define  RCC_CFGR2_PREDIV1_DIV15             ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
N#define  RCC_CFGR2_PREDIV1_DIV16             ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
N
N/*******************  Bit definition for RCC_CFGR3 register  ******************/
N#define  RCC_CFGR3_USART1SW                  ((uint32_t)0x00000003)        /*!< USART1SW[1:0] bits */
N#define  RCC_CFGR3_USART1SW_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
N#define  RCC_CFGR3_USART1SW_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
N
N#define  RCC_CFGR3_I2CSW                     ((uint32_t)0x00000030)        /*!< I2CSW bits */
N#define  RCC_CFGR3_I2C1SW                    ((uint32_t)0x00000010)        /*!< I2C1SW bits */ 
N#define  RCC_CFGR3_I2C2SW                    ((uint32_t)0x00000020)        /*!< I2C2SW bits */
N#define  RCC_CFGR3_CECSW                     ((uint32_t)0x00000040)        /*!< CECSW bits */ 
N
N#define  RCC_CFGR3_USART2SW                  ((uint32_t)0x00030000)        /*!< USART2SW[1:0] bits */
N#define  RCC_CFGR3_USART2SW_0                ((uint32_t)0x00010000)        /*!< Bit 0 */
N#define  RCC_CFGR3_USART2SW_1                ((uint32_t)0x00020000)        /*!< Bit 1 */
N
N#define  RCC_CFGR3_USART3SW                  ((uint32_t)0x000C0000)        /*!< USART3SW[1:0] bits */
N#define  RCC_CFGR3_USART3SW_0                ((uint32_t)0x00040000)        /*!< Bit 0 */
N#define  RCC_CFGR3_USART3SW_1                ((uint32_t)0x00080000)        /*!< Bit 1 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                           Real-Time Clock (RTC)                            */
N/*                                                                            */
N/******************************************************************************/
N/********************  Bits definition for RTC_TR register  *******************/
N#define RTC_TR_PM                            ((uint32_t)0x00400000)
N#define RTC_TR_HT                            ((uint32_t)0x00300000)
N#define RTC_TR_HT_0                          ((uint32_t)0x00100000)
N#define RTC_TR_HT_1                          ((uint32_t)0x00200000)
N#define RTC_TR_HU                            ((uint32_t)0x000F0000)
N#define RTC_TR_HU_0                          ((uint32_t)0x00010000)
N#define RTC_TR_HU_1                          ((uint32_t)0x00020000)
N#define RTC_TR_HU_2                          ((uint32_t)0x00040000)
N#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
N#define RTC_TR_MNT                           ((uint32_t)0x00007000)
N#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)
N#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)
N#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)
N#define RTC_TR_MNU                           ((uint32_t)0x00000F00)
N#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)
N#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)
N#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)
N#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)
N#define RTC_TR_ST                            ((uint32_t)0x00000070)
N#define RTC_TR_ST_0                          ((uint32_t)0x00000010)
N#define RTC_TR_ST_1                          ((uint32_t)0x00000020)
N#define RTC_TR_ST_2                          ((uint32_t)0x00000040)
N#define RTC_TR_SU                            ((uint32_t)0x0000000F)
N#define RTC_TR_SU_0                          ((uint32_t)0x00000001)
N#define RTC_TR_SU_1                          ((uint32_t)0x00000002)
N#define RTC_TR_SU_2                          ((uint32_t)0x00000004)
N#define RTC_TR_SU_3                          ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_DR register  *******************/
N#define RTC_DR_YT                            ((uint32_t)0x00F00000)
N#define RTC_DR_YT_0                          ((uint32_t)0x00100000)
N#define RTC_DR_YT_1                          ((uint32_t)0x00200000)
N#define RTC_DR_YT_2                          ((uint32_t)0x00400000)
N#define RTC_DR_YT_3                          ((uint32_t)0x00800000)
N#define RTC_DR_YU                            ((uint32_t)0x000F0000)
N#define RTC_DR_YU_0                          ((uint32_t)0x00010000)
N#define RTC_DR_YU_1                          ((uint32_t)0x00020000)
N#define RTC_DR_YU_2                          ((uint32_t)0x00040000)
N#define RTC_DR_YU_3                          ((uint32_t)0x00080000)
N#define RTC_DR_WDU                           ((uint32_t)0x0000E000)
N#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)
N#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)
N#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)
N#define RTC_DR_MT                            ((uint32_t)0x00001000)
N#define RTC_DR_MU                            ((uint32_t)0x00000F00)
N#define RTC_DR_MU_0                          ((uint32_t)0x00000100)
N#define RTC_DR_MU_1                          ((uint32_t)0x00000200)
N#define RTC_DR_MU_2                          ((uint32_t)0x00000400)
N#define RTC_DR_MU_3                          ((uint32_t)0x00000800)
N#define RTC_DR_DT                            ((uint32_t)0x00000030)
N#define RTC_DR_DT_0                          ((uint32_t)0x00000010)
N#define RTC_DR_DT_1                          ((uint32_t)0x00000020)
N#define RTC_DR_DU                            ((uint32_t)0x0000000F)
N#define RTC_DR_DU_0                          ((uint32_t)0x00000001)
N#define RTC_DR_DU_1                          ((uint32_t)0x00000002)
N#define RTC_DR_DU_2                          ((uint32_t)0x00000004)
N#define RTC_DR_DU_3                          ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_CR register  *******************/
N#define RTC_CR_COE                           ((uint32_t)0x00800000)
N#define RTC_CR_OSEL                          ((uint32_t)0x00600000)
N#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)
N#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
N#define RTC_CR_POL                           ((uint32_t)0x00100000)
N#define RTC_CR_COSEL                         ((uint32_t)0x00080000)
N#define RTC_CR_BCK                           ((uint32_t)0x00040000)
N#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)
N#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)
N#define RTC_CR_TSIE                          ((uint32_t)0x00008000)
N#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)
N#define RTC_CR_ALRBIE                        ((uint32_t)0x00002000)
N#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)
N#define RTC_CR_TSE                           ((uint32_t)0x00000800)
N#define RTC_CR_WUTE                          ((uint32_t)0x00000400)
N#define RTC_CR_ALRBE                         ((uint32_t)0x00000200)
N#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)
N#define RTC_CR_FMT                           ((uint32_t)0x00000040)
N#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)
N#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)
N#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)
N#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)
N#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)
N#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)
N#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)
N
N/********************  Bits definition for RTC_ISR register  ******************/
N#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)
N#define RTC_ISR_TAMP3F                       ((uint32_t)0x00008000)
N#define RTC_ISR_TAMP2F                       ((uint32_t)0x00004000)
N#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)
N#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)
N#define RTC_ISR_TSF                          ((uint32_t)0x00000800)
N#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)
N#define RTC_ISR_ALRBF                        ((uint32_t)0x00000200)
N#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)
N#define RTC_ISR_INIT                         ((uint32_t)0x00000080)
N#define RTC_ISR_INITF                        ((uint32_t)0x00000040)
N#define RTC_ISR_RSF                          ((uint32_t)0x00000020)
N#define RTC_ISR_INITS                        ((uint32_t)0x00000010)
N#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)
N#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)
N#define RTC_ISR_ALRBWF                       ((uint32_t)0x00000002)
N#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)
N
N/********************  Bits definition for RTC_PRER register  *****************/
N#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)
N#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00007FFF)
N
N/********************  Bits definition for RTC_WUTR register  *****************/
N#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_ALRMAR register  ***************/
N#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)
N#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)
N#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)
N#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)
N#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)
N#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)
N#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)
N#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)
N#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)
N#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)
N#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)
N#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)
N#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)
N#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)
N#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)
N#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)
N#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)
N#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)
N#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)
N#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)
N#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)
N#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)
N#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)
N#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)
N#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)
N#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)
N#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)
N#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)
N#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)
N#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)
N#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)
N#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)
N#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)
N#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)
N#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)
N#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)
N#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)
N#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)
N#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)
N#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_ALRMBR register  ***************/
N#define RTC_ALRMBR_MSK4                      ((uint32_t)0x80000000)
N#define RTC_ALRMBR_WDSEL                     ((uint32_t)0x40000000)
N#define RTC_ALRMBR_DT                        ((uint32_t)0x30000000)
N#define RTC_ALRMBR_DT_0                      ((uint32_t)0x10000000)
N#define RTC_ALRMBR_DT_1                      ((uint32_t)0x20000000)
N#define RTC_ALRMBR_DU                        ((uint32_t)0x0F000000)
N#define RTC_ALRMBR_DU_0                      ((uint32_t)0x01000000)
N#define RTC_ALRMBR_DU_1                      ((uint32_t)0x02000000)
N#define RTC_ALRMBR_DU_2                      ((uint32_t)0x04000000)
N#define RTC_ALRMBR_DU_3                      ((uint32_t)0x08000000)
N#define RTC_ALRMBR_MSK3                      ((uint32_t)0x00800000)
N#define RTC_ALRMBR_PM                        ((uint32_t)0x00400000)
N#define RTC_ALRMBR_HT                        ((uint32_t)0x00300000)
N#define RTC_ALRMBR_HT_0                      ((uint32_t)0x00100000)
N#define RTC_ALRMBR_HT_1                      ((uint32_t)0x00200000)
N#define RTC_ALRMBR_HU                        ((uint32_t)0x000F0000)
N#define RTC_ALRMBR_HU_0                      ((uint32_t)0x00010000)
N#define RTC_ALRMBR_HU_1                      ((uint32_t)0x00020000)
N#define RTC_ALRMBR_HU_2                      ((uint32_t)0x00040000)
N#define RTC_ALRMBR_HU_3                      ((uint32_t)0x00080000)
N#define RTC_ALRMBR_MSK2                      ((uint32_t)0x00008000)
N#define RTC_ALRMBR_MNT                       ((uint32_t)0x00007000)
N#define RTC_ALRMBR_MNT_0                     ((uint32_t)0x00001000)
N#define RTC_ALRMBR_MNT_1                     ((uint32_t)0x00002000)
N#define RTC_ALRMBR_MNT_2                     ((uint32_t)0x00004000)
N#define RTC_ALRMBR_MNU                       ((uint32_t)0x00000F00)
N#define RTC_ALRMBR_MNU_0                     ((uint32_t)0x00000100)
N#define RTC_ALRMBR_MNU_1                     ((uint32_t)0x00000200)
N#define RTC_ALRMBR_MNU_2                     ((uint32_t)0x00000400)
N#define RTC_ALRMBR_MNU_3                     ((uint32_t)0x00000800)
N#define RTC_ALRMBR_MSK1                      ((uint32_t)0x00000080)
N#define RTC_ALRMBR_ST                        ((uint32_t)0x00000070)
N#define RTC_ALRMBR_ST_0                      ((uint32_t)0x00000010)
N#define RTC_ALRMBR_ST_1                      ((uint32_t)0x00000020)
N#define RTC_ALRMBR_ST_2                      ((uint32_t)0x00000040)
N#define RTC_ALRMBR_SU                        ((uint32_t)0x0000000F)
N#define RTC_ALRMBR_SU_0                      ((uint32_t)0x00000001)
N#define RTC_ALRMBR_SU_1                      ((uint32_t)0x00000002)
N#define RTC_ALRMBR_SU_2                      ((uint32_t)0x00000004)
N#define RTC_ALRMBR_SU_3                      ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_WPR register  ******************/
N#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)
N
N/********************  Bits definition for RTC_SSR register  ******************/
N#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_SHIFTR register  ***************/
N#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)
N#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)
N
N/********************  Bits definition for RTC_TSTR register  *****************/
N#define RTC_TSTR_PM                          ((uint32_t)0x00400000)
N#define RTC_TSTR_HT                          ((uint32_t)0x00300000)
N#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)
N#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)
N#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)
N#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)
N#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)
N#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)
N#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)
N#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)
N#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)
N#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)
N#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)
N#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)
N#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)
N#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)
N#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)
N#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)
N#define RTC_TSTR_ST                          ((uint32_t)0x00000070)
N#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)
N#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)
N#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)
N#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)
N#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)
N#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)
N#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)
N#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_TSDR register  *****************/
N#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)
N#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)
N#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)
N#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)
N#define RTC_TSDR_MT                          ((uint32_t)0x00001000)
N#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)
N#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)
N#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)
N#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)
N#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)
N#define RTC_TSDR_DT                          ((uint32_t)0x00000030)
N#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)
N#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)
N#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)
N#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)
N#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)
N#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)
N#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)
N
N/********************  Bits definition for RTC_TSSSR register  ****************/
N#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
N
N/********************  Bits definition for RTC_CAL register  *****************/
N#define RTC_CALR_CALP                        ((uint32_t)0x00008000)
N#define RTC_CALR_CALW8                       ((uint32_t)0x00004000)
N#define RTC_CALR_CALW16                      ((uint32_t)0x00002000)
N#define RTC_CALR_CALM                        ((uint32_t)0x000001FF)
N#define RTC_CALR_CALM_0                      ((uint32_t)0x00000001)
N#define RTC_CALR_CALM_1                      ((uint32_t)0x00000002)
N#define RTC_CALR_CALM_2                      ((uint32_t)0x00000004)
N#define RTC_CALR_CALM_3                      ((uint32_t)0x00000008)
N#define RTC_CALR_CALM_4                      ((uint32_t)0x00000010)
N#define RTC_CALR_CALM_5                      ((uint32_t)0x00000020)
N#define RTC_CALR_CALM_6                      ((uint32_t)0x00000040)
N#define RTC_CALR_CALM_7                      ((uint32_t)0x00000080)
N#define RTC_CALR_CALM_8                      ((uint32_t)0x00000100)
N
N/********************  Bits definition for RTC_TAFCR register  ****************/
N#define RTC_TAFCR_ALARMOUTTYPE               ((uint32_t)0x00040000)
N#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)
N#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)
N#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)
N#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)
N#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)
N#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)
N#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)
N#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)
N#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)
N#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)
N#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)
N#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)
N#define RTC_TAFCR_TAMP3TRG                   ((uint32_t)0x00000040)
N#define RTC_TAFCR_TAMP3E                     ((uint32_t)0x00000020)
N#define RTC_TAFCR_TAMP2TRG                   ((uint32_t)0x00000010)
N#define RTC_TAFCR_TAMP2E                     ((uint32_t)0x00000008)
N#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)
N#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)
N#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)
N
N/********************  Bits definition for RTC_ALRMASSR register  *************/
N#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)
N#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)
N#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)
N#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)
N#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)
N#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)
N
N/********************  Bits definition for RTC_ALRMBSSR register  *************/
N#define RTC_ALRMBSSR_MASKSS                  ((uint32_t)0x0F000000)
N#define RTC_ALRMBSSR_MASKSS_0                ((uint32_t)0x01000000)
N#define RTC_ALRMBSSR_MASKSS_1                ((uint32_t)0x02000000)
N#define RTC_ALRMBSSR_MASKSS_2                ((uint32_t)0x04000000)
N#define RTC_ALRMBSSR_MASKSS_3                ((uint32_t)0x08000000)
N#define RTC_ALRMBSSR_SS                      ((uint32_t)0x00007FFF)
N
N/********************  Bits definition for RTC_BKP0R register  ****************/
N#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP1R register  ****************/
N#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP2R register  ****************/
N#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP3R register  ****************/
N#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP4R register  ****************/
N#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP5R register  ****************/
N#define RTC_BKP5R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP6R register  ****************/
N#define RTC_BKP6R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP7R register  ****************/
N#define RTC_BKP7R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP8R register  ****************/
N#define RTC_BKP8R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP9R register  ****************/
N#define RTC_BKP9R                            ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP10R register  ***************/
N#define RTC_BKP10R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP11R register  ***************/
N#define RTC_BKP11R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP12R register  ***************/
N#define RTC_BKP12R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP13R register  ***************/
N#define RTC_BKP13R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP14R register  ***************/
N#define RTC_BKP14R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP15R register  ***************/
N#define RTC_BKP15R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP16R register  ***************/
N#define RTC_BKP16R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP17R register  ***************/
N#define RTC_BKP17R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP18R register  ***************/
N#define RTC_BKP18R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP19R register  ***************/
N#define RTC_BKP19R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP20R register  ***************/
N#define RTC_BKP20R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP21R register  ***************/
N#define RTC_BKP21R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP22R register  ***************/
N#define RTC_BKP22R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP23R register  ***************/
N#define RTC_BKP23R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP24R register  ***************/
N#define RTC_BKP24R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP25R register  ***************/
N#define RTC_BKP25R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP26R register  ***************/
N#define RTC_BKP26R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP27R register  ***************/
N#define RTC_BKP27R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP28R register  ***************/
N#define RTC_BKP28R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP29R register  ***************/
N#define RTC_BKP29R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP30R register  ***************/
N#define RTC_BKP30R                           ((uint32_t)0xFFFFFFFF)
N
N/********************  Bits definition for RTC_BKP31R register  ***************/
N#define RTC_BKP31R                           ((uint32_t)0xFFFFFFFF)
N
N/******************************************************************************/
N/*                                                                            */
N/*             Sigma-Delta Analog to Digital Converter (SDADC)                */
N/*                                                                            */
N/******************************************************************************/
N
N/*****************  Bit definition for SDADC_CR1 register  ********************/
N#define  SDADC_CR1_EOCALIE                       ((uint32_t)0x00000001)        /*!< End of calibration interrupt enable */
N#define  SDADC_CR1_JEOCIE                        ((uint32_t)0x00000002)        /*!< Injected end of conversion interrupt enable */
N#define  SDADC_CR1_JOVRIE                        ((uint32_t)0x00000004)        /*!< Injected data overrun interrupt enable */
N#define  SDADC_CR1_REOCIE                        ((uint32_t)0x00000008)        /*!< Regular end of conversion interrupt enable */
N#define  SDADC_CR1_ROVRIE                        ((uint32_t)0x00000010)        /*!< Regular data overrun interrupt enable */
N#define  SDADC_CR1_REFV                          ((uint32_t)0x00000300)        /*!< Reference voltage selection */
N#define  SDADC_CR1_REFV_0                        ((uint32_t)0x00000100)        /*!< Reference voltage selection bit 0 */
N#define  SDADC_CR1_REFV_1                        ((uint32_t)0x00000200)        /*!< Reference voltage selection bit 1 */
N#define  SDADC_CR1_SLOWCK                        ((uint32_t)0x00000400)        /*!< Slow clock mode enable */
N#define  SDADC_CR1_SBI                           ((uint32_t)0x00000800)        /*!< Enter standby mode when idle */
N#define  SDADC_CR1_PDI                           ((uint32_t)0x00001000)        /*!< Enter power down mode when idle */
N#define  SDADC_CR1_JSYNC                         ((uint32_t)0x00004000)        /*!< Launch a injected conversion synchronously with SDADC1 */
N#define  SDADC_CR1_RSYNC                         ((uint32_t)0x00008000)        /*!< Launch regular conversion synchronously with SDADC1 */
N#define  SDADC_CR1_JDMAEN                        ((uint32_t)0x00010000)        /*!< DMA channel enabled to read data for the injected channel group */
N#define  SDADC_CR1_RDMAEN                        ((uint32_t)0x00020000)        /*!< DMA channel enabled to read data for the regular channel */
N#define  SDADC_CR1_INIT                          ((uint32_t)0x80000000)        /*!< Initialization mode request */
N
N/*****************  Bit definition for SDADC_CR2 register  ********************/
N#define  SDADC_CR2_ADON                          ((uint32_t)0x00000001)        /*!< SDADC enable */
N#define  SDADC_CR2_CALIBCNT                      ((uint32_t)0x00000006)        /*!< Number of calibration sequences to be performed */
N#define  SDADC_CR2_CALIBCNT_0                    ((uint32_t)0x00000002)        /*!< Number of calibration sequences to be performed bit 0 */
N#define  SDADC_CR2_CALIBCNT_1                    ((uint32_t)0x00000004)        /*!< Number of calibration sequences to be performed bit 1 */
N#define  SDADC_CR2_STARTCALIB                    ((uint32_t)0x00000010)        /*!< Start calibration */
N#define  SDADC_CR2_JCONT                         ((uint32_t)0x00000020)        /*!< Continuous mode selection for injected conversions */
N#define  SDADC_CR2_JDS                           ((uint32_t)0x00000040)        /*!< Delay start of injected conversions */
N#define  SDADC_CR2_JEXTSEL                       ((uint32_t)0x00000F00)        /*!< Trigger signal selection for launching injected conversions */
N#define  SDADC_CR2_JEXTSEL_0                     ((uint32_t)0x00000100)        /*!< Trigger signal selection for launching injected conversions bit 0 */
N#define  SDADC_CR2_JEXTSEL_1                     ((uint32_t)0x00000200)        /*!< Trigger signal selection for launching injected conversions bit 1 */
N#define  SDADC_CR2_JEXTSEL_2                     ((uint32_t)0x00000400)        /*!< Trigger signal selection for launching injected conversions bit 2 */
N#define  SDADC_CR2_JEXTSEL_3                     ((uint32_t)0x00000800)        /*!< Trigger signal selection for launching injected conversions bit 3 */
N#define  SDADC_CR2_JEXTEN                        ((uint32_t)0x00006000)        /*!< Trigger enable and trigger edge selection for injected conversions */
N#define  SDADC_CR2_JEXTEN_0                      ((uint32_t)0x00002000)        /*!< Trigger enable and trigger edge selection for injected conversions bit 0 */
N#define  SDADC_CR2_JEXTEN_1                      ((uint32_t)0x00004000)        /*!< Trigger enable and trigger edge selection for injected conversions bit 1 */
N#define  SDADC_CR2_JSWSTART                      ((uint32_t)0x00008000)        /*!< Start a conversion of the injected group of channels */
N#define  SDADC_CR2_RCH                           ((uint32_t)0x000F0000)        /*!< Regular channel selection */
N#define  SDADC_CR2_RCH_0                         ((uint32_t)0x00010000)        /*!< Regular channel selection bit 0 */
N#define  SDADC_CR2_RCH_1                         ((uint32_t)0x00020000)        /*!< Regular channel selection bit 1 */
N#define  SDADC_CR2_RCH_2                         ((uint32_t)0x00040000)        /*!< Regular channel selection bit 2 */
N#define  SDADC_CR2_RCH_3                         ((uint32_t)0x00080000)        /*!< Regular channel selection bit 3 */
N#define  SDADC_CR2_RCONT                         ((uint32_t)0x00400000)        /*!< Continuous mode selection for regular conversions */
N#define  SDADC_CR2_RSWSTART                      ((uint32_t)0x00800000)        /*!< Software start of a conversion on the regular channel */
N#define  SDADC_CR2_FAST                          ((uint32_t)0x01000000)        /*!< Fast conversion mode selection */
N
N/********************  Bit definition for SDADC_ISR register  *****************/
N#define  SDADC_ISR_EOCALF                        ((uint32_t)0x00000001)        /*!< End of calibration flag */
N#define  SDADC_ISR_JEOCF                         ((uint32_t)0x00000002)        /*!< End of injected conversion flag */
N#define  SDADC_ISR_JOVRF                         ((uint32_t)0x00000004)        /*!< Injected conversion overrun flag */
N#define  SDADC_ISR_REOCF                         ((uint32_t)0x00000010)        /*!< End of regular conversion flag */
N#define  SDADC_ISR_ROVRF                         ((uint32_t)0x00000020)        /*!< Regular conversion overrun flag */
N#define  SDADC_ISR_CALIBIP                       ((uint32_t)0x00001000)        /*!< Calibration in progress status */
N#define  SDADC_ISR_JCIP                          ((uint32_t)0x00002000)        /*!< Injected conversion in progress status */
N#define  SDADC_ISR_RCIP                          ((uint32_t)0x00004000)        /*!< Regular conversion in progress status */
N#define  SDADC_ISR_STABIP                        ((uint32_t)0x00008000)        /*!< Stabilization in progress status */
N#define  SDADC_ISR_INITRDY                       ((uint32_t)0x80000000)        /*!< Initialization mode is ready */
N
N/******************  Bit definition for SDADC_CLRISR register  ****************/
N#define  SDADC_ISR_CLREOCALF                     ((uint32_t)0x00000001)       /*!< Clear the end of calibration flag */
N#define  SDADC_ISR_CLRJOVRF                      ((uint32_t)0x00000004)       /*!< Clear the injected conversion overrun flag */
N#define  SDADC_ISR_CLRROVRF                      ((uint32_t)0x00000010)       /*!< Clear the regular conversion overrun flag */
N
N/******************  Bit definition for SDADC_JCHGR register  *****************/
N#define  SDADC_JCHGR_JCHG                        ((uint32_t)0x000001FF)       /*!< Injected channel group selection */
N#define  SDADC_JCHGR_JCHG_0                      ((uint32_t)0x00000001)       /*!< Injected channel 0 selection */
N#define  SDADC_JCHGR_JCHG_1                      ((uint32_t)0x00000002)       /*!< Injected channel 1 selection */
N#define  SDADC_JCHGR_JCHG_2                      ((uint32_t)0x00000004)       /*!< Injected channel 2 selection */
N#define  SDADC_JCHGR_JCHG_3                      ((uint32_t)0x00000008)       /*!< Injected channel 3 selection */
N#define  SDADC_JCHGR_JCHG_4                      ((uint32_t)0x00000010)       /*!< Injected channel 4 selection */
N#define  SDADC_JCHGR_JCHG_5                      ((uint32_t)0x00000020)       /*!< Injected channel 5 selection */
N#define  SDADC_JCHGR_JCHG_6                      ((uint32_t)0x00000040)       /*!< Injected channel 6 selection */
N#define  SDADC_JCHGR_JCHG_7                      ((uint32_t)0x00000080)       /*!< Injected channel 7 selection */
N#define  SDADC_JCHGR_JCHG_8                      ((uint32_t)0x00000100)       /*!< Injected channel 8 selection */
N
N/******************  Bit definition for SDADC_CONF0R register  ****************/
N#define  SDADC_CONF0R_OFFSET0                    ((uint32_t)0x00000FFF)       /*!< 12-bit calibration offset for configuration 0 */
N#define  SDADC_CONF0R_GAIN0                      ((uint32_t)0x00700000)       /*!< Gain setting for configuration 0 */
N#define  SDADC_CONF0R_GAIN0_0                    ((uint32_t)0x00100000)       /*!< Gain setting for configuration 0 Bit 0*/
N#define  SDADC_CONF0R_GAIN0_1                    ((uint32_t)0x00200000)       /*!< Gain setting for configuration 0 Bit 1 */
N#define  SDADC_CONF0R_GAIN0_2                    ((uint32_t)0x00400000)       /*!< Gain setting for configuration 0 Bit 2 */
N#define  SDADC_CONF0R_SE0                        ((uint32_t)0x0C000000)       /*!< Single ended mode for configuration 0 */
N#define  SDADC_CONF0R_SE0_0                      ((uint32_t)0x04000000)       /*!< Single ended mode for configuration 0 Bit 0 */
N#define  SDADC_CONF0R_SE0_1                      ((uint32_t)0x08000000)       /*!< Single ended mode for configuration 0 Bit 1 */
N#define  SDADC_CONF0R_COMMON0                    ((uint32_t)0xC0000000)       /*!< Common mode for configuration 0 */
N#define  SDADC_CONF0R_COMMON0_0                  ((uint32_t)0x40000000)       /*!< Common mode for configuration 0 Bit 0 */
N#define  SDADC_CONF0R_COMMON0_1                  ((uint32_t)0x80000000)       /*!< Common mode for configuration 0 Bit 1 */
N
N/******************  Bit definition for SDADC_CONF1R register  ****************/
N#define  SDADC_CONF1R_OFFSET1                    ((uint32_t)0x00000FFF)       /*!< 12-bit calibration offset for configuration 1 */
N#define  SDADC_CONF1R_GAIN1                      ((uint32_t)0x00700000)       /*!< Gain setting for configuration 1 */
N#define  SDADC_CONF1R_GAIN1_0                    ((uint32_t)0x00100000)       /*!< Gain setting for configuration 1 Bit 0 */
N#define  SDADC_CONF1R_GAIN1_1                    ((uint32_t)0x00200000)       /*!< Gain setting for configuration 1 Bit 1 */
N#define  SDADC_CONF1R_GAIN1_2                    ((uint32_t)0x00400000)       /*!< Gain setting for configuration 1 Bit 2 */
N#define  SDADC_CONF1R_SE1                        ((uint32_t)0x0C000000)       /*!< Single ended mode for configuration 1 */
N#define  SDADC_CONF1R_SE1_0                      ((uint32_t)0x04000000)       /*!< Single ended mode for configuration 1 Bit 0 */
N#define  SDADC_CONF1R_SE1_1                      ((uint32_t)0x08000000)       /*!< Single ended mode for configuration 1 Bit 1 */
N#define  SDADC_CONF1R_COMMON1                    ((uint32_t)0xC0000000)       /*!< Common mode for configuration 1 */
N#define  SDADC_CONF1R_COMMON1_0                  ((uint32_t)0x40000000)       /*!< Common mode for configuration 1 Bit 0 */
N#define  SDADC_CONF1R_COMMON1_1                  ((uint32_t)0x40000000)       /*!< Common mode for configuration 1 Bit 1 */
N
N/******************  Bit definition for SDADC_CONF2R register  ****************/
N#define  SDADC_CONF2R_OFFSET2                    ((uint32_t)0x00000FFF)       /*!< 12-bit calibration offset for configuration 2 */
N#define  SDADC_CONF2R_GAIN2                      ((uint32_t)0x00700000)       /*!< Gain setting for configuration 2 */
N#define  SDADC_CONF2R_GAIN2_0                    ((uint32_t)0x00100000)       /*!< Gain setting for configuration 2 Bit 0 */
N#define  SDADC_CONF2R_GAIN2_1                    ((uint32_t)0x00200000)       /*!< Gain setting for configuration 2 Bit 1 */
N#define  SDADC_CONF2R_GAIN2_2                    ((uint32_t)0x00400000)       /*!< Gain setting for configuration 2 Bit 2 */
N#define  SDADC_CONF2R_SE2                        ((uint32_t)0x0C000000)       /*!< Single ended mode for configuration 2 */
N#define  SDADC_CONF2R_SE2_0                      ((uint32_t)0x04000000)       /*!< Single ended mode for configuration 2 Bit 0 */
N#define  SDADC_CONF2R_SE2_1                      ((uint32_t)0x08000000)       /*!< Single ended mode for configuration 2 Bit 1 */
N#define  SDADC_CONF2R_COMMON2                    ((uint32_t)0xC0000000)       /*!< Common mode for configuration 2 */
N#define  SDADC_CONF2R_COMMON2_0                  ((uint32_t)0x40000000)       /*!< Common mode for configuration 2 Bit 0 */
N#define  SDADC_CONF2R_COMMON2_1                  ((uint32_t)0x80000000)       /*!< Common mode for configuration 2 Bit 1 */
N
N/*****************  Bit definition for SDADC_CONFCHR1 register  ***************/
N#define  SDADC_CONFCHR1_CONFCH0                  ((uint32_t)0x00000003)      /*!< Channel 0 configuration */
N#define  SDADC_CONFCHR1_CONFCH1                  ((uint32_t)0x00000030)      /*!< Channel 1 configuration */
N#define  SDADC_CONFCHR1_CONFCH2                  ((uint32_t)0x00000300)      /*!< Channel 2 configuration */
N#define  SDADC_CONFCHR1_CONFCH3                  ((uint32_t)0x00003000)      /*!< Channel 3 configuration */
N#define  SDADC_CONFCHR1_CONFCH4                  ((uint32_t)0x00030000)      /*!< Channel 4 configuration */
N#define  SDADC_CONFCHR1_CONFCH5                  ((uint32_t)0x00300000)      /*!< Channel 5 configuration */
N#define  SDADC_CONFCHR1_CONFCH6                  ((uint32_t)0x03000000)      /*!< Channel 6 configuration */
N#define  SDADC_CONFCHR1_CONFCH7                  ((uint32_t)0x30000000)      /*!< Channel 7 configuration */
N
N/*****************  Bit definition for SDADC_CONFCHR2 register  ***************/
N#define  SDADC_CONFCHR2_CONFCH8                  ((uint32_t)0x00000003)      /*!< Channel 8 configuration */
N
N/*****************  Bit definition for SDADC_JDATAR register  ***************/
N#define  SDADC_JDATAR_JDATA                      ((uint32_t)0x0000FFFF)      /*!< Injected group conversion data */
N#define  SDADC_JDATAR_JDATACH                    ((uint32_t)0x0F000000)      /*!< Injected channel most recently converted */
N#define  SDADC_JDATAR_JDATACH_0                  ((uint32_t)0x01000000)      /*!< Injected channel most recently converted bit 0 */
N#define  SDADC_JDATAR_JDATACH_1                  ((uint32_t)0x02000000)      /*!< Injected channel most recently converted bit 1 */
N#define  SDADC_JDATAR_JDATACH_2                  ((uint32_t)0x04000000)      /*!< Injected channel most recently converted bit 2 */
N#define  SDADC_JDATAR_JDATACH_3                  ((uint32_t)0x08000000)      /*!< Injected channel most recently converted bit 3 */
N
N/*****************  Bit definition for SDADC_RDATAR register  ***************/
N#define  SDADC_RDATAR_RDATA                      ((uint32_t)0x0000FFFF)      /*!< Injected group conversion data */
N
N/*****************  Bit definition for SDADC_JDATA12R register  ***************/
N#define  SDADC_JDATA12R_JDATA2                      ((uint32_t)0xFFFF0000)      /*!< Injected group conversion data for SDADC2 */
N#define  SDADC_JDATA12R_JDATA1                      ((uint32_t)0x0000FFFF)      /*!< Injected group conversion data for SDADC1 */
N
N/*****************  Bit definition for SDADC_RDATA12R register  ***************/
N#define  SDADC_RDATA12R_RDATA2                      ((uint32_t)0xFFFF0000)      /*!< Regular conversion data for SDADC2 */
N#define  SDADC_RDATA12R_RDATA1                      ((uint32_t)0x0000FFFF)      /*!< Regular conversion data for SDADC1 */
N
N/*****************  Bit definition for SDADC_JDATA13R register  ***************/
N#define  SDADC_JDATA13R_JDATA3                      ((uint32_t)0xFFFF0000)      /*!< Injected group conversion data for SDADC3 */
N#define  SDADC_JDATA13R_JDATA1                      ((uint32_t)0x0000FFFF)      /*!< Injected group conversion data for SDADC1 */
N
N/*****************  Bit definition for SDADC_RDATA13R register  ***************/
N#define  SDADC_RDATA13R_RDATA3                      ((uint32_t)0xFFFF0000)      /*!< Regular conversion data for SDADC3 */
N#define  SDADC_RDATA13R_RDATA1                      ((uint32_t)0x0000FFFF)      /*!< Regular conversion data for SDADC1 */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        Serial Peripheral Interface (SPI)                   */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for SPI_CR1 register  ********************/
N#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
N#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
N#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
N#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
N#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
N#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
N#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
N#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
N#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
N#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
N#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
N#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
N#define  SPI_CR1_CRCL                        ((uint16_t)0x0800)            /*!< CRC Length */
N#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
N#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
N#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
N#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
N
N/*******************  Bit definition for SPI_CR2 register  ********************/
N#define  SPI_CR2_RXDMAEN                     ((uint16_t)0x0001)            /*!< Rx Buffer DMA Enable */
N#define  SPI_CR2_TXDMAEN                     ((uint16_t)0x0002)            /*!< Tx Buffer DMA Enable */
N#define  SPI_CR2_SSOE                        ((uint16_t)0x0004)            /*!< SS Output Enable */
N#define  SPI_CR2_NSSP                        ((uint16_t)0x0008)            /*!< NSS pulse management Enable */
N#define  SPI_CR2_FRF                         ((uint16_t)0x0010)            /*!< Frame Format Enable */
N#define  SPI_CR2_ERRIE                       ((uint16_t)0x0020)            /*!< Error Interrupt Enable */
N#define  SPI_CR2_RXNEIE                      ((uint16_t)0x0040)            /*!< RX buffer Not Empty Interrupt Enable */
N#define  SPI_CR2_TXEIE                       ((uint16_t)0x0080)            /*!< Tx buffer Empty Interrupt Enable */
N#define  SPI_CR2_DS                          ((uint16_t)0x0F00)            /*!< DS[3:0] Data Size */
N#define  SPI_CR2_DS_0                        ((uint16_t)0x0100)            /*!< Bit 0 */
N#define  SPI_CR2_DS_1                        ((uint16_t)0x0200)            /*!< Bit 1 */
N#define  SPI_CR2_DS_2                        ((uint16_t)0x0400)            /*!< Bit 2 */
N#define  SPI_CR2_DS_3                        ((uint16_t)0x0800)            /*!< Bit 3 */
N#define  SPI_CR2_FRXTH                       ((uint16_t)0x1000)            /*!< FIFO reception Threshold */
N#define  SPI_CR2_LDMARX                      ((uint16_t)0x2000)            /*!< Last DMA transfer for reception */
N#define  SPI_CR2_LDMATX                      ((uint16_t)0x4000)            /*!< Last DMA transfer for transmission */
N
N/********************  Bit definition for SPI_SR register  ********************/
N#define  SPI_SR_RXNE                         ((uint16_t)0x0001)            /*!< Receive buffer Not Empty */
N#define  SPI_SR_TXE                          ((uint16_t)0x0002)            /*!< Transmit buffer Empty */
N#define  SPI_SR_CHSIDE                       ((uint16_t)0x0004)            /*!< Channel side */
N#define  SPI_SR_UDR                          ((uint16_t)0x0008)            /*!< Underrun flag */
N#define  SPI_SR_CRCERR                       ((uint16_t)0x0010)            /*!< CRC Error flag */
N#define  SPI_SR_MODF                         ((uint16_t)0x0020)            /*!< Mode fault */
N#define  SPI_SR_OVR                          ((uint16_t)0x0040)            /*!< Overrun flag */
N#define  SPI_SR_BSY                          ((uint16_t)0x0080)            /*!< Busy flag */
N#define  SPI_SR_FRE                          ((uint16_t)0x0100)            /*!< TI frame format error */
N#define  SPI_SR_FRLVL                        ((uint16_t)0x0600)            /*!< FIFO Reception Level */
N#define  SPI_SR_FRLVL_0                      ((uint16_t)0x0200)            /*!< Bit 0 */
N#define  SPI_SR_FRLVL_1                      ((uint16_t)0x0400)            /*!< Bit 1 */
N#define  SPI_SR_FTLVL                        ((uint16_t)0x1800)            /*!< FIFO Transmission Level */
N#define  SPI_SR_FTLVL_0                      ((uint16_t)0x0800)            /*!< Bit 0 */
N#define  SPI_SR_FTLVL_1                      ((uint16_t)0x1000)            /*!< Bit 1 */  
N
N/********************  Bit definition for SPI_DR register  ********************/
N#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
N
N/*******************  Bit definition for SPI_CRCPR register  ******************/
N#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
N
N/******************  Bit definition for SPI_RXCRCR register  ******************/
N#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
N
N/******************  Bit definition for SPI_TXCRCR register  ******************/
N#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
N
N/******************  Bit definition for SPI_I2SCFGR register  *****************/
N#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
N#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred) */
N#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
N#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity */
N#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
N#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization */
N#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
N#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable */
N#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
N
N/******************  Bit definition for SPI_I2SPR register  *******************/
N#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler */
N#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
N#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable */
N
N/******************************************************************************/
N/*                                                                            */
N/*                        System Configuration(SYSCFG)                        */
N/*                                                                            */
N/******************************************************************************/
N/*****************  Bit definition for SYSCFG_CFGR1 register  ****************/
N#define SYSCFG_CFGR1_MEM_MODE               ((uint32_t)0x00000003) /*!< SYSCFG_Memory Remap Config */
N#define SYSCFG_CFGR1_MEM_MODE_0             ((uint32_t)0x00000001) /*!< Bit 0 */
N#define SYSCFG_CFGR1_MEM_MODE_1             ((uint32_t)0x00000002) /*!< Bit 1 */
N#define SYSCFG_CFGR1_TIM16_DMA_RMP          ((uint32_t)0x00000800) /*!< Timer 16 DMA remap */
N#define SYSCFG_CFGR1_TIM17_DMA_RMP          ((uint32_t)0x00001000) /*!< Timer 17 DMA remap */
N#define SYSCFG_CFGR1_TIM6DAC1Ch1_DMA_RMP    ((uint32_t)0x00002000) /*!< Timer 6 / DAC1 Ch1 DMA remap */
N#define SYSCFG_CFGR1_TIM7DAC1Ch2_DMA_RMP    ((uint32_t)0x00004000) /*!< Timer 7 / DAC1 Ch2 DMA remap */
N#define SYSCFG_CFGR1_TIM18DAC2Ch1_DMA_RMP   ((uint32_t)0x00008000) /*!< Timer 18 / DAC2 Ch1 DMA remap */
N#define SYSCFG_CFGR1_I2C_FMP_PB6            ((uint32_t)0x00010000) /*!< I2C PB6 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_PB7            ((uint32_t)0x00020000) /*!< I2C PB7 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_PB8            ((uint32_t)0x00040000) /*!< I2C PB8 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_PB9            ((uint32_t)0x00080000) /*!< I2C PB9 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_I2C1           ((uint32_t)0x00100000) /*!< I2C1 Fast mode plus */
N#define SYSCFG_CFGR1_I2C_FMP_I2C2           ((uint32_t)0x00200000) /*!< I2C2 Fast mode plus */
N#define SYSCFG_CFGR1_VBAT                   ((uint32_t)0x01000000) /*!< VBAT monitoring */
N#define SYSCFG_CFGR1_FPU_IE                 ((uint32_t)0xFC000000) /*!< Floating Point Unit Interrupt Enable */
N#define SYSCFG_CFGR1_FPU_IE_0               ((uint32_t)0x04000000) /*!< Floating Point Unit Interrupt Enable 0 */
N#define SYSCFG_CFGR1_FPU_IE_1               ((uint32_t)0x08000000) /*!< Floating Point Unit Interrupt Enable 1 */
N#define SYSCFG_CFGR1_FPU_IE_2               ((uint32_t)0x10000000) /*!< Floating Point Unit Interrupt Enable 2 */
N#define SYSCFG_CFGR1_FPU_IE_3               ((uint32_t)0x20000000) /*!< Floating Point Unit Interrupt Enable 3 */
N#define SYSCFG_CFGR1_FPU_IE_4               ((uint32_t)0x40000000) /*!< Floating Point Unit Interrupt Enable 4 */
N#define SYSCFG_CFGR1_FPU_IE_5               ((uint32_t)0x80000000) /*!< Floating Point Unit Interrupt Enable 5 */
N
N/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
N#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!< EXTI 0 configuration */
N#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!< EXTI 1 configuration */
N#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!< EXTI 2 configuration */
N#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!< EXTI 3 configuration */
N
N/** 
N  * @brief  EXTI0 configuration  
N  */ 
N#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!< PA[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!< PB[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!< PC[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!< PD[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!< PE[0] pin */
N#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0005) /*!< PF[0] pin */
N
N/** 
N  * @brief  EXTI1 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!< PA[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!< PB[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!< PC[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!< PD[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!< PE[1] pin */
N#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0050) /*!< PF[1] pin */
N
N/** 
N  * @brief  EXTI2 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!< PA[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!< PB[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!< PC[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!< PD[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!< PE[2] pin */
N#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0500) /*!< PF[2] pin */
N
N/** 
N  * @brief  EXTI3 configuration  
N  */
N#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!< PA[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!< PB[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!< PC[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!< PD[3] pin */
N#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!< PE[3] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR2 register  *****************/
N#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!< EXTI 4 configuration */
N#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!< EXTI 5 configuration */
N#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!< EXTI 6 configuration */
N#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!< EXTI 7 configuration */
N
N/** 
N  * @brief  EXTI4 configuration  
N  */ 
N#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!< PA[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!< PB[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!< PC[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!< PD[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!< PE[4] pin */
N#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0005) /*!< PF[4] pin */
N
N/** 
N  * @brief  EXTI5 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!< PA[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!< PB[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!< PC[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!< PD[5] pin */
N#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!< PE[5] pin */
N
N/** 
N  * @brief  EXTI6 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!< PA[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!< PB[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!< PC[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!< PD[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!< PE[6] pin */
N#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0500) /*!< PF[6] pin */
N
N/** 
N  * @brief  EXTI7 configuration  
N  */
N#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!< PA[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!< PB[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!< PC[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!< PD[7] pin */
N#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!< PE[7] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR3 register  *****************/
N#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!< EXTI 8 configuration */
N#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!< EXTI 9 configuration */
N#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!< EXTI 10 configuration */
N#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!< EXTI 11 configuration */
N
N/** 
N  * @brief  EXTI8 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!< PA[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!< PB[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!< PC[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!< PD[8] pin */
N#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!< PE[8] pin */
N
N/** 
N  * @brief  EXTI9 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!< PA[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!< PB[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!< PC[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!< PD[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!< PE[9] pin */
N#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0050) /*!< PF[9] pin */
N
N/** 
N  * @brief  EXTI10 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!< PA[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!< PB[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!< PC[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!< PD[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!< PE[10] pin */
N#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0500) /*!< PF[10] pin */
N
N/** 
N  * @brief  EXTI11 configuration  
N  */
N#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!< PA[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!< PC[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!< PD[11] pin */
N#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!< PE[11] pin */
N
N/*****************  Bit definition for SYSCFG_EXTICR4 register  *****************/
N#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!< EXTI 12 configuration */
N#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!< EXTI 13 configuration */
N#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!< EXTI 14 configuration */
N#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!< EXTI 15 configuration */
N
N/** 
N  * @brief  EXTI12 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!< PA[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!< PC[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!< PD[12] pin */
N#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!< PE[12] pin */
N
N/** 
N  * @brief  EXTI13 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!< PA[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!< PC[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!< PD[13] pin */
N#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!< PE[13] pin */
N
N/** 
N  * @brief  EXTI14 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!< PA[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!< PB[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!< PC[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!< PD[14] pin */
N#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!< PE[14] pin */
N
N/** 
N  * @brief  EXTI15 configuration  
N  */
N#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!< PA[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!< PB[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!< PC[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!< PD[15] pin */
N#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!< PE[15] pin */
N
N/*****************  Bit definition for SYSCFG_CFGR2 register  ****************/
N#define SYSCFG_CFGR2_LOCKUP_LOCK               ((uint32_t)0x00000001) /*!< Enables and locks the PVD connection with Timer1 Break Input and also the PVD_EN and PVDSEL[2:0] bits of the Power Control Interface */
N#define SYSCFG_CFGR2_SRAM_PARITY_LOCK          ((uint32_t)0x00000002) /*!< Enables and locks the SRAM_PARITY error signal with Break Input of TIMER1 */
N#define SYSCFG_CFGR2_PVD_LOCK                  ((uint32_t)0x00000004) /*!< Enables and locks the LOCKUP (Hardfault) output of CortexM0 with Break Input of TIMER1 */
N#define SYSCFG_CFGR2_SRAM_PE                   ((uint32_t)0x00000100) /*!< SRAM Parity error flag */
N
N/******************************************************************************/
N/*                                                                            */
N/*                                    TIM                                     */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for TIM_CR1 register  ********************/
N#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable */
N#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable */
N#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
N#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode */
N#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction */
N
N#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
N#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
N#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
N
N#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable */
N
N#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
N#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N
N/*******************  Bit definition for TIM_CR2 register  ********************/
N#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!<Capture/Compare Preloaded Control */
N#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!<Capture/Compare Control Update Selection */
N#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection */
N
N#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
N#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
N#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!<Output Idle state 1 (OC1 output) */
N#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!<Output Idle state 1 (OC1N output) */
N#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!<Output Idle state 2 (OC2 output) */
N#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!<Output Idle state 2 (OC2N output) */
N#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!<Output Idle state 3 (OC3 output) */
N#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!<Output Idle state 3 (OC3N output) */
N#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!<Output Idle state 4 (OC4 output) */
N
N/*******************  Bit definition for TIM_SMCR register  *******************/
N#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection) */
N#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N
N#define  TIM_SMCR_OCCS                       ((uint16_t)0x0008)            /*!< OCREF clear selection */
N
N#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection) */
N#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode */
N
N#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
N#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
N
N#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
N#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
N
N#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable */
N#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
N
N/*******************  Bit definition for TIM_DIER register  *******************/
N#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
N#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable */
N#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable */
N#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable */
N#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable */
N#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!<COM interrupt enable */
N#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable */
N#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!<Break interrupt enable */
N#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable */
N#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
N#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
N#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
N#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
N#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!<COM DMA request enable */
N#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable */
N
N/********************  Bit definition for TIM_SR register  ********************/
N#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag */
N#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag */
N#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag */
N#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag */
N#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag */
N#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!<COM interrupt Flag */
N#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag */
N#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!<Break interrupt Flag */
N#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
N#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
N#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
N#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
N
N/*******************  Bit definition for TIM_EGR register  ********************/
N#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation */
N#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation */
N#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation */
N#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation */
N#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation */
N#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!<Capture/Compare Control Update Generation */
N#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation */
N#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!<Break Generation */
N
N/******************  Bit definition for TIM_CCMR1 register  *******************/
N#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
N#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable */
N#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable */
N
N#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
N#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable */
N
N#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
N#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable */
N#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable */
N
N#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
N#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
N#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
N#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
N#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
N#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/******************  Bit definition for TIM_CCMR2 register  *******************/
N#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
N#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable */
N#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable */
N
N#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
N#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
N
N#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
N#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable */
N#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
N
N#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
N#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N
N#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
N
N/*----------------------------------------------------------------------------*/
N
N#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
N#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
N#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
N
N#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
N#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
N
N#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
N#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
N#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
N#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
N#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
N
N/*******************  Bit definition for TIM_CCER register  *******************/
N#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable */
N#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity */
N#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!<Capture/Compare 1 Complementary output enable */
N#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
N#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable */
N#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity */
N#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!<Capture/Compare 2 Complementary output enable */
N#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
N#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable */
N#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity */
N#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!<Capture/Compare 3 Complementary output enable */
N#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
N#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable */
N#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity */
N#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!<Capture/Compare 4 Complementary output Polarity */
N
N/*******************  Bit definition for TIM_CNT register  ********************/
N#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value */
N
N/*******************  Bit definition for TIM_PSC register  ********************/
N#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value */
N
N/*******************  Bit definition for TIM_ARR register  ********************/
N#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
N
N/*******************  Bit definition for TIM_RCR register  ********************/
N#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!<Repetition Counter Value */
N
N/*******************  Bit definition for TIM_CCR1 register  *******************/
N#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value */
N
N/*******************  Bit definition for TIM_CCR2 register  *******************/
N#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value */
N
N/*******************  Bit definition for TIM_CCR3 register  *******************/
N#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value */
N
N/*******************  Bit definition for TIM_CCR4 register  *******************/
N#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value */
N
N/*******************  Bit definition for TIM_BDTR register  *******************/
N#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
N#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
N#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!<Bit 6 */
N#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!<Bit 7 */
N
N#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!<LOCK[1:0] bits (Lock Configuration) */
N#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!<Bit 1 */
N
N#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!<Off-State Selection for Idle mode */
N#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!<Off-State Selection for Run mode */
N#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!<Break enable */
N#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!<Break Polarity */
N#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!<Automatic Output enable */
N#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!<Main Output enable */
N
N/*******************  Bit definition for TIM_DCR register  ********************/
N#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
N#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
N
N#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
N#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
N#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
N#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
N#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
N#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
N
N/*******************  Bit definition for TIM_DMAR register  *******************/
N#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses */
N
N/*******************  Bit definition for TIM_OR register  *********************/
N#define TIM14_OR_TI1_RMP                       ((uint16_t)0x00C0)            /*!<TI1_RMP[1:0] bits (TIM14 Input 4 remap) */
N#define TIM14_OR_TI1_RMP_0                     ((uint16_t)0x0040)            /*!<Bit 0 */
N#define TIM14_OR_TI1_RMP_1                     ((uint16_t)0x0080)            /*!<Bit 1 */
N
N/******************************************************************************/
N/*                                                                            */
N/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
N/*                                                                            */
N/******************************************************************************/
N/******************  Bit definition for USART_CR1 register  *******************/
N#define  USART_CR1_UE                        ((uint32_t)0x00000001)            /*!< USART Enable */
N#define  USART_CR1_UESM                      ((uint32_t)0x00000002)            /*!< USART Enable in STOP Mode */
N#define  USART_CR1_RE                        ((uint32_t)0x00000004)            /*!< Receiver Enable */
N#define  USART_CR1_TE                        ((uint32_t)0x00000008)            /*!< Transmitter Enable */
N#define  USART_CR1_IDLEIE                    ((uint32_t)0x00000010)            /*!< IDLE Interrupt Enable */
N#define  USART_CR1_RXNEIE                    ((uint32_t)0x00000020)            /*!< RXNE Interrupt Enable */
N#define  USART_CR1_TCIE                      ((uint32_t)0x00000040)            /*!< Transmission Complete Interrupt Enable */
N#define  USART_CR1_TXEIE                     ((uint32_t)0x00000080)            /*!< TXE Interrupt Enable */
N#define  USART_CR1_PEIE                      ((uint32_t)0x00000100)            /*!< PE Interrupt Enable */
N#define  USART_CR1_PS                        ((uint32_t)0x00000200)            /*!< Parity Selection */
N#define  USART_CR1_PCE                       ((uint32_t)0x00000400)            /*!< Parity Control Enable */
N#define  USART_CR1_WAKE                      ((uint32_t)0x00000800)            /*!< Receiver Wakeup method */
N#define  USART_CR1_M                         ((uint32_t)0x00001000)            /*!< Word length */
N#define  USART_CR1_MME                       ((uint32_t)0x00002000)            /*!< Mute Mode Enable */
N#define  USART_CR1_CMIE                      ((uint32_t)0x00004000)            /*!< Character match interrupt enable */
N#define  USART_CR1_OVER8                     ((uint32_t)0x00008000)            /*!< Oversampling by 8-bit or 16-bit mode */
N#define  USART_CR1_DEDT                      ((uint32_t)0x001F0000)            /*!< DEDT[4:0] bits (Driver Enable Deassertion Time) */
N#define  USART_CR1_DEDT_0                    ((uint32_t)0x00010000)            /*!< Bit 0 */
N#define  USART_CR1_DEDT_1                    ((uint32_t)0x00020000)            /*!< Bit 1 */
N#define  USART_CR1_DEDT_2                    ((uint32_t)0x00040000)            /*!< Bit 2 */
N#define  USART_CR1_DEDT_3                    ((uint32_t)0x00080000)            /*!< Bit 3 */
N#define  USART_CR1_DEDT_4                    ((uint32_t)0x00100000)            /*!< Bit 4 */
N#define  USART_CR1_DEAT                      ((uint32_t)0x03E00000)            /*!< DEAT[4:0] bits (Driver Enable Assertion Time) */
N#define  USART_CR1_DEAT_0                    ((uint32_t)0x00200000)            /*!< Bit 0 */
N#define  USART_CR1_DEAT_1                    ((uint32_t)0x00400000)            /*!< Bit 1 */
N#define  USART_CR1_DEAT_2                    ((uint32_t)0x00800000)            /*!< Bit 2 */
N#define  USART_CR1_DEAT_3                    ((uint32_t)0x01000000)            /*!< Bit 3 */
N#define  USART_CR1_DEAT_4                    ((uint32_t)0x02000000)            /*!< Bit 4 */
N#define  USART_CR1_RTOIE                     ((uint32_t)0x04000000)            /*!< Receive Time Out interrupt enable */
N#define  USART_CR1_EOBIE                     ((uint32_t)0x08000000)            /*!< End of Block interrupt enable */
N
N/******************  Bit definition for USART_CR2 register  *******************/
N#define  USART_CR2_ADDM7                     ((uint32_t)0x00000010)            /*!< 7-bit or 4-bit Address Detection */
N#define  USART_CR2_LBDL                      ((uint32_t)0x00000020)            /*!< LIN Break Detection Length */
N#define  USART_CR2_LBDIE                     ((uint32_t)0x00000040)            /*!< LIN Break Detection Interrupt Enable */
N#define  USART_CR2_LBCL                      ((uint32_t)0x00000100)            /*!< Last Bit Clock pulse */
N#define  USART_CR2_CPHA                      ((uint32_t)0x00000200)            /*!< Clock Phase */
N#define  USART_CR2_CPOL                      ((uint32_t)0x00000400)            /*!< Clock Polarity */
N#define  USART_CR2_CLKEN                     ((uint32_t)0x00000800)            /*!< Clock Enable */
N#define  USART_CR2_STOP                      ((uint32_t)0x00003000)            /*!< STOP[1:0] bits (STOP bits) */
N#define  USART_CR2_STOP_0                    ((uint32_t)0x00001000)            /*!< Bit 0 */
N#define  USART_CR2_STOP_1                    ((uint32_t)0x00002000)            /*!< Bit 1 */
N#define  USART_CR2_LINEN                     ((uint32_t)0x00004000)            /*!< LIN mode enable */
N#define  USART_CR2_SWAP                      ((uint32_t)0x00008000)            /*!< SWAP TX/RX pins */
N#define  USART_CR2_RXINV                     ((uint32_t)0x00010000)            /*!< RX pin active level inversion */
N#define  USART_CR2_TXINV                     ((uint32_t)0x00020000)            /*!< TX pin active level inversion */
N#define  USART_CR2_DATAINV                   ((uint32_t)0x00040000)            /*!< Binary data inversion */
N#define  USART_CR2_MSBFIRST                  ((uint32_t)0x00080000)            /*!< Most Significant Bit First */
N#define  USART_CR2_ABREN                     ((uint32_t)0x00100000)            /*!< Auto Baud-Rate Enable*/
N#define  USART_CR2_ABRMODE                   ((uint32_t)0x00600000)            /*!< ABRMOD[1:0] bits (Auto Baud-Rate Mode) */
N#define  USART_CR2_ABRMODE_0                 ((uint32_t)0x00200000)            /*!< Bit 0 */
N#define  USART_CR2_ABRMODE_1                 ((uint32_t)0x00400000)            /*!< Bit 1 */
N#define  USART_CR2_RTOEN                     ((uint32_t)0x00800000)            /*!< Receiver Time-Out enable */
N#define  USART_CR2_ADD                       ((uint32_t)0xFF000000)            /*!< Address of the USART node */
N
N/******************  Bit definition for USART_CR3 register  *******************/
N#define  USART_CR3_EIE                       ((uint32_t)0x00000001)            /*!< Error Interrupt Enable */
N#define  USART_CR3_IREN                      ((uint32_t)0x00000002)            /*!< IrDA mode Enable */
N#define  USART_CR3_IRLP                      ((uint32_t)0x00000004)            /*!< IrDA Low-Power */
N#define  USART_CR3_HDSEL                     ((uint32_t)0x00000008)            /*!< Half-Duplex Selection */
N#define  USART_CR3_NACK                      ((uint32_t)0x00000010)            /*!< SmartCard NACK enable */
N#define  USART_CR3_SCEN                      ((uint32_t)0x00000020)            /*!< SmartCard mode enable */
N#define  USART_CR3_DMAR                      ((uint32_t)0x00000040)            /*!< DMA Enable Receiver */
N#define  USART_CR3_DMAT                      ((uint32_t)0x00000080)            /*!< DMA Enable Transmitter */
N#define  USART_CR3_RTSE                      ((uint32_t)0x00000100)            /*!< RTS Enable */
N#define  USART_CR3_CTSE                      ((uint32_t)0x00000200)            /*!< CTS Enable */
N#define  USART_CR3_CTSIE                     ((uint32_t)0x00000400)            /*!< CTS Interrupt Enable */
N#define  USART_CR3_ONEBIT                    ((uint32_t)0x00000800)            /*!< One sample bit method enable */
N#define  USART_CR3_OVRDIS                    ((uint32_t)0x00001000)            /*!< Overrun Disable */
N#define  USART_CR3_DDRE                      ((uint32_t)0x00002000)            /*!< DMA Disable on Reception Error */
N#define  USART_CR3_DEM                       ((uint32_t)0x00004000)            /*!< Driver Enable Mode */
N#define  USART_CR3_DEP                       ((uint32_t)0x00008000)            /*!< Driver Enable Polarity Selection */
N#define  USART_CR3_SCARCNT                   ((uint32_t)0x000E0000)            /*!< SCARCNT[2:0] bits (SmartCard Auto-Retry Count) */
N#define  USART_CR3_SCARCNT_0                 ((uint32_t)0x00020000)            /*!< Bit 0 */
N#define  USART_CR3_SCARCNT_1                 ((uint32_t)0x00040000)            /*!< Bit 1 */
N#define  USART_CR3_SCARCNT_2                 ((uint32_t)0x00080000)            /*!< Bit 2 */
N#define  USART_CR3_WUS                       ((uint32_t)0x00300000)            /*!< WUS[1:0] bits (Wake UP Interrupt Flag Selection) */
N#define  USART_CR3_WUS_0                     ((uint32_t)0x00100000)            /*!< Bit 0 */
N#define  USART_CR3_WUS_1                     ((uint32_t)0x00200000)            /*!< Bit 1 */
N#define  USART_CR3_WUFIE                     ((uint32_t)0x00400000)            /*!< Wake Up Interrupt Enable */
N
N/******************  Bit definition for USART_BRR register  *******************/
N#define  USART_BRR_DIV_FRACTION              ((uint16_t)0x000F)                /*!< Fraction of USARTDIV */
N#define  USART_BRR_DIV_MANTISSA              ((uint16_t)0xFFF0)                /*!< Mantissa of USARTDIV */
N
N/******************  Bit definition for USART_GTPR register  ******************/
N#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)                /*!< PSC[7:0] bits (Prescaler value) */
N#define  USART_GTPR_GT                       ((uint16_t)0xFF00)                /*!< GT[7:0] bits (Guard time value) */
N
N
N/*******************  Bit definition for USART_RTOR register  *****************/
N#define  USART_RTOR_RTO                      ((uint32_t)0x00FFFFFF)            /*!< Receiver Time Out Value */
N#define  USART_RTOR_BLEN                     ((uint32_t)0xFF000000)            /*!< Block Length */
N
N/*******************  Bit definition for USART_RQR register  ******************/
N#define  USART_RQR_ABRRQ                     ((uint16_t)0x0001)                /*!< Auto-Baud Rate Request */
N#define  USART_RQR_SBKRQ                     ((uint16_t)0x0002)                /*!< Send Break Request */
N#define  USART_RQR_MMRQ                      ((uint16_t)0x0004)                /*!< Mute Mode Request */
N#define  USART_RQR_RXFRQ                     ((uint16_t)0x0008)                /*!< Receive Data flush Request */
N#define  USART_RQR_TXFRQ                     ((uint16_t)0x0010)                /*!< Transmit data flush Request */
N
N/*******************  Bit definition for USART_ISR register  ******************/
N#define  USART_ISR_PE                        ((uint32_t)0x00000001)            /*!< Parity Error */
N#define  USART_ISR_FE                        ((uint32_t)0x00000002)            /*!< Framing Error */
N#define  USART_ISR_NE                        ((uint32_t)0x00000004)            /*!< Noise detected Flag */
N#define  USART_ISR_ORE                       ((uint32_t)0x00000008)            /*!< OverRun Error */
N#define  USART_ISR_IDLE                      ((uint32_t)0x00000010)            /*!< IDLE line detected */
N#define  USART_ISR_RXNE                      ((uint32_t)0x00000020)            /*!< Read Data Register Not Empty */
N#define  USART_ISR_TC                        ((uint32_t)0x00000040)            /*!< Transmission Complete */
N#define  USART_ISR_TXE                       ((uint32_t)0x00000080)            /*!< Transmit Data Register Empty */
N#define  USART_ISR_LBD                       ((uint32_t)0x00000100)            /*!< LIN Break Detection Flag */
N#define  USART_ISR_CTSIF                     ((uint32_t)0x00000200)            /*!< CTS interrupt flag */
N#define  USART_ISR_CTS                       ((uint32_t)0x00000400)            /*!< CTS flag */
N#define  USART_ISR_RTOF                      ((uint32_t)0x00000800)            /*!< Receiver Time Out */
N#define  USART_ISR_EOBF                      ((uint32_t)0x00001000)            /*!< End Of Block Flag */
N#define  USART_ISR_ABRE                      ((uint32_t)0x00004000)            /*!< Auto-Baud Rate Error */
N#define  USART_ISR_ABRF                      ((uint32_t)0x00008000)            /*!< Auto-Baud Rate Flag */
N#define  USART_ISR_BUSY                      ((uint32_t)0x00010000)            /*!< Busy Flag */
N#define  USART_ISR_CMF                       ((uint32_t)0x00020000)            /*!< Character Match Flag */
N#define  USART_ISR_SBKF                      ((uint32_t)0x00040000)            /*!< Send Break Flag */
N#define  USART_ISR_RWU                       ((uint32_t)0x00080000)            /*!< Receive Wake Up from mute mode Flag */
N#define  USART_ISR_WUF                       ((uint32_t)0x00100000)            /*!< Wake Up from stop mode Flag */
N#define  USART_ISR_TEACK                     ((uint32_t)0x00200000)            /*!< Transmit Enable Acknowledge Flag */
N#define  USART_ISR_REACK                     ((uint32_t)0x00400000)            /*!< Receive Enable Acknowledge Flag */
N
N/*******************  Bit definition for USART_ICR register  ******************/
N#define  USART_ICR_PECF                      ((uint32_t)0x00000001)            /*!< Parity Error Clear Flag */
N#define  USART_ICR_FECF                      ((uint32_t)0x00000002)            /*!< Framing Error Clear Flag */
N#define  USART_ICR_NCF                       ((uint32_t)0x00000004)            /*!< Noise detected Clear Flag */
N#define  USART_ICR_ORECF                     ((uint32_t)0x00000008)            /*!< OverRun Error Clear Flag */
N#define  USART_ICR_IDLECF                    ((uint32_t)0x00000010)            /*!< IDLE line detected Clear Flag */
N#define  USART_ICR_TCCF                      ((uint32_t)0x00000040)            /*!< Transmission Complete Clear Flag */
N#define  USART_ICR_LBDCF                     ((uint32_t)0x00000100)            /*!< LIN Break Detection Clear Flag */
N#define  USART_ICR_CTSCF                     ((uint32_t)0x00000200)            /*!< CTS Interrupt Clear Flag */
N#define  USART_ICR_RTOCF                     ((uint32_t)0x00000800)            /*!< Receiver Time Out Clear Flag */
N#define  USART_ICR_EOBCF                     ((uint32_t)0x00001000)            /*!< End Of Block Clear Flag */
N#define  USART_ICR_CMCF                      ((uint32_t)0x00020000)            /*!< Character Match Clear Flag */
N#define  USART_ICR_WUCF                      ((uint32_t)0x00100000)            /*!< Wake Up from stop mode Clear Flag */
N
N/*******************  Bit definition for USART_RDR register  ******************/
N#define  USART_RDR_RDR                       ((uint16_t)0x01FF)                /*!< RDR[8:0] bits (Receive Data value) */
N
N/*******************  Bit definition for USART_TDR register  ******************/
N#define  USART_TDR_TDR                       ((uint16_t)0x01FF)                /*!< TDR[8:0] bits (Transmit Data value) */
N
N/******************************************************************************/
N/*                                                                            */
N/*                            Window WATCHDOG                                 */
N/*                                                                            */
N/******************************************************************************/
N/*******************  Bit definition for WWDG_CR register  ********************/
N#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
N#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!<Bit 0 */
N#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!<Bit 1 */
N#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!<Bit 2 */
N#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!<Bit 3 */
N#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!<Bit 4 */
N#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!<Bit 5 */
N#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!<Bit 6 */
N
N#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!<Activation bit */
N
N/*******************  Bit definition for WWDG_CFR register  *******************/
N#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!<W[6:0] bits (7-bit window value) */
N#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!<Bit 0 */
N#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!<Bit 1 */
N#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!<Bit 2 */
N#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!<Bit 3 */
N#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!<Bit 4 */
N#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!<Bit 5 */
N#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!<Bit 6 */
N
N#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!<WDGTB[1:0] bits (Timer Base) */
N#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!<Bit 0 */
N#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!<Bit 1 */
N
N#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!<Early Wakeup Interrupt */
N
N/*******************  Bit definition for WWDG_SR register  ********************/
N#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!<Early Wakeup Interrupt Flag */
N
N/**
N  * @}
N  */
N
N /**
N  * @}
N  */
N
N#ifdef USE_STDPERIPH_DRIVER
N  #include "stm32f37x_conf.h"
L 1 "..\inc\stm32f37x_conf.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_conf.h 
N  * @author  MCD Application Team
N  * @version V4.0.0
N  * @date    21-January-2013
N  * @brief   Library configuration file.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2013 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_CONF_H
N#define __STM32F37X_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Comment the line below to disable peripheral header file inclusion */
N#include "stm32f37x_adc.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_adc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_adc.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the ADC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_ADC_H
N#define __STM32F37X_ADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
L 1 "..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include\stm32f37x.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer Header File. 
N  *          This file contains all the peripheral registers definitions, bits 
N  *          definitions and memory mapping for STM32F37x devices.
N  *            
N  *          The file is the unique include file that the application programmer
N  *          is using in the C source code, usually in main.c. This file contains:
N  *           - Configuration section that allows to select:
N  *              - The device used in the target application
N  *              - To use or not the peripheral’s drivers in application code(i.e. 
N  *                code will be based on direct access to peripheral’s registers 
N  *                rather than drivers API), this option is controlled by 
N  *                "#define USE_STDPERIPH_DRIVER"
N  *              - To change few application-specific parameters such as the HSE 
N  *                crystal frequency
N  *           - Data structures and the address mapping for all peripherals
N  *           - Peripheral registers declarations and bits definition
N  *           - Macros to access peripheral registers hardware
N  *  
N  ******************************************************************************
N  * @attention
N  *
N  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
N  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
N  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
N  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
N  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N  *
N  * FOR MORE INFORMATION PLEASE READ CAREFULLY THE LICENSE AGREEMENT FILE
N  * LOCATED IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  ******************************************************************************  
N  */ 
N
N/** @addtogroup CMSIS
N  * @{
N  */
N
N/** @addtogroup stm32f37x
N  * @{
N  */
N    
N#ifndef __STM32F37x_H
S#define __STM32F37x_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif /* __cplusplus */
S  
S/** @addtogroup Library_configuration_section
S  * @{
S  */
S  
S/* Uncomment the line below according to the target STM32 device used in your
S   application 
S  */
S
S#if !defined (STM32F37X) 
S  #define STM32F37X
S#endif
S
S/*  Tip: To avoid modifying this file each time you need to switch between these
S        devices, you can define the device in your toolchain compiler preprocessor.
S  */
S
S#if !defined (STM32F37X)
S #error "Please select first the target STM32F37X device used in your application (in stm32f37x.h file)"
S#endif
S
S#if !defined  (USE_STDPERIPH_DRIVER)
S/**
S * @brief Comment the line below if you will not use the peripherals drivers.
S   In this case, these drivers will not be included and the application code will 
S   be based on direct access to peripherals registers 
S   */
S  /*#define USE_STDPERIPH_DRIVER*/
S#endif /* USE_STDPERIPH_DRIVER */
S
S/**
S * @brief In the following line adjust the value of External High Speed oscillator (HSE)
S   used in your application 
S   
S   Tip: To avoid modifying this file each time you need to use different HSE, you
S        can define the HSE value in your toolchain compiler preprocessor.
S  */           
S#if !defined  (HSE_VALUE) 
S #define HSE_VALUE            ((uint32_t)16000000) /*!< Value of the External oscillator in Hz */
S#endif /* HSE_VALUE */
S/**
S * @brief In the following line adjust the External High Speed oscillator (HSE) Startup 
S   Timeout value 
S   */
S#if !defined  (HSE_STARTUP_TIMEOUT) 
S #define HSE_STARTUP_TIMEOUT  ((uint16_t)0x0500)   /*!< Time out for HSE start up */
S#endif /* HSE_STARTUP_TIMEOUT */
S/**
S * @brief In the following line adjust the Internal High Speed oscillator (HSI) Startup 
S   Timeout value 
S   */
S#define HSI_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSI start up */
S
S#if !defined  (HSI_VALUE) 
S #define HSI_VALUE  ((uint32_t)8000000)
S#endif /* HSI_VALUE */                      /*!< Value of the Internal High Speed oscillator in Hz.
S                                            The real value may vary depending on the variations
S                                             in voltage and temperature.  */
S#if !defined  (LSI_VALUE) 
S #define LSI_VALUE  ((uint32_t)40000)    
S#endif /* LSI_VALUE */                      /*!< Value of the Internal Low Speed oscillator in Hz
S                                             The real value may vary depending on the variations
S                                             in voltage and temperature.  */
S#if !defined  (LSE_VALUE)
S #define LSE_VALUE  ((uint32_t)32768)    /*!< Value of the External Low Speed oscillator in Hz */
S#endif /* LSE_VALUE */     
S
S/**
S * @brief STM32F37x Standard Peripherals Library version number V1.0.0
S   */
S#define __STM32F37X_STDPERIPH_VERSION_MAIN   (0x01) /*!< [31:24] main version */                                  
S#define __STM32F37X_STDPERIPH_VERSION_SUB1   (0x00) /*!< [23:16] sub1 version */
S#define __STM32F37X_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */
S#define __STM32F37X_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */ 
S#define __STM32F37X_STDPERIPH_VERSION       ( (__STM32F37X_STDPERIPH_VERSION_MAIN << 24)\
S                                             |(__STM32F37X_STDPERIPH_VERSION_SUB1 << 16)\
S                                             |(__STM32F37X_STDPERIPH_VERSION_SUB2 << 8)\
S                                             |(__STM32F37X_STDPERIPH_VERSION_RC))
X#define __STM32F37X_STDPERIPH_VERSION       ( (__STM32F37X_STDPERIPH_VERSION_MAIN << 24)                                             |(__STM32F37X_STDPERIPH_VERSION_SUB1 << 16)                                             |(__STM32F37X_STDPERIPH_VERSION_SUB2 << 8)                                             |(__STM32F37X_STDPERIPH_VERSION_RC))
S                                             
S/**
S  * @}
S  */
S
S/** @addtogroup Configuration_section_for_CMSIS
S  * @{
S  */
S
S/**
S * @brief Configuration of the Cortex-M4 Processor and Core Peripherals 
S */
S#define __CM4_REV                 0x0001  /*!< Core revision r0p1                            */
S#define __MPU_PRESENT             1         /*!< STM32F37X provide an MPU */
S#define __NVIC_PRIO_BITS          4         /*!< STM32F37X uses 4 Bits for the Priority Levels */
S#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used */
S#define __FPU_PRESENT             1         /*!< STM32F37X provide an FPU */
S
S
S/**
S * @brief STM32F37X Interrupt Number Definition, according to the selected device 
S *        in @ref Library_configuration_section 
S */
Stypedef enum IRQn
S{
S/******  Cortex-M4 Processor Exceptions Numbers ****************************************************************/
S  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                                          */
S  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M4 Memory Management Interrupt                           */
S  BusFault_IRQn               = -11,    /*!< 5 Cortex-M4 Bus Fault Interrupt                                   */
S  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M4 Usage Fault Interrupt                                 */
S  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M4 SV Call Interrupt                                    */
S  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M4 Debug Monitor Interrupt                              */
S  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M4 Pend SV Interrupt                                    */
S  SysTick_IRQn                = -1,     /*!< 15 Cortex-M4 System Tick Interrupt                                */
S/******  STM32 specific Interrupt Numbers **********************************************************************/
S  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                                         */
S  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt                         */
S  TAMPER_STAMP_IRQn           = 2,      /*!< Tamper and TimeStamp interrupts through the EXTI line 19          */
S  RTC_WKUP_IRQn               = 3,      /*!< RTC Wakeup interrupt through the EXTI line 20                     */
S  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                                            */
S  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                              */
S  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                              */
S  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                              */
S  EXTI2_TS_IRQn               = 8,      /*!< EXTI Line2 Interrupt and Touch Sense Interrupt                    */
S  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                              */
S  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                              */
S  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 Interrupt                                          */
S  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 Interrupt                                          */
S  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 Interrupt                                          */
S  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 Interrupt                                          */
S  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 Interrupt                                          */
S  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 Interrupt                                          */
S  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 Interrupt                                          */
S  ADC1_IRQn                   = 18,     /*!< ADC1 Interrupts                                                   */
S  CAN1_TX_IRQn                = 19,     /*!< CAN1 TX Interrupt                                                  */
S  CAN1_RX0_IRQn               = 20,     /*!< CAN1 RX0 Interrupt                                                 */
S  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                                 */
S  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                                 */
S  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                                     */
S  TIM15_IRQn                  = 24,     /*!< TIM15 global Interrupt                                            */
S  TIM16_IRQn                  = 25,     /*!< TIM16 global Interrupt                                            */
S  TIM17_IRQn                  = 26,     /*!< TIM17 global Interrupt                                            */
S  TIM18_DAC2_IRQn             = 27,     /*!< TIM18 global Interrupt and DAC2 underrun Interrupt                */
S  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                             */
S  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                             */
S  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                             */
S  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                              */
S  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                              */
S  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                              */
S  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                              */  
S  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                             */
S  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                             */
S  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                                           */
S  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                                           */
S  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                                           */
S  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                                   */
S  RTC_Alarm_IRQn              = 41,     /*!< RTC Alarm (A and B) through EXTI Line Interrupt                   */
S  CEC_IRQn                    = 42,     /*!< CEC Interrupt                                                     */    
S  TIM12_IRQn                  = 43,     /*!< TIM12 global interrupt                                            */
S  TIM13_IRQn                  = 44,     /*!< TIM13 global interrupt                                            */
S  TIM14_IRQn                  = 45,     /*!< TIM14 global interrupt                                            */
S  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                             */
S  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                             */
S  TIM6_DAC1_IRQn              = 54,     /*!< TIM6 global and DAC1 Cahnnel1 & Cahnnel2 underrun error Interrupts*/
S  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                             */
S  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                                   */
S  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                                   */
S  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                                   */
S  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                                   */
S  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                                   */
S  SDADC1_IRQn                 = 61,     /*!< ADC Sigma Delta 1 global Interrupt                                */
S  SDADC2_IRQn                 = 62,     /*!< ADC Sigma Delta 2 global Interrupt                                */
S  SDADC3_IRQn                 = 63,     /*!< ADC Sigma Delta 1 global Interrupt                                */
S  COMP_IRQn                   = 64,     /*!< COMP1 and COMP2 global Interrupt                                  */
S  USB_HP_IRQn                 = 74,     /*!< USB High Priority global Interrupt                                */
S  USB_LP_IRQn                 = 75,     /*!< USB Low Priority global Interrupt                                 */
S  USBWakeUp_IRQn              = 76,     /*!< USB Wakeup Interrupt                                              */
S  TIM19_IRQn                  = 78,     /*!< TIM19 global Interrupt                                            */
S  FPU_IRQn                    = 81      /*!< Floating point Interrupt                                          */
S} IRQn_Type;
S
S/**
S  * @}
S  */
S
S#include "core_cm4.h"            /* Cortex-M4 processor and core peripherals */
S#include "system_stm32f37x.h"    /* STM32F37x System Header */
S#include <stdint.h>
S
S/** @addtogroup Exported_types
S  * @{
S  */  
S/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */
Stypedef int32_t  s32;
Stypedef int16_t s16;
Stypedef int8_t  s8;
S
Stypedef const int32_t sc32;  /*!< Read Only */
Stypedef const int16_t sc16;  /*!< Read Only */
Stypedef const int8_t sc8;   /*!< Read Only */
S
Stypedef __IO int32_t  vs32;
Stypedef __IO int16_t  vs16;
Stypedef __IO int8_t   vs8;
S
Stypedef __I int32_t vsc32;  /*!< Read Only */
Stypedef __I int16_t vsc16;  /*!< Read Only */
Stypedef __I int8_t vsc8;   /*!< Read Only */
S
Stypedef uint32_t  u32;
Stypedef uint16_t u16;
Stypedef uint8_t  u8;
S
Stypedef const uint32_t uc32;  /*!< Read Only */
Stypedef const uint16_t uc16;  /*!< Read Only */
Stypedef const uint8_t uc8;   /*!< Read Only */
S
Stypedef __IO uint32_t  vu32;
Stypedef __IO uint16_t vu16;
Stypedef __IO uint8_t  vu8;
S
Stypedef __I uint32_t vuc32;  /*!< Read Only */
Stypedef __I uint16_t vuc16;  /*!< Read Only */
Stypedef __I uint8_t vuc8;   /*!< Read Only */
S
Stypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
S
Stypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
S#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
S
Stypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
S
S/**
S  * @}
S  */
S
S/** @addtogroup Peripheral_registers_structures
S  * @{
S  */   
S
S/** 
S  * @brief Analog to Digital Converter  
S  */
S
Stypedef struct
S{
S  __IO uint32_t SR;    /*!< ADC status register,                         Address offset: 0x00 */
S  __IO uint32_t CR1;   /*!< ADC control register 1,                      Address offset: 0x04 */
S  __IO uint32_t CR2;   /*!< ADC control register 2,                      Address offset: 0x08 */
S  __IO uint32_t SMPR1; /*!< ADC sample time register 1,                  Address offset: 0x0C */
S  __IO uint32_t SMPR2; /*!< ADC sample time register 2,                  Address offset: 0x10 */
S  __IO uint32_t JOFR1; /*!< ADC injected channel data offset register 1, Address offset: 0x14 */
S  __IO uint32_t JOFR2; /*!< ADC injected channel data offset register 2, Address offset: 0x18 */
S  __IO uint32_t JOFR3; /*!< ADC injected channel data offset register 3, Address offset: 0x1C */
S  __IO uint32_t JOFR4; /*!< ADC injected channel data offset register 4, Address offset: 0x20 */
S  __IO uint32_t HTR;   /*!< ADC watchdog higher threshold register,      Address offset: 0x24 */
S  __IO uint32_t LTR;   /*!< ADC watchdog lower threshold register,       Address offset: 0x28 */
S  __IO uint32_t SQR1;  /*!< ADC regular sequence register 1,             Address offset: 0x2C */
S  __IO uint32_t SQR2;  /*!< ADC regular sequence register 2,             Address offset: 0x30 */
S  __IO uint32_t SQR3;  /*!< ADC regular sequence register 3,             Address offset: 0x34 */
S  __IO uint32_t JSQR;  /*!< ADC injected sequence register,              Address offset: 0x38 */
S  __IO uint32_t JDR1;  /*!< ADC injected data register 1,                Address offset: 0x3C */
S  __IO uint32_t JDR2;  /*!< ADC injected data register 2,                Address offset: 0x40 */
S  __IO uint32_t JDR3;  /*!< ADC injected data register 3,                Address offset: 0x44 */
S  __IO uint32_t JDR4;  /*!< ADC injected data register 4,                Address offset: 0x48 */
S  __IO uint32_t DR;    /*!< ADC regular data register,                   Address offset: 0x4C */
S} ADC_TypeDef;
S  
S
S/** 
S  * @brief Controller Area Network TxMailBox 
S  */
Stypedef struct
S{
S  __IO uint32_t TIR;  /*!< CAN TX mailbox identifier register */
S  __IO uint32_t TDTR; /*!< CAN mailbox data length control and time stamp register */
S  __IO uint32_t TDLR; /*!< CAN mailbox data low register */
S  __IO uint32_t TDHR; /*!< CAN mailbox data high register */
S} CAN_TxMailBox_TypeDef;
S
S/** 
S  * @brief Controller Area Network FIFOMailBox 
S  */
Stypedef struct
S{
S  __IO uint32_t RIR;  /*!< CAN receive FIFO mailbox identifier register */
S  __IO uint32_t RDTR; /*!< CAN receive FIFO mailbox data length control and time stamp register */
S  __IO uint32_t RDLR; /*!< CAN receive FIFO mailbox data low register */
S  __IO uint32_t RDHR; /*!< CAN receive FIFO mailbox data high register */
S} CAN_FIFOMailBox_TypeDef;
S  
S/** 
S  * @brief Controller Area Network FilterRegister 
S  */
Stypedef struct
S{
S  __IO uint32_t FR1; /*!< CAN Filter bank register 1 */
S  __IO uint32_t FR2; /*!< CAN Filter bank register 1 */
S} CAN_FilterRegister_TypeDef;
S
S/** 
S  * @brief Controller Area Network 
S  */
Stypedef struct
S{
S  __IO uint32_t              MCR;                 /*!< CAN master control register,         Address offset: 0x00          */
S  __IO uint32_t              MSR;                 /*!< CAN master status register,          Address offset: 0x04          */
S  __IO uint32_t              TSR;                 /*!< CAN transmit status register,        Address offset: 0x08          */
S  __IO uint32_t              RF0R;                /*!< CAN receive FIFO 0 register,         Address offset: 0x0C          */
S  __IO uint32_t              RF1R;                /*!< CAN receive FIFO 1 register,         Address offset: 0x10          */
S  __IO uint32_t              IER;                 /*!< CAN interrupt enable register,       Address offset: 0x14          */
S  __IO uint32_t              ESR;                 /*!< CAN error status register,           Address offset: 0x18          */
S  __IO uint32_t              BTR;                 /*!< CAN bit timing register,             Address offset: 0x1C          */
S  uint32_t                   RESERVED0[88];       /*!< Reserved, 0x020 - 0x17F                                            */
S  CAN_TxMailBox_TypeDef      sTxMailBox[3];       /*!< CAN Tx MailBox,                      Address offset: 0x180 - 0x1AC */
S  CAN_FIFOMailBox_TypeDef    sFIFOMailBox[2];     /*!< CAN FIFO MailBox,                    Address offset: 0x1B0 - 0x1CC */
S  uint32_t                   RESERVED1[12];       /*!< Reserved, 0x1D0 - 0x1FF                                            */
S  __IO uint32_t              FMR;                 /*!< CAN filter master register,          Address offset: 0x200         */
S  __IO uint32_t              FM1R;                /*!< CAN filter mode register,            Address offset: 0x204         */
S  uint32_t                   RESERVED2;           /*!< Reserved, 0x208                                                    */
S  __IO uint32_t              FS1R;                /*!< CAN filter scale register,           Address offset: 0x20C         */
S  uint32_t                   RESERVED3;           /*!< Reserved, 0x210                                                    */
S  __IO uint32_t              FFA1R;               /*!< CAN filter FIFO assignment register, Address offset: 0x214         */
S  uint32_t                   RESERVED4;           /*!< Reserved, 0x218                                                    */
S  __IO uint32_t              FA1R;                /*!< CAN filter activation register,      Address offset: 0x21C         */
S  uint32_t                   RESERVED5[8];        /*!< Reserved, 0x220-0x23F                                              */
S  CAN_FilterRegister_TypeDef sFilterRegister[28]; /*!< CAN Filter Register,                 Address offset: 0x240-0x31C   */
S} CAN_TypeDef;
S
S/** 
S  * @brief Consumer Electronics Control     
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;           /*!< CEC control register,              Address offset:0x00 */
S  __IO uint32_t CFGR;         /*!< CEC configuration register,        Address offset:0x04 */
S  __IO uint32_t TXDR;         /*!< CEC Tx data register ,             Address offset:0x08 */
S  __IO uint32_t RXDR;         /*!< CEC Rx Data Register,              Address offset:0x0C */
S  __IO uint32_t ISR;          /*!< CEC Interrupt and Status Register, Address offset:0x10 */
S  __IO uint32_t IER;          /*!< CEC interrupt enable register,     Address offset:0x14 */
S}CEC_TypeDef;
S
S/** 
S  * @brief Analog Comparators 
S  */
S
Stypedef struct
S{
S  __IO uint32_t CSR;    /*!< Comparator control Status register, Address offset: 0x00 */
S} COMP_TypeDef;
S
S/** 
S  * @brief CRC calculation unit 
S  */
S
Stypedef struct
S{
S  __IO uint32_t DR;          /*!< CRC Data register,                           Address offset: 0x00 */
S  __IO uint8_t  IDR;         /*!< CRC Independent data register,               Address offset: 0x04 */
S  uint8_t       RESERVED0;   /*!< Reserved,                                                    0x05 */
S  uint16_t      RESERVED1;   /*!< Reserved,                                                    0x06 */
S  __IO uint32_t CR;          /*!< CRC Control register,                        Address offset: 0x08 */
S  uint32_t      RESERVED2;   /*!< Reserved,                                                    0x0C */
S  __IO uint32_t INIT;        /*!< Initial CRC value register,                  Address offset: 0x10 */
S  __IO uint32_t POL;         /*!< CRC polynomial register,                     Address offset: 0x14 */
S} CRC_TypeDef;
S
S/** 
S  * @brief Digital to Analog Converter
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;       /*!< DAC control register,                                    Address offset: 0x00 */
S  __IO uint32_t SWTRIGR;  /*!< DAC software trigger register,                           Address offset: 0x04 */
S  __IO uint32_t DHR12R1;  /*!< DAC channel1 12-bit right-aligned data holding register, Address offset: 0x08 */
S  __IO uint32_t DHR12L1;  /*!< DAC channel1 12-bit left aligned data holding register,  Address offset: 0x0C */
S  __IO uint32_t DHR8R1;   /*!< DAC channel1 8-bit right aligned data holding register,  Address offset: 0x10 */
S  __IO uint32_t DHR12R2;  /*!< DAC channel2 12-bit right aligned data holding register, Address offset: 0x14 */
S  __IO uint32_t DHR12L2;  /*!< DAC channel2 12-bit left aligned data holding register,  Address offset: 0x18 */
S  __IO uint32_t DHR8R2;   /*!< DAC channel2 8-bit right-aligned data holding register,  Address offset: 0x1C */
S  __IO uint32_t DHR12RD;  /*!< Dual DAC 12-bit right-aligned data holding register,     Address offset: 0x20 */
S  __IO uint32_t DHR12LD;  /*!< DUAL DAC 12-bit left aligned data holding register,      Address offset: 0x24 */
S  __IO uint32_t DHR8RD;   /*!< DUAL DAC 8-bit right aligned data holding register,      Address offset: 0x28 */
S  __IO uint32_t DOR1;     /*!< DAC channel1 data output register,                       Address offset: 0x2C */
S  __IO uint32_t DOR2;     /*!< DAC channel2 data output register,                       Address offset: 0x30 */
S  __IO uint32_t SR;       /*!< DAC status register,                                     Address offset: 0x34 */
S} DAC_TypeDef;
S
S/** 
S  * @brief Debug MCU
S  */
S
Stypedef struct
S{
S  __IO uint32_t IDCODE;  /*!< MCU device ID code,               Address offset: 0x00 */
S  __IO uint32_t CR;      /*!< Debug MCU configuration register, Address offset: 0x04 */
S  __IO uint32_t APB1FZ;  /*!< Debug MCU APB1 freeze register,   Address offset: 0x08 */
S  __IO uint32_t APB2FZ;  /*!< Debug MCU APB2 freeze register,   Address offset: 0x0C */
S}DBGMCU_TypeDef;
S
S/** 
S  * @brief DMA Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t CCR;          /*!< DMA channel x configuration register                                           */
S  __IO uint32_t CNDTR;        /*!< DMA channel x number of data register                                          */
S  __IO uint32_t CPAR;         /*!< DMA channel x peripheral address register                                      */
S  __IO uint32_t CMAR;         /*!< DMA channel x memory address register                                          */
S} DMA_Channel_TypeDef;
S
Stypedef struct
S{
S  __IO uint32_t ISR;          /*!< DMA interrupt status register,                            Address offset: 0x00 */
S  __IO uint32_t IFCR;         /*!< DMA interrupt flag clear register,                        Address offset: 0x04 */
S} DMA_TypeDef;
S
S/** 
S  * @brief External Interrupt/Event Controller
S  */
S
Stypedef struct
S{
S  __IO uint32_t IMR;          /*!<EXTI Interrupt mask register,                             Address offset: 0x00 */
S  __IO uint32_t EMR;          /*!<EXTI Event mask register,                                 Address offset: 0x04 */
S  __IO uint32_t RTSR;         /*!<EXTI Rising trigger selection register ,                  Address offset: 0x08 */
S  __IO uint32_t FTSR;         /*!<EXTI Falling trigger selection register,                  Address offset: 0x0C */
S  __IO uint32_t SWIER;        /*!<EXTI Software interrupt event register,                   Address offset: 0x10 */
S  __IO uint32_t PR;           /*!<EXTI Pending register,                                    Address offset: 0x14 */
S}EXTI_TypeDef;
S
S/** 
S  * @brief FLASH Registers
S  */
S
Stypedef struct
S{
S  __IO uint32_t ACR;          /*!< FLASH access control register,              Address offset: 0x00 */
S  __IO uint32_t KEYR;         /*!< FLASH key register,                         Address offset: 0x04 */
S  __IO uint32_t OPTKEYR;      /*!< FLASH option key register,                  Address offset: 0x08 */
S  __IO uint32_t SR;           /*!< FLASH status register,                      Address offset: 0x0C */
S  __IO uint32_t CR;           /*!< FLASH control register,                     Address offset: 0x10 */
S  __IO uint32_t AR;           /*!< FLASH address register,                     Address offset: 0x14 */
S  uint32_t      RESERVED;     /*!< Reserved, 0x18                                                   */
S  __IO uint32_t OBR;          /*!< FLASH Option byte register,                 Address offset: 0x1C */
S  __IO uint32_t WRPR;         /*!< FLASH Write register,                       Address offset: 0x20 */
S  
S} FLASH_TypeDef;
S
S/** 
S  * @brief Option Bytes Registers
S  */
Stypedef struct
S{
S  __IO uint16_t RDP;          /*!<FLASH option byte Read protection,             Address offset: 0x00 */
S  __IO uint16_t USER;         /*!<FLASH option byte user options,                Address offset: 0x02 */
S  uint16_t RESERVED0;         /*!< Reserved,                                                     0x04 */
S  uint16_t RESERVED1;         /*!< Reserved,                                                     0x06 */
S  __IO uint16_t WRP0;         /*!<FLASH option byte write protection 0,          Address offset: 0x08 */
S  __IO uint16_t WRP1;         /*!<FLASH option byte write protection 1,          Address offset: 0x0C */
S  __IO uint16_t WRP2;         /*!<FLASH option byte write protection 2,          Address offset: 0x10 */
S  __IO uint16_t WRP3;         /*!<FLASH option byte write protection 3,          Address offset: 0x12 */
S} OB_TypeDef;
S
S/** 
S  * @brief General Purpose I/O
S  */
S
Stypedef struct
S{
S  __IO uint32_t MODER;        /*!< GPIO port mode register,                                  Address offset: 0x00 */
S  __IO uint16_t OTYPER;       /*!< GPIO port output type register,                           Address offset: 0x04 */
S  uint16_t RESERVED0;         /*!< Reserved,                                                                 0x06 */
S  __IO uint32_t OSPEEDR;      /*!< GPIO port output speed register,                          Address offset: 0x08 */
S  __IO uint32_t PUPDR;        /*!< GPIO port pull-up/pull-down register,                     Address offset: 0x0C */
S  __IO uint16_t IDR;          /*!< GPIO port input data register,                            Address offset: 0x10 */
S  uint16_t RESERVED1;         /*!< Reserved,                                                                 0x12 */
S  __IO uint16_t ODR;          /*!< GPIO port output data register,                           Address offset: 0x14 */
S  uint16_t RESERVED2;         /*!< Reserved,                                                                 0x16 */
S  __IO uint32_t BSRR;         /*!< GPIO port bit set/reset registerBSRR,                     Address offset: 0x18 */
S  __IO uint32_t LCKR;         /*!< GPIO port configuration lock register,                    Address offset: 0x1C */
S  __IO uint32_t AFR[2];       /*!< GPIO alternate function low register,                Address offset: 0x20-0x24 */
S  __IO uint16_t BRR;          /*!< GPIO bit reset register,                                  Address offset: 0x28 */
S  uint16_t RESERVED3;         /*!< Reserved,                                                                 0x2A */
S}GPIO_TypeDef;
S
S/** 
S  * @brief System configuration controller
S  */
S  
Stypedef struct
S{
S  __IO uint32_t CFGR1;       /*!< SYSCFG configuration register 1,                      Address offset: 0x00 */
S       uint32_t RESERVED;    /*!< Reserved,                                                             0x04 */
S  __IO uint32_t EXTICR[4];   /*!< SYSCFG control register,                              Adress offset: 0x14-0x08 */
S  __IO uint32_t CFGR2;       /*!< SYSCFG configuration register 2,                      Address offset: 0x18 */
S} SYSCFG_TypeDef;
S
S/** 
S  * @brief Inter-integrated Circuit Interface
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR1;      /*!< I2C Control register 1,            Address offset: 0x00 */
S  __IO uint32_t CR2;      /*!< I2C Control register 2,            Address offset: 0x04 */  
S  __IO uint32_t OAR1;     /*!< I2C Own address 1 register,        Address offset: 0x08 */
S  __IO uint32_t OAR2;     /*!< I2C Own address 2 register,        Address offset: 0x0C */
S  __IO uint32_t TIMINGR;  /*!< I2C Timing register,               Address offset: 0x10 */
S  __IO uint32_t TIMEOUTR; /*!< I2C Timeout register,              Address offset: 0x14 */
S  __IO uint32_t ISR;      /*!< I2C Interrupt and status register, Address offset: 0x18 */
S  __IO uint32_t ICR;      /*!< I2C Interrupt clear register,      Address offset: 0x1C */
S  __IO uint32_t PECR;     /*!< I2C PEC register,                  Address offset: 0x20 */
S  __IO uint32_t RXDR;     /*!< I2C Receive data register,         Address offset: 0x24 */
S  __IO uint32_t TXDR;     /*!< I2C Transmit data register,        Address offset: 0x28 */  
S}I2C_TypeDef;
S
S/** 
S  * @brief Independent WATCHDOG
S  */
S
Stypedef struct
S{
S  __IO uint32_t KR;   /*!< IWDG Key register,       Address offset: 0x00 */
S  __IO uint32_t PR;   /*!< IWDG Prescaler register, Address offset: 0x04 */
S  __IO uint32_t RLR;  /*!< IWDG Reload register,    Address offset: 0x08 */
S  __IO uint32_t SR;   /*!< IWDG Status register,    Address offset: 0x0C */
S  __IO uint32_t WINR; /*!< IWDG Window register,    Address offset: 0x10 */ 
S} IWDG_TypeDef;
S
S/** 
S  * @brief Power Control
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR;   /*!< PWR power control register,        Address offset: 0x00 */
S  __IO uint32_t CSR;  /*!< PWR power control/status register, Address offset: 0x04 */
S} PWR_TypeDef;
S
S/** 
S  * @brief Reset and Clock Control
S  */
Stypedef struct
S{
S  __IO uint32_t CR;         /*!< RCC clock control register,                                  Address offset: 0x00 */
S  __IO uint32_t CFGR;       /*!< RCC clock configuration register,                            Address offset: 0x04 */
S  __IO uint32_t CIR;        /*!< RCC clock interrupt register,                                Address offset: 0x08 */
S  __IO uint32_t APB2RSTR;   /*!< RCC APB2 peripheral reset register,                          Address offset: 0x0C */
S  __IO uint32_t APB1RSTR;   /*!< RCC APB1 peripheral reset register,                          Address offset: 0x10 */
S  __IO uint32_t AHBENR;     /*!< RCC AHB peripheral clock register,                           Address offset: 0x14 */
S  __IO uint32_t APB2ENR;    /*!< RCC APB2 peripheral clock enable register,                   Address offset: 0x18 */
S  __IO uint32_t APB1ENR;    /*!< RCC APB1 peripheral clock enable register,                   Address offset: 0x1C */
S  __IO uint32_t BDCR;       /*!< RCC Backup domain control register,                          Address offset: 0x20 */ 
S  __IO uint32_t CSR;        /*!< RCC clock control & status register,                         Address offset: 0x24 */
S  __IO uint32_t AHBRSTR;    /*!< RCC AHB peripheral reset register,                           Address offset: 0x28 */
S  __IO uint32_t CFGR2;      /*!< RCC clock configuration register 2,                          Address offset: 0x2C */
S  __IO uint32_t CFGR3;      /*!< RCC clock configuration register 3,                          Address offset: 0x30 */ 
S} RCC_TypeDef;
S
S/** 
S  * @brief Real-Time Clock
S  */
S  
Stypedef struct
S{
S  __IO uint32_t TR;         /*!< RTC time register,                                        Address offset: 0x00 */
S  __IO uint32_t DR;         /*!< RTC date register,                                        Address offset: 0x04 */
S  __IO uint32_t CR;         /*!< RTC control register,                                     Address offset: 0x08 */
S  __IO uint32_t ISR;        /*!< RTC initialization and status register,                   Address offset: 0x0C */
S  __IO uint32_t PRER;       /*!< RTC prescaler register,                                   Address offset: 0x10 */
S  __IO uint32_t WUTR;       /*!< RTC wakeup timer register,                                Address offset: 0x14 */
S  uint32_t RESERVED0;       /*!< Reserved, 0x18                                                                 */
S  __IO uint32_t ALRMAR;     /*!< RTC alarm A register,                                     Address offset: 0x1C */
S  __IO uint32_t ALRMBR;     /*!< RTC alarm B register,                                     Address offset: 0x20 */
S  __IO uint32_t WPR;        /*!< RTC write protection register,                            Address offset: 0x24 */
S  __IO uint32_t SSR;        /*!< RTC sub second register,                                  Address offset: 0x28 */
S  __IO uint32_t SHIFTR;     /*!< RTC shift control register,                               Address offset: 0x2C */
S  __IO uint32_t TSTR;       /*!< RTC time stamp time register,                             Address offset: 0x30 */
S  __IO uint32_t TSDR;       /*!< RTC time stamp date register,                             Address offset: 0x34 */
S  __IO uint32_t TSSSR;      /*!< RTC time-stamp sub second register,                       Address offset: 0x38 */
S  __IO uint32_t CALR;       /*!< RTC calibration register,                                 Address offset: 0x3C */
S  __IO uint32_t TAFCR;      /*!< RTC tamper and alternate function configuration register, Address offset: 0x40 */
S  __IO uint32_t ALRMASSR;   /*!< RTC alarm A sub second register,                          Address offset: 0x44 */
S  __IO uint32_t ALRMBSSR;   /*!< RTC alarm B sub second register,                          Address offset: 0x48 */
S  uint32_t RESERVED7;       /*!< Reserved, 0x4C                                                                 */
S  __IO uint32_t BKP0R;      /*!< RTC backup register 0,                                    Address offset: 0x50 */
S  __IO uint32_t BKP1R;      /*!< RTC backup register 1,                                    Address offset: 0x54 */
S  __IO uint32_t BKP2R;      /*!< RTC backup register 2,                                    Address offset: 0x58 */
S  __IO uint32_t BKP3R;      /*!< RTC backup register 3,                                    Address offset: 0x5C */
S  __IO uint32_t BKP4R;      /*!< RTC backup register 4,                                    Address offset: 0x60 */
S  __IO uint32_t BKP5R;      /*!< RTC backup register 5,                                    Address offset: 0x64 */
S  __IO uint32_t BKP6R;      /*!< RTC backup register 6,                                    Address offset: 0x68 */
S  __IO uint32_t BKP7R;      /*!< RTC backup register 7,                                    Address offset: 0x6C */
S  __IO uint32_t BKP8R;      /*!< RTC backup register 8,                                    Address offset: 0x70 */
S  __IO uint32_t BKP9R;      /*!< RTC backup register 9,                                    Address offset: 0x74 */
S  __IO uint32_t BKP10R;     /*!< RTC backup register 10,                                   Address offset: 0x78 */
S  __IO uint32_t BKP11R;     /*!< RTC backup register 11,                                   Address offset: 0x7C */
S  __IO uint32_t BKP12R;     /*!< RTC backup register 12,                                   Address offset: 0x80 */
S  __IO uint32_t BKP13R;     /*!< RTC backup register 13,                                   Address offset: 0x84 */
S  __IO uint32_t BKP14R;     /*!< RTC backup register 14,                                   Address offset: 0x88 */
S  __IO uint32_t BKP15R;     /*!< RTC backup register 15,                                   Address offset: 0x8C */
S  __IO uint32_t BKP16R;     /*!< RTC backup register 16,                                   Address offset: 0x90 */
S  __IO uint32_t BKP17R;     /*!< RTC backup register 17,                                   Address offset: 0x94 */
S  __IO uint32_t BKP18R;     /*!< RTC backup register 18,                                   Address offset: 0x98 */
S  __IO uint32_t BKP19R;     /*!< RTC backup register 19,                                   Address offset: 0x9C */
S  __IO uint32_t BKP20R;     /*!< RTC backup register 20,                                   Address offset: 0xA0 */
S  __IO uint32_t BKP21R;     /*!< RTC backup register 21,                                   Address offset: 0xA4 */
S  __IO uint32_t BKP22R;     /*!< RTC backup register 22,                                   Address offset: 0xA8 */
S  __IO uint32_t BKP23R;     /*!< RTC backup register 23,                                   Address offset: 0xAC */
S  __IO uint32_t BKP24R;     /*!< RTC backup register 24,                                   Address offset: 0xB0 */
S  __IO uint32_t BKP25R;     /*!< RTC backup register 25,                                   Address offset: 0xB4 */
S  __IO uint32_t BKP26R;     /*!< RTC backup register 26,                                   Address offset: 0xB8 */
S  __IO uint32_t BKP27R;     /*!< RTC backup register 27,                                   Address offset: 0xBC */
S  __IO uint32_t BKP28R;     /*!< RTC backup register 28,                                   Address offset: 0xC0 */
S  __IO uint32_t BKP29R;     /*!< RTC backup register 29,                                   Address offset: 0xC4 */
S  __IO uint32_t BKP30R;     /*!< RTC backup register 30,                                   Address offset: 0xC8 */
S  __IO uint32_t BKP31R;     /*!< RTC backup register 31,                                   Address offset: 0xCC */
S} RTC_TypeDef;
S
S
S/** 
S  * @brief Sigma-Delta Analog to Digital Converter (SDADC)  
S  */
S
Stypedef struct
S{
S  __IO uint32_t CR1;          /*!< SDADC control register 1,                        Address offset: 0x00 */
S  __IO uint32_t CR2;          /*!< SDADC control register 2,                        Address offset: 0x04 */
S  __IO uint32_t ISR;          /*!< SDADC interrupt and status register,             Address offset: 0x08 */
S  __IO uint32_t CLRISR;       /*!< SDADC clear interrupt and status register,       Address offset: 0x0C */
S  __IO uint32_t RESERVED0;    /*!< Reserved, 0x10                                                        */
S  __IO uint32_t JCHGR;        /*!< SDADC injected channel group selection register, Address offset: 0x14 */
S  __IO uint32_t RESERVED1;    /*!< Reserved, 0x18                                                        */
S  __IO uint32_t RESERVED2;    /*!< Reserved, 0x1C                                                        */
S  __IO uint32_t CONF0R;       /*!< SDADC configuration 0 register,                  Address offset: 0x20 */
S  __IO uint32_t CONF1R;       /*!< SDADC configuration 1 register,                  Address offset: 0x24 */
S  __IO uint32_t CONF2R;       /*!< SDADC configuration 2 register,                  Address offset: 0x28 */
S  __IO uint32_t RESERVED3[5]; /*!< Reserved, 0x2C - 0x3C                                                 */
S  __IO uint32_t CONFCHR1;     /*!< SDADC channel configuration register 1,          Address offset: 0x40 */
S  __IO uint32_t CONFCHR2;     /*!< SDADC channel configuration register 2,          Address offset: 0x44 */
S  __IO uint32_t RESERVED4[6]; /*!< Reserved, 0x48 - 0x5C                                                 */
S  __IO uint32_t JDATAR;       /*!< SDADC data register for injected group,          Address offset: 0x60 */
S  __IO uint32_t RDATAR;       /*!< SDADC data register for the regular channel,     Address offset: 0x64 */
S  __IO uint32_t RESERVED5[2]; /*!< Reserved, 0x68 - 0x6C                                                 */
S  __IO uint32_t JDATA12R;     /*!< SDADC1 and SDADC2 injected data register,        Address offset: 0x70 */
S  __IO uint32_t RDATA12R;     /*!< SDADC1 and SDADC2 regular data register,         Address offset: 0x74 */
S  __IO uint32_t JDATA13R;     /*!< SDADC1 and SDADC3 injected data register,        Address offset: 0x78 */
S  __IO uint32_t RDATA13R;     /*!< SDADC1 and SDADC3 regular data register,         Address offset: 0x7C */
S} SDADC_TypeDef;
S
S/** 
S  * @brief Serial Peripheral Interface
S  */
S  
Stypedef struct
S{
S  __IO uint16_t CR1;      /*!< SPI Control register 1 (not used in I2S mode),       Address offset: 0x00 */
S  uint16_t  RESERVED0;    /*!< Reserved, 0x02                                                            */
S  __IO uint16_t CR2;      /*!< SPI Control register 2,                              Address offset: 0x04 */
S  uint16_t  RESERVED1;    /*!< Reserved, 0x06                                                            */
S  __IO uint16_t SR;       /*!< SPI Status register,                                 Address offset: 0x08 */
S  uint16_t  RESERVED2;    /*!< Reserved, 0x0A                                                            */
S  __IO uint16_t DR;       /*!< SPI data register,                                   Address offset: 0x0C */
S  uint16_t  RESERVED3;    /*!< Reserved, 0x0E                                                            */
S  __IO uint16_t CRCPR;    /*!< SPI CRC polynomial register (not used in I2S mode),  Address offset: 0x10 */
S  uint16_t  RESERVED4;    /*!< Reserved, 0x12                                                            */
S  __IO uint16_t RXCRCR;   /*!< SPI Rx CRC register (not used in I2S mode),          Address offset: 0x14 */
S  uint16_t  RESERVED5;    /*!< Reserved, 0x16                                                            */
S  __IO uint16_t TXCRCR;   /*!< SPI Tx CRC register (not used in I2S mode),          Address offset: 0x18 */
S  uint16_t  RESERVED6;    /*!< Reserved, 0x1A                                                            */ 
S  __IO uint16_t I2SCFGR;  /*!< SPI_I2S configuration register,                      Address offset: 0x1C */
S  uint16_t  RESERVED7;    /*!< Reserved, 0x1E                                                            */
S  __IO uint16_t I2SPR;    /*!< SPI_I2S prescaler register,                          Address offset: 0x20 */
S  uint16_t  RESERVED8;    /*!< Reserved, 0x22                                                            */    
S} SPI_TypeDef;
S
S
S/** 
S  * @brief TIM
S  */
Stypedef struct
S{
S  __IO uint16_t CR1;         /*!< TIM control register 1,              Address offset: 0x00 */
S  uint16_t      RESERVED0;   /*!< Reserved, 0x02                                            */
S  __IO uint16_t CR2;         /*!< TIM control register 2,              Address offset: 0x04 */
S  uint16_t      RESERVED1;   /*!< Reserved, 0x06                                            */
S  __IO uint16_t SMCR;        /*!< TIM slave mode control register,     Address offset: 0x08 */
S  uint16_t      RESERVED2;   /*!< Reserved, 0x0A                                            */
S  __IO uint16_t DIER;        /*!< TIM DMA/interrupt enable register,   Address offset: 0x0C */
S  uint16_t      RESERVED3;   /*!< Reserved, 0x0E                                            */
S  __IO uint16_t SR;          /*!< TIM status register,                 Address offset: 0x10 */
S  uint16_t      RESERVED4;   /*!< Reserved, 0x12                                            */
S  __IO uint16_t EGR;         /*!< TIM event generation register,       Address offset: 0x14 */
S  uint16_t      RESERVED5;   /*!< Reserved, 0x16                                            */
S  __IO uint16_t CCMR1;       /*!< TIM capture/compare mode register 1, Address offset: 0x18 */
S  uint16_t      RESERVED6;   /*!< Reserved, 0x1A                                            */
S  __IO uint16_t CCMR2;       /*!< TIM capture/compare mode register 2, Address offset: 0x1C */
S  uint16_t      RESERVED7;   /*!< Reserved, 0x1E                                            */
S  __IO uint16_t CCER;        /*!< TIM capture/compare enable register, Address offset: 0x20 */
S  uint16_t      RESERVED8;   /*!< Reserved, 0x22                                            */
S  __IO uint32_t CNT;         /*!< TIM counter register,                Address offset: 0x24 */
S  __IO uint16_t PSC;         /*!< TIM prescaler,                       Address offset: 0x28 */
S  uint16_t      RESERVED9;   /*!< Reserved, 0x2A                                            */
S  __IO uint32_t ARR;         /*!< TIM auto-reload register,            Address offset: 0x2C */
S  __IO uint16_t RCR;         /*!< TIM repetition counter register,     Address offset: 0x30 */
S  uint16_t      RESERVED10;  /*!< Reserved, 0x32                                            */
S  __IO uint32_t CCR1;        /*!< TIM capture/compare register 1,      Address offset: 0x34 */
S  __IO uint32_t CCR2;        /*!< TIM capture/compare register 2,      Address offset: 0x38 */
S  __IO uint32_t CCR3;        /*!< TIM capture/compare register 3,      Address offset: 0x3C */
S  __IO uint32_t CCR4;        /*!< TIM capture/compare register 4,      Address offset: 0x40 */
S  __IO uint16_t BDTR;        /*!< TIM break and dead-time register,    Address offset: 0x44 */
S  uint16_t      RESERVED11;  /*!< Reserved, 0x46                                            */
S  __IO uint16_t DCR;         /*!< TIM DMA control register,            Address offset: 0x48 */
S  uint16_t      RESERVED12;  /*!< Reserved, 0x4A                                            */
S  __IO uint16_t DMAR;        /*!< TIM DMA address for full transfer,   Address offset: 0x4C */
S  uint16_t      RESERVED13;  /*!< Reserved, 0x4E                                            */
S  __IO uint16_t OR;          /*!< TIM option register,                 Address offset: 0x50 */
S  uint16_t      RESERVED14;  /*!< Reserved, 0x52                                            */
S} TIM_TypeDef;
S
S/** 
S  * @brief Touch Sensing Controller (TSC)
S  */
Stypedef struct
S{
S  __IO uint32_t CR;            /*!< TSC control register,                                     Address offset: 0x00 */
S  __IO uint32_t IER;           /*!< TSC interrupt enable register,                            Address offset: 0x04 */
S  __IO uint32_t ICR;           /*!< TSC interrupt clear register,                             Address offset: 0x08 */
S  __IO uint32_t ISR;           /*!< TSC interrupt status register,                            Address offset: 0x0C */
S  __IO uint32_t IOHCR;         /*!< TSC I/O hysteresis control register,                      Address offset: 0x10 */
S  uint32_t      RESERVED1;     /*!< Reserved,                                                 Address offset: 0x14 */
S  __IO uint32_t IOASCR;        /*!< TSC I/O analog switch control register,                   Address offset: 0x18 */
S  uint32_t      RESERVED2;     /*!< Reserved,                                                 Address offset: 0x1C */
S  __IO uint32_t IOSCR;         /*!< TSC I/O sampling control register,                        Address offset: 0x20 */
S  uint32_t      RESERVED3;     /*!< Reserved,                                                 Address offset: 0x24 */
S  __IO uint32_t IOCCR;         /*!< TSC I/O channel control register,                         Address offset: 0x28 */
S  uint32_t      RESERVED4;     /*!< Reserved,                                                 Address offset: 0x2C */
S  __IO uint32_t IOGCSR;        /*!< TSC I/O group control status register,                    Address offset: 0x30 */
S  __IO uint32_t IOGXCR[8];     /*!< TSC I/O group x counter register,                         Address offset: 0x34-50 */
S} TSC_TypeDef;
S/** 
S  * @brief Universal Synchronous Asynchronous Receiver Transmitter
S  */
S  
Stypedef struct
S{
S  __IO uint32_t CR1;    /*!< USART Control register 1,                 Address offset: 0x00 */ 
S  __IO uint32_t CR2;    /*!< USART Control register 2,                 Address offset: 0x04 */ 
S  __IO uint32_t CR3;    /*!< USART Control register 3,                 Address offset: 0x08 */
S  __IO uint16_t BRR;    /*!< USART Baud rate register,                 Address offset: 0x0C */
S  uint16_t  RESERVED1;  /*!< Reserved, 0x0E                                                 */  
S  __IO uint16_t GTPR;   /*!< USART Guard time and prescaler register,  Address offset: 0x10 */
S  uint16_t  RESERVED2;  /*!< Reserved, 0x12                                                 */
S  __IO uint32_t RTOR;   /*!< USART Receiver Time Out register,         Address offset: 0x14 */  
S  __IO uint16_t RQR;    /*!< USART Request register,                   Address offset: 0x18 */
S  uint16_t  RESERVED3;  /*!< Reserved, 0x1A                                                 */
S  __IO uint32_t ISR;    /*!< USART Interrupt and status register,      Address offset: 0x1C */
S  __IO uint32_t ICR;    /*!< USART Interrupt flag Clear register,      Address offset: 0x20 */
S  __IO uint16_t RDR;    /*!< USART Receive Data register,              Address offset: 0x24 */
S  uint16_t  RESERVED4;  /*!< Reserved, 0x26                                                 */
S  __IO uint16_t TDR;    /*!< USART Transmit Data register,             Address offset: 0x28 */
S  uint16_t  RESERVED5;  /*!< Reserved, 0x2A                                                 */
S} USART_TypeDef; 
S
S/** 
S  * @brief Window WATCHDOG
S  */
Stypedef struct
S{
S  __IO uint32_t CR;   /*!< WWDG Control register,       Address offset: 0x00 */
S  __IO uint32_t CFR;  /*!< WWDG Configuration register, Address offset: 0x04 */
S  __IO uint32_t SR;   /*!< WWDG Status register,        Address offset: 0x08 */
S} WWDG_TypeDef;
S
S  
S/** @addtogroup Peripheral_memory_map
S  * @{
S  */
S
S#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */
S#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */
S#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */
S
S#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */
S#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */
S
S
S/*!< Peripheral memory map */
S#define APB1PERIPH_BASE       PERIPH_BASE
S#define APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000)
S#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)
S#define AHB2PERIPH_BASE       (PERIPH_BASE + 0x08000000)
S
S/*!< APB1 peripherals */
S#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
S#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
S#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
S#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
S#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
S#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
S#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)
S#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)
S#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)
S#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
S#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
S#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
S#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
S#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
S#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
S#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
S#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
S#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
S#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)
S#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
S#define DAC1_BASE             (APB1PERIPH_BASE + 0x7400)
S#define CEC_BASE              (APB1PERIPH_BASE + 0x7800)
S#define DAC2_BASE             (APB1PERIPH_BASE + 0x9800)
S#define TIM18_BASE            (APB1PERIPH_BASE + 0x9C00)
S
S/*!< APB2 peripherals */
S#define SYSCFG_BASE           (APB2PERIPH_BASE + 0x0000)
S#define COMP_BASE             (APB2PERIPH_BASE + 0x001C)
S#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
S#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
S#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
S#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
S#define TIM15_BASE            (APB2PERIPH_BASE + 0x4000)
S#define TIM16_BASE            (APB2PERIPH_BASE + 0x4400)
S#define TIM17_BASE            (APB2PERIPH_BASE + 0x4800)
S#define TIM19_BASE            (APB2PERIPH_BASE + 0x5C00)
S#define SDADC1_BASE           (APB2PERIPH_BASE + 0x6000)
S#define SDADC2_BASE           (APB2PERIPH_BASE + 0x6400)
S#define SDADC3_BASE           (APB2PERIPH_BASE + 0x6800)
S
S/*!< AHB1 peripherals */
S#define DMA1_BASE             (AHB1PERIPH_BASE + 0x0000)
S#define DMA1_Channel1_BASE    (AHB1PERIPH_BASE + 0x0008)
S#define DMA1_Channel2_BASE    (AHB1PERIPH_BASE + 0x001C)
S#define DMA1_Channel3_BASE    (AHB1PERIPH_BASE + 0x0030)
S#define DMA1_Channel4_BASE    (AHB1PERIPH_BASE + 0x0044)
S#define DMA1_Channel5_BASE    (AHB1PERIPH_BASE + 0x0058)
S#define DMA1_Channel6_BASE    (AHB1PERIPH_BASE + 0x006C)
S#define DMA1_Channel7_BASE    (AHB1PERIPH_BASE + 0x0080)
S#define DMA2_BASE             (AHB1PERIPH_BASE + 0x0400)
S#define DMA2_Channel1_BASE    (AHB1PERIPH_BASE + 0x0408)
S#define DMA2_Channel2_BASE    (AHB1PERIPH_BASE + 0x041C)
S#define DMA2_Channel3_BASE    (AHB1PERIPH_BASE + 0x0430)
S#define DMA2_Channel4_BASE    (AHB1PERIPH_BASE + 0x0444)
S#define DMA2_Channel5_BASE    (AHB1PERIPH_BASE + 0x0458)
S#define RCC_BASE              (AHB1PERIPH_BASE + 0x1000)
S#define FLASH_R_BASE          (AHB1PERIPH_BASE + 0x2000) /*!< Flash registers base address */
S#define OB_BASE               ((uint32_t)0x1FFFF800)     /*!< Flash Option Bytes base address */
S#define CRC_BASE              (AHB1PERIPH_BASE + 0x3000)
S#define TSC_BASE              (AHB1PERIPH_BASE + 0x00004000)
S
S/*!< AHB2 peripherals */
S#define GPIOA_BASE            (AHB2PERIPH_BASE + 0x0000)
S#define GPIOB_BASE            (AHB2PERIPH_BASE + 0x0400)
S#define GPIOC_BASE            (AHB2PERIPH_BASE + 0x0800)
S#define GPIOD_BASE            (AHB2PERIPH_BASE + 0x0C00)
S#define GPIOE_BASE            (AHB2PERIPH_BASE + 0x1000)
S#define GPIOF_BASE            (AHB2PERIPH_BASE + 0x1400)
S
S#define DBGMCU_BASE          ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */
S/**
S  * @}
S  */
S
S/** @addtogroup Peripheral_declaration
S  * @{
S  */
S#define TIM2                ((TIM_TypeDef *) TIM2_BASE)
S#define TIM3                ((TIM_TypeDef *) TIM3_BASE)
S#define TIM4                ((TIM_TypeDef *) TIM4_BASE)
S#define TIM5                ((TIM_TypeDef *) TIM5_BASE)
S#define TIM6                ((TIM_TypeDef *) TIM6_BASE)
S#define TIM7                ((TIM_TypeDef *) TIM7_BASE)
S#define TIM12               ((TIM_TypeDef *) TIM12_BASE)
S#define TIM13               ((TIM_TypeDef *) TIM13_BASE)
S#define TIM14               ((TIM_TypeDef *) TIM14_BASE)
S#define RTC                 ((RTC_TypeDef *) RTC_BASE)
S#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
S#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
S#define SPI2                ((SPI_TypeDef *) SPI2_BASE)
S#define SPI3                ((SPI_TypeDef *) SPI3_BASE)
S#define USART2              ((USART_TypeDef *) USART2_BASE)
S#define USART3              ((USART_TypeDef *) USART3_BASE)
S#define I2C1                ((I2C_TypeDef *) I2C1_BASE)
S#define I2C2                ((I2C_TypeDef *) I2C2_BASE)
S#define CAN1                ((CAN_TypeDef *) CAN1_BASE)
S#define PWR                 ((PWR_TypeDef *) PWR_BASE)
S#define DAC1                ((DAC_TypeDef *) DAC1_BASE)
S#define DAC2                ((DAC_TypeDef *) DAC2_BASE)
S#define CEC                 ((CEC_TypeDef *) CEC_BASE)
S#define COMP                ((COMP_TypeDef *) COMP_BASE)
S#define TIM18               ((TIM_TypeDef *) TIM18_BASE)
S#define SYSCFG              ((SYSCFG_TypeDef *) SYSCFG_BASE)
S#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
S#define ADC1                ((ADC_TypeDef *) ADC1_BASE)
S#define SPI1                ((SPI_TypeDef *) SPI1_BASE)
S#define USART1              ((USART_TypeDef *) USART1_BASE)
S#define TIM15               ((TIM_TypeDef *) TIM15_BASE)
S#define TIM16               ((TIM_TypeDef *) TIM16_BASE)
S#define TIM17               ((TIM_TypeDef *) TIM17_BASE)
S#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
S#define TIM19               ((TIM_TypeDef *) TIM19_BASE)
S#define SDADC1              ((SDADC_TypeDef *) SDADC1_BASE)
S#define SDADC2              ((SDADC_TypeDef *) SDADC2_BASE)
S#define SDADC3              ((SDADC_TypeDef *) SDADC3_BASE)
S#define DMA1                ((DMA_TypeDef *) DMA1_BASE)
S#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
S#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
S#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
S#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
S#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
S#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
S#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
S#define DMA2                ((DMA_TypeDef *) DMA2_BASE)
S#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
S#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
S#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
S#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
S#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
S#define RCC                 ((RCC_TypeDef *) RCC_BASE)
S#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
S#define OB                  ((OB_TypeDef *) OB_BASE)
S#define CRC                 ((CRC_TypeDef *) CRC_BASE)
S#define TSC                 ((TSC_TypeDef *) TSC_BASE)
S#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
S#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
S#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
S#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
S#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
S#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
S
S/**
S  * @}
S  */
S
S/** @addtogroup Exported_constants
S  * @{
S  */
S
S  /** @addtogroup Peripheral_Registers_Bits_Definition
S  * @{
S  */
S
S/******************************************************************************/
S/*                         Peripheral Registers_Bits_Definition               */
S/******************************************************************************/
S
S/******************************************************************************/
S/*                                                                            */
S/*                        Analog to Digital Converter SAR (ADC)               */
S/*                                                                            */
S/******************************************************************************/
S
S/********************  Bit definition for ADC_SR register  ********************/
S#define  ADC_SR_AWD                          ((uint32_t)0x00000001)  /*!< Analog watchdog flag */
S#define  ADC_SR_EOC                          ((uint32_t)0x00000002)  /*!< End of conversion */
S#define  ADC_SR_JEOC                         ((uint32_t)0x00000004)  /*!< Injected channel end of conversion */
S#define  ADC_SR_JSTRT                        ((uint32_t)0x00000008)  /*!< Injected channel Start flag */
S#define  ADC_SR_STRT                         ((uint32_t)0x00000010)  /*!< Regular channel Start flag */
S
S/*******************  Bit definition for ADC_CR1 register  ********************/
S#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)  /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */
S#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)  /*!< Bit 0 */
S#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)  /*!< Bit 1 */
S#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)  /*!< Bit 2 */
S#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)  /*!< Bit 3 */
S#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)  /*!< Bit 4 */
S#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)  /*!< Interrupt enable for EOC */
S#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)  /*!< Analog Watchdog interrupt enable */
S#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)  /*!< Interrupt enable for injected channels */
S#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)  /*!< Scan mode */
S#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)  /*!< Enable the watchdog on a single channel in scan mode */
S#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)  /*!< Automatic injected group conversion */
S#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)  /*!< Discontinuous mode on regular channels */
S#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)  /*!< Discontinuous mode on injected channels */
S#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)  /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */
S#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)  /*!< Bit 0 */
S#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)  /*!< Bit 1 */
S#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)  /*!< Bit 2 */
S#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)  /*!< Analog watchdog enable on injected channels */
S#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)  /*!< Analog watchdog enable on regular channels */
S
S/*******************  Bit definition for ADC_CR2 register  ********************/
S#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)  /*!< A/D Converter ON / OFF */
S#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)  /*!< Continuous Conversion */
S#define  ADC_CR2_CAL                         ((uint32_t)0x00000004)  /*!< A/D Calibration */
S#define  ADC_CR2_RSTCAL                      ((uint32_t)0x00000008)  /*!< Reset Calibration */
S#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)  /*!< Direct Memory access mode */
S#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)  /*!< Data Alignment */
S#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x00007000)  /*!< JEXTSEL[2:0] bits (External event select for injected group) */
S#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00001000)  /*!< Bit 0 */
S#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00002000)  /*!< Bit 1 */
S#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00004000)  /*!< Bit 2 */
S#define  ADC_CR2_JEXTTRIG                    ((uint32_t)0x00008000)  /*!< External Trigger Conversion mode for injected channels */
S#define  ADC_CR2_EXTSEL                      ((uint32_t)0x000E0000)  /*!< EXTSEL[2:0] bits (External Event Select for regular group) */
S#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x00020000)  /*!< Bit 0 */
S#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x00040000)  /*!< Bit 1 */
S#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x00080000)  /*!< Bit 2 */
S#define  ADC_CR2_EXTTRIG                     ((uint32_t)0x00100000)  /*!< External Trigger Conversion mode for regular channels */
S#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00200000)  /*!< Start Conversion of injected channels */
S#define  ADC_CR2_SWSTART                     ((uint32_t)0x00400000)  /*!< Start Conversion of regular channels */
S#define  ADC_CR2_TSVREFE                     ((uint32_t)0x00800000)  /*!< Temperature Sensor and VREFINT Enable */
S
S/******************  Bit definition for ADC_SMPR1 register  *******************/
S#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)  /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */
S#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)  /*!< Bit 0 */
S#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)  /*!< Bit 1 */
S#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)  /*!< Bit 2 */
S#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)  /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */
S#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)  /*!< Bit 0 */
S#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)  /*!< Bit 1 */
S#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)  /*!< Bit 2 */
S#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)  /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */
S#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)  /*!< Bit 0 */
S#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)  /*!< Bit 1 */
S#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)  /*!< Bit 2 */
S#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)  /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */
S#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)  /*!< Bit 0 */
S#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)  /*!< Bit 1 */
S#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)  /*!< Bit 2 */
S#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)  /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */
S#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)  /*!< Bit 0 */
S#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)  /*!< Bit 1 */
S#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)  /*!< Bit 2 */
S#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)  /*!< SMP15[2:0] bits (Channel 15 Sample time selection) */
S#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */
S#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */
S#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */
S#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */
S#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */
S#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */
S
S/******************  Bit definition for ADC_SMPR2 register  *******************/
S#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */
S#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */
S#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */
S#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */
S#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */
S#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */
S#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */
S#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */
S#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */
S#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */
S#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */
S#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */
S#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */
S
S/******************  Bit definition for ADC_JOFR1 register  *******************/
S#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 1 */
S
S/******************  Bit definition for ADC_JOFR2 register  *******************/
S#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 2 */
S
S/******************  Bit definition for ADC_JOFR3 register  *******************/
S#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 3 */
S
S/******************  Bit definition for ADC_JOFR4 register  *******************/
S#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 4 */
S
S/*******************  Bit definition for ADC_HTR register  ********************/
S#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog high threshold */
S
S/*******************  Bit definition for ADC_LTR register  ********************/
S#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog low threshold */
S
S/*******************  Bit definition for ADC_SQR1 register  *******************/
S#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */
S#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */
S#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
S#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */
S#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
S#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */
S#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */
S#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */
S
S/*******************  Bit definition for ADC_SQR2 register  *******************/
S#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */
S#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */
S#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
S#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */
S#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
S#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */
S#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */
S#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */
S#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */
S#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */
S#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */
S#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */
S#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */
S
S/*******************  Bit definition for ADC_SQR3 register  *******************/
S#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */
S#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */
S#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */
S#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */
S#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */
S#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */
S#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */
S#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */
S#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */
S#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */
S#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */
S#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */
S#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */
S#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */
S#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */
S
S/*******************  Bit definition for ADC_JSQR register  *******************/
S#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */  
S#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */
S#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */
S#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */
S#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */
S#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */
S#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */
S#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */
S#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */
S#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */
S#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */
S#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */
S#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */
S#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */
S#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */
S
S/*******************  Bit definition for ADC_JDR1 register  *******************/
S#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR2 register  *******************/
S#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR3 register  *******************/
S#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
S
S/*******************  Bit definition for ADC_JDR4 register  *******************/
S#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */
S
S/********************  Bit definition for ADC_DR register  ********************/
S#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */
S
S/******************************************************************************/
S/*                                                                            */
S/*                      Analog Comparators (COMP)                             */
S/*                                                                            */
S/******************************************************************************/
S
S/***********************  Bit definition for COMP_CSR register  ***************/
S/* COMP1 bits definition */
S#define COMP_CSR_COMP1EN               ((uint32_t)0x00000001) /*!< COMP1 enable */
S#define COMP_CSR_COMP1SW1              ((uint32_t)0x00000002) /*!< SW1 switch control */
S#define COMP_CSR_COMP1MODE             ((uint32_t)0x0000000C) /*!< COMP1 power mode */
S#define COMP_CSR_COMP1MODE_0           ((uint32_t)0x00000004) /*!< COMP1 power mode bit 0 */
S#define COMP_CSR_COMP1MODE_1           ((uint32_t)0x00000008) /*!< COMP1 power mode bit 1 */
S#define COMP_CSR_COMP1INSEL            ((uint32_t)0x00000070) /*!< COMP1 inverting input select */
S#define COMP_CSR_COMP1INSEL_0          ((uint32_t)0x00000010) /*!< COMP1 inverting input select bit 0 */
S#define COMP_CSR_COMP1INSEL_1          ((uint32_t)0x00000020) /*!< COMP1 inverting input select bit 1 */
S#define COMP_CSR_COMP1INSEL_2          ((uint32_t)0x00000040) /*!< COMP1 inverting input select bit 2 */
S#define COMP_CSR_COMP1OUTSEL           ((uint32_t)0x00000700) /*!< COMP1 output select */
S#define COMP_CSR_COMP1OUTSEL_0         ((uint32_t)0x00000100) /*!< COMP1 output select bit 0 */
S#define COMP_CSR_COMP1OUTSEL_1         ((uint32_t)0x00000200) /*!< COMP1 output select bit 1 */
S#define COMP_CSR_COMP1OUTSEL_2         ((uint32_t)0x00000400) /*!< COMP1 output select bit 2 */
S#define COMP_CSR_COMP1POL              ((uint32_t)0x00000800) /*!< COMP1 output polarity */
S#define COMP_CSR_COMP1HYST             ((uint32_t)0x00003000) /*!< COMP1 hysteresis */
S#define COMP_CSR_COMP1HYST_0           ((uint32_t)0x00001000) /*!< COMP1 hysteresis bit 0 */
S#define COMP_CSR_COMP1HYST_1           ((uint32_t)0x00002000) /*!< COMP1 hysteresis bit 1 */
S#define COMP_CSR_COMP1OUT              ((uint32_t)0x00004000) /*!< COMP1 output level */
S#define COMP_CSR_COMP1LOCK             ((uint32_t)0x00008000) /*!< COMP1 lock */
S/* COMP2 bits definition */
S#define COMP_CSR_COMP2EN               ((uint32_t)0x00010000) /*!< COMP2 enable */
S#define COMP_CSR_COMP2MODE             ((uint32_t)0x000C0000) /*!< COMP2 power mode */
S#define COMP_CSR_COMP2MODE_0           ((uint32_t)0x00040000) /*!< COMP2 power mode bit 0 */
S#define COMP_CSR_COMP2MODE_1           ((uint32_t)0x00080000) /*!< COMP2 power mode bit 1 */
S#define COMP_CSR_COMP2INSEL            ((uint32_t)0x00700000) /*!< COMP2 inverting input select */
S#define COMP_CSR_COMP2INSEL_0          ((uint32_t)0x00100000) /*!< COMP2 inverting input select bit 0 */
S#define COMP_CSR_COMP2INSEL_1          ((uint32_t)0x00200000) /*!< COMP2 inverting input select bit 1 */
S#define COMP_CSR_COMP2INSEL_2          ((uint32_t)0x00400000) /*!< COMP2 inverting input select bit 2 */
S#define COMP_CSR_WNDWEN                ((uint32_t)0x00800000) /*!< Comparators window mode enable */
S#define COMP_CSR_COMP2OUTSEL           ((uint32_t)0x07000000) /*!< COMP2 output select */
S#define COMP_CSR_COMP2OUTSEL_0         ((uint32_t)0x01000000) /*!< COMP2 output select bit 0 */
S#define COMP_CSR_COMP2OUTSEL_1         ((uint32_t)0x02000000) /*!< COMP2 output select bit 1 */
S#define COMP_CSR_COMP2OUTSEL_2         ((uint32_t)0x04000000) /*!< COMP2 output select bit 2 */
S#define COMP_CSR_COMP2POL              ((uint32_t)0x08000000) /*!< COMP2 output polarity */
S#define COMP_CSR_COMP2HYST             ((uint32_t)0x30000000) /*!< COMP2 hysteresis */
S#define COMP_CSR_COMP2HYST_0           ((uint32_t)0x10000000) /*!< COMP2 hysteresis bit 0 */
S#define COMP_CSR_COMP2HYST_1           ((uint32_t)0x20000000) /*!< COMP2 hysteresis bit 1 */
S#define COMP_CSR_COMP2OUT              ((uint32_t)0x40000000) /*!< COMP2 output level */
S#define COMP_CSR_COMP2LOCK             ((uint32_t)0x80000000) /*!< COMP2 lock */
S
S/******************************************************************************/
S/*                                                                            */
S/*                   Controller Area Network (CAN )                           */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for CAN_MCR register  ********************/
S#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!<Initialization Request */
S#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!<Sleep Mode Request */
S#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!<Transmit FIFO Priority */
S#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!<Receive FIFO Locked Mode */
S#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!<No Automatic Retransmission */
S#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!<Automatic Wakeup Mode */
S#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!<Automatic Bus-Off Management */
S#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!<Time Triggered Communication Mode */
S#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!<bxCAN software master reset */
S
S/*******************  Bit definition for CAN_MSR register  ********************/
S#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!<Initialization Acknowledge */
S#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!<Sleep Acknowledge */
S#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!<Error Interrupt */
S#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!<Wakeup Interrupt */
S#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!<Sleep Acknowledge Interrupt */
S#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!<Transmit Mode */
S#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!<Receive Mode */
S#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!<Last Sample Point */
S#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!<CAN Rx Signal */
S
S/*******************  Bit definition for CAN_TSR register  ********************/
S#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!<Request Completed Mailbox0 */
S#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!<Transmission OK of Mailbox0 */
S#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!<Arbitration Lost for Mailbox0 */
S#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!<Transmission Error of Mailbox0 */
S#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!<Abort Request for Mailbox0 */
S#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!<Request Completed Mailbox1 */
S#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!<Transmission OK of Mailbox1 */
S#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!<Arbitration Lost for Mailbox1 */
S#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!<Transmission Error of Mailbox1 */
S#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!<Abort Request for Mailbox 1 */
S#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!<Request Completed Mailbox2 */
S#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!<Transmission OK of Mailbox 2 */
S#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!<Arbitration Lost for mailbox 2 */
S#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!<Transmission Error of Mailbox 2 */
S#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!<Abort Request for Mailbox 2 */
S#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!<Mailbox Code */
S
S#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!<TME[2:0] bits */
S#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!<Transmit Mailbox 0 Empty */
S#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!<Transmit Mailbox 1 Empty */
S#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!<Transmit Mailbox 2 Empty */
S
S#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!<LOW[2:0] bits */
S#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!<Lowest Priority Flag for Mailbox 0 */
S#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!<Lowest Priority Flag for Mailbox 1 */
S#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!<Lowest Priority Flag for Mailbox 2 */
S
S/*******************  Bit definition for CAN_RF0R register  *******************/
S#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!<FIFO 0 Message Pending */
S#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!<FIFO 0 Full */
S#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!<FIFO 0 Overrun */
S#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!<Release FIFO 0 Output Mailbox */
S
S/*******************  Bit definition for CAN_RF1R register  *******************/
S#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!<FIFO 1 Message Pending */
S#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!<FIFO 1 Full */
S#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!<FIFO 1 Overrun */
S#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!<Release FIFO 1 Output Mailbox */
S
S/********************  Bit definition for CAN_IER register  *******************/
S#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Empty Interrupt Enable */
S#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!<FIFO Message Pending Interrupt Enable */
S#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!<FIFO Full Interrupt Enable */
S#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!<FIFO Overrun Interrupt Enable */
S#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!<FIFO Message Pending Interrupt Enable */
S#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!<FIFO Full Interrupt Enable */
S#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!<FIFO Overrun Interrupt Enable */
S#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!<Error Warning Interrupt Enable */
S#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!<Error Passive Interrupt Enable */
S#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!<Bus-Off Interrupt Enable */
S#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!<Last Error Code Interrupt Enable */
S#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!<Error Interrupt Enable */
S#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!<Wakeup Interrupt Enable */
S#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!<Sleep Interrupt Enable */
S
S/********************  Bit definition for CAN_ESR register  *******************/
S#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!<Error Warning Flag */
S#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!<Error Passive Flag */
S#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!<Bus-Off Flag */
S
S#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!<LEC[2:0] bits (Last Error Code) */
S#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!<Bit 0 */
S#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!<Bit 1 */
S#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!<Bit 2 */
S
S#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!<Least significant byte of the 9-bit Transmit Error Counter */
S#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!<Receive Error Counter */
S
S/*******************  Bit definition for CAN_BTR register  ********************/
S#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!<Baud Rate Prescaler */
S#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!<Time Segment 1 */
S#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!<Time Segment 2 */
S#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!<Resynchronization Jump Width */
S#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!<Loop Back Mode (Debug) */
S#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!<Silent Mode */
S
S/*!<Mailbox registers */
S/******************  Bit definition for CAN_TI0R register  ********************/
S#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
S#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
S#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/******************  Bit definition for CAN_TDT0R register  *******************/
S#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
S#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/******************  Bit definition for CAN_TDL0R register  *******************/
S#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/******************  Bit definition for CAN_TDH0R register  *******************/
S#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*******************  Bit definition for CAN_TI1R register  *******************/
S#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
S#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
S#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_TDT1R register  ******************/
S#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
S#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/*******************  Bit definition for CAN_TDL1R register  ******************/
S#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/*******************  Bit definition for CAN_TDH1R register  ******************/
S#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*******************  Bit definition for CAN_TI2R register  *******************/
S#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!<Transmit Mailbox Request */
S#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
S#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_TDT2R register  ******************/  
S#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!<Transmit Global Time */
S#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/*******************  Bit definition for CAN_TDL2R register  ******************/
S#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/*******************  Bit definition for CAN_TDH2R register  ******************/
S#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*******************  Bit definition for CAN_RI0R register  *******************/
S#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended Identifier */
S#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_RDT0R register  ******************/
S#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
S#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/*******************  Bit definition for CAN_RDL0R register  ******************/
S#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/*******************  Bit definition for CAN_RDH0R register  ******************/
S#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*******************  Bit definition for CAN_RI1R register  *******************/
S#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!<Remote Transmission Request */
S#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!<Identifier Extension */
S#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!<Extended identifier */
S#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!<Standard Identifier or Extended Identifier */
S
S/*******************  Bit definition for CAN_RDT1R register  ******************/
S#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!<Data Length Code */
S#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!<Filter Match Index */
S#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!<Message Time Stamp */
S
S/*******************  Bit definition for CAN_RDL1R register  ******************/
S#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!<Data byte 0 */
S#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!<Data byte 1 */
S#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!<Data byte 2 */
S#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!<Data byte 3 */
S
S/*******************  Bit definition for CAN_RDH1R register  ******************/
S#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!<Data byte 4 */
S#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!<Data byte 5 */
S#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!<Data byte 6 */
S#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!<Data byte 7 */
S
S/*!<CAN filter registers */
S/*******************  Bit definition for CAN_FMR register  ********************/
S#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!<Filter Init Mode */
S
S/*******************  Bit definition for CAN_FM1R register  *******************/
S#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!<Filter Mode */
S#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!<Filter Init Mode bit 0 */
S#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!<Filter Init Mode bit 1 */
S#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!<Filter Init Mode bit 2 */
S#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!<Filter Init Mode bit 3 */
S#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!<Filter Init Mode bit 4 */
S#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!<Filter Init Mode bit 5 */
S#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!<Filter Init Mode bit 6 */
S#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!<Filter Init Mode bit 7 */
S#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!<Filter Init Mode bit 8 */
S#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!<Filter Init Mode bit 9 */
S#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!<Filter Init Mode bit 10 */
S#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!<Filter Init Mode bit 11 */
S#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!<Filter Init Mode bit 12 */
S#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!<Filter Init Mode bit 13 */
S
S/*******************  Bit definition for CAN_FS1R register  *******************/
S#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!<Filter Scale Configuration */
S#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!<Filter Scale Configuration bit 0 */
S#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!<Filter Scale Configuration bit 1 */
S#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!<Filter Scale Configuration bit 2 */
S#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!<Filter Scale Configuration bit 3 */
S#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!<Filter Scale Configuration bit 4 */
S#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!<Filter Scale Configuration bit 5 */
S#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!<Filter Scale Configuration bit 6 */
S#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!<Filter Scale Configuration bit 7 */
S#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!<Filter Scale Configuration bit 8 */
S#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!<Filter Scale Configuration bit 9 */
S#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!<Filter Scale Configuration bit 10 */
S#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!<Filter Scale Configuration bit 11 */
S#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!<Filter Scale Configuration bit 12 */
S#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!<Filter Scale Configuration bit 13 */
S
S/******************  Bit definition for CAN_FFA1R register  *******************/
S#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!<Filter FIFO Assignment */
S#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!<Filter FIFO Assignment for Filter 0 */
S#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!<Filter FIFO Assignment for Filter 1 */
S#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!<Filter FIFO Assignment for Filter 2 */
S#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!<Filter FIFO Assignment for Filter 3 */
S#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!<Filter FIFO Assignment for Filter 4 */
S#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!<Filter FIFO Assignment for Filter 5 */
S#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!<Filter FIFO Assignment for Filter 6 */
S#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!<Filter FIFO Assignment for Filter 7 */
S#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!<Filter FIFO Assignment for Filter 8 */
S#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!<Filter FIFO Assignment for Filter 9 */
S#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!<Filter FIFO Assignment for Filter 10 */
S#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!<Filter FIFO Assignment for Filter 11 */
S#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!<Filter FIFO Assignment for Filter 12 */
S#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!<Filter FIFO Assignment for Filter 13 */
S
S/*******************  Bit definition for CAN_FA1R register  *******************/
S#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!<Filter Active */
S#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!<Filter 0 Active */
S#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!<Filter 1 Active */
S#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!<Filter 2 Active */
S#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!<Filter 3 Active */
S#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!<Filter 4 Active */
S#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!<Filter 5 Active */
S#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!<Filter 6 Active */
S#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!<Filter 7 Active */
S#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!<Filter 8 Active */
S#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!<Filter 9 Active */
S#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!<Filter 10 Active */
S#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!<Filter 11 Active */
S#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!<Filter 12 Active */
S#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!<Filter 13 Active */
S
S/*******************  Bit definition for CAN_F0R1 register  *******************/
S#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F1R1 register  *******************/
S#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F2R1 register  *******************/
S#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F3R1 register  *******************/
S#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F4R1 register  *******************/
S#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F5R1 register  *******************/
S#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F6R1 register  *******************/
S#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F7R1 register  *******************/
S#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F8R1 register  *******************/
S#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F9R1 register  *******************/
S#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F10R1 register  ******************/
S#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F11R1 register  ******************/
S#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F12R1 register  ******************/
S#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F13R1 register  ******************/
S#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F0R2 register  *******************/
S#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F1R2 register  *******************/
S#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F2R2 register  *******************/
S#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F3R2 register  *******************/
S#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F4R2 register  *******************/
S#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F5R2 register  *******************/
S#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F6R2 register  *******************/
S#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F7R2 register  *******************/
S#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F8R2 register  *******************/
S#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F9R2 register  *******************/
S#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F10R2 register  ******************/
S#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F11R2 register  ******************/
S#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F12R2 register  ******************/
S#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/*******************  Bit definition for CAN_F13R2 register  ******************/
S#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!<Filter bit 0 */
S#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!<Filter bit 1 */
S#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!<Filter bit 2 */
S#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!<Filter bit 3 */
S#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!<Filter bit 4 */
S#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!<Filter bit 5 */
S#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!<Filter bit 6 */
S#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!<Filter bit 7 */
S#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!<Filter bit 8 */
S#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!<Filter bit 9 */
S#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!<Filter bit 10 */
S#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!<Filter bit 11 */
S#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!<Filter bit 12 */
S#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!<Filter bit 13 */
S#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!<Filter bit 14 */
S#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!<Filter bit 15 */
S#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!<Filter bit 16 */
S#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!<Filter bit 17 */
S#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!<Filter bit 18 */
S#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!<Filter bit 19 */
S#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!<Filter bit 20 */
S#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!<Filter bit 21 */
S#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!<Filter bit 22 */
S#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!<Filter bit 23 */
S#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!<Filter bit 24 */
S#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!<Filter bit 25 */
S#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!<Filter bit 26 */
S#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!<Filter bit 27 */
S#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!<Filter bit 28 */
S#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!<Filter bit 29 */
S#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!<Filter bit 30 */
S#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!<Filter bit 31 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                     CRC calculation unit (CRC)                             */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for CRC_DR register  *********************/
S#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */
S
S/*******************  Bit definition for CRC_IDR register  ********************/
S#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */
S
S/********************  Bit definition for CRC_CR register  ********************/
S#define  CRC_CR_RESET                        ((uint32_t)0x00000001) /*!< RESET the CRC computation unit bit */
S#define  CRC_CR_POLSIZE                      ((uint32_t)0x00000018) /*!< Polynomial size bits */
S#define  CRC_CR_POLSIZE_0                    ((uint32_t)0x00000008) /*!< Polynomial size bit 0 */
S#define  CRC_CR_POLSIZE_1                    ((uint32_t)0x00000010) /*!< Polynomial size bit 1 */
S#define  CRC_CR_REV_IN                       ((uint32_t)0x00000060) /*!< REV_IN Reverse Input Data bits */
S#define  CRC_CR_REV_IN_0                     ((uint32_t)0x00000020) /*!< Bit 0 */
S#define  CRC_CR_REV_IN_1                     ((uint32_t)0x00000040) /*!< Bit 1 */
S#define  CRC_CR_REV_OUT                      ((uint32_t)0x00000080) /*!< REV_OUT Reverse Output Data bits */
S
S/*******************  Bit definition for CRC_INIT register  *******************/
S#define  CRC_INIT_INIT                       ((uint32_t)0xFFFFFFFF) /*!< Initial CRC value bits */
S
S/*******************  Bit definition for CRC_POL register  ********************/
S#define  CRC_POL_POL                         ((uint32_t)0xFFFFFFFF) /*!< Coefficients of the polynomial */
S
S/******************************************************************************/
S/*                                                                            */
S/*                 Digital to Analog Converter (DAC)                          */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for DAC_CR register  ********************/
S#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!< DAC channel1 enable */
S#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!< DAC channel1 output buffer disable */
S#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!< DAC channel1 Trigger enable */
S
S#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!< TSEL1[2:0] (DAC channel1 Trigger selection) */
S#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!< Bit 1 */
S#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!< Bit 2 */
S
S#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */
S#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!< Bit 0 */
S#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!< Bit 1 */
S
S#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!< MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */
S#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!< Bit 2 */
S#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!< Bit 3 */
S
S#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!< DAC channel1 DMA enable */
S#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!< DAC channel2 enable */
S#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!< DAC channel2 output buffer disable */
S#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!< DAC channel2 Trigger enable */
S
S#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!< TSEL2[2:0] (DAC channel2 Trigger selection) */
S#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!< Bit 0 */
S#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!< Bit 1 */
S#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!< Bit 2 */
S
S#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */
S#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!< Bit 0 */
S#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!< Bit 1 */
S
S#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!< MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */
S#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
S#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */
S
S#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!< DAC channel2 DMA enabled */
S
S/*****************  Bit definition for DAC_SWTRIGR register  ******************/
S#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!< DAC channel1 software trigger */
S#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!< DAC channel2 software trigger */
S
S/*****************  Bit definition for DAC_DHR12R1 register  ******************/
S#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!< DAC channel1 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12L1 register  ******************/
S#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!< DAC channel1 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8R1 register  ******************/
S#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!< DAC channel1 8-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12R2 register  ******************/
S#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!< DAC channel2 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12L2 register  ******************/
S#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!< DAC channel2 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8R2 register  ******************/
S#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!< DAC channel2 8-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12RD register  ******************/
S#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!< DAC channel1 12-bit Right aligned data */
S#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!< DAC channel2 12-bit Right aligned data */
S
S/*****************  Bit definition for DAC_DHR12LD register  ******************/
S#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!< DAC channel1 12-bit Left aligned data */
S#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!< DAC channel2 12-bit Left aligned data */
S
S/******************  Bit definition for DAC_DHR8RD register  ******************/
S#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!< DAC channel1 8-bit Right aligned data */
S#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!< DAC channel2 8-bit Right aligned data */
S
S/*******************  Bit definition for DAC_DOR1 register  *******************/
S#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel1 data output */
S
S/*******************  Bit definition for DAC_DOR2 register  *******************/
S#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel2 data output */
S
S/********************  Bit definition for DAC_SR register  ********************/
S#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!< DAC channel1 DMA underrun flag */
S#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!< DAC channel2 DMA underrun flag */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                 Debug MCU (DBGMCU)                         */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for DBGMCU_IDCODE register  *************/
S#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)
S#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)
S
S/********************  Bit definition for DBGMCU_CR register  *****************/
S#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)
S#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)
S#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)
S
S/********************  Bit definition for DBGMCU_APB1_FZ register  ************/
S#define  DBGMCU_APB1_FZ_DBG_TIM2_STOP        ((uint32_t)0x00000001)
S#define  DBGMCU_APB1_FZ_DBG_TIM3_STOP        ((uint32_t)0x00000002)
S#define  DBGMCU_APB1_FZ_DBG_TIM4_STOP        ((uint32_t)0x00000004)
S#define  DBGMCU_APB1_FZ_DBG_TIM5_STOP        ((uint32_t)0x00000008)
S#define  DBGMCU_APB1_FZ_DBG_TIM6_STOP        ((uint32_t)0x00000010)
S#define  DBGMCU_APB1_FZ_DBG_TIM7_STOP        ((uint32_t)0x00000020)
S#define  DBGMCU_APB1_FZ_DBG_TIM12_STOP       ((uint32_t)0x00000040)
S#define  DBGMCU_APB1_FZ_DBG_TIM13_STOP       ((uint32_t)0x00000080)
S#define  DBGMCU_APB1_FZ_DBG_TIM14_STOP       ((uint32_t)0x00000100)
S#define  DBGMCU_APB1_FZ_DBG_TIM18_STOP       ((uint32_t)0x00000200)
S#define  DBGMCU_APB1_FZ_DBG_RTC_STOP         ((uint32_t)0x00000400)
S#define  DBGMCU_APB1_FZ_DBG_WWDG_STOP        ((uint32_t)0x00000800)
S#define  DBGMCU_APB1_FZ_DBG_IWDG_STOP        ((uint32_t)0x00001000)
S#define  DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT   ((uint32_t)0x00200000)
S#define  DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT   ((uint32_t)0x00400000)
S#define  DBGMCU_APB1_FZ_DBG_CAN1_STOP            ((uint32_t)0x02000000)
S
S/********************  Bit definition for DBGMCU_APB2_FZ register  ************/
S#define  DBGMCU_APB2_FZ_DBG_TIM15_STOP       ((uint32_t)0x00000004)
S#define  DBGMCU_APB2_FZ_DBG_TIM16_STOP       ((uint32_t)0x00000008)
S#define  DBGMCU_APB2_FZ_DBG_TIM17_STOP       ((uint32_t)0x00000010)
S#define  DBGMCU_APB2_FZ_DBG_TIM19_STOP       ((uint32_t)0x00000020)
S
S/******************************************************************************/
S/*                                                                            */
S/*                             DMA Controller (DMA)                           */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for DMA_ISR register  ********************/
S#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */
S#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */
S#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */
S#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */
S#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */
S#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */
S#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */
S#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */
S#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */
S#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */
S#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */
S#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */
S#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */
S#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */
S#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */
S#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */
S#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */
S#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */
S#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */
S#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */
S#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */
S#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */
S#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */
S#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */
S#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */
S#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */
S#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */
S#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */
S
S/*******************  Bit definition for DMA_IFCR register  *******************/
S#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear */
S#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */
S#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */
S#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */
S#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */
S#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */
S#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */
S#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */
S#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */
S#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */
S#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */
S#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */
S#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */
S#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */
S#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */
S#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */
S#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */
S#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */
S#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */
S#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */
S#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */
S#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */
S
S/*******************  Bit definition for DMA_CCR register  ********************/
S#define  DMA_CCR_EN                          ((uint32_t)0x00000001)        /*!< Channel enable                      */
S#define  DMA_CCR_TCIE                        ((uint32_t)0x00000002)        /*!< Transfer complete interrupt enable  */
S#define  DMA_CCR_HTIE                        ((uint32_t)0x00000004)        /*!< Half Transfer interrupt enable      */
S#define  DMA_CCR_TEIE                        ((uint32_t)0x00000008)        /*!< Transfer error interrupt enable     */
S#define  DMA_CCR_DIR                         ((uint32_t)0x00000010)        /*!< Data transfer direction             */
S#define  DMA_CCR_CIRC                        ((uint32_t)0x00000020)        /*!< Circular mode                       */
S#define  DMA_CCR_PINC                        ((uint32_t)0x00000040)        /*!< Peripheral increment mode           */
S#define  DMA_CCR_MINC                        ((uint32_t)0x00000080)        /*!< Memory increment mode               */
S
S#define  DMA_CCR_PSIZE                       ((uint32_t)0x00000300)        /*!< PSIZE[1:0] bits (Peripheral size)   */
S#define  DMA_CCR_PSIZE_0                     ((uint32_t)0x00000100)        /*!< Bit 0                               */
S#define  DMA_CCR_PSIZE_1                     ((uint32_t)0x00000200)        /*!< Bit 1                               */
S
S#define  DMA_CCR_MSIZE                       ((uint32_t)0x00000C00)        /*!< MSIZE[1:0] bits (Memory size)       */
S#define  DMA_CCR_MSIZE_0                     ((uint32_t)0x00000400)        /*!< Bit 0                               */
S#define  DMA_CCR_MSIZE_1                     ((uint32_t)0x00000800)        /*!< Bit 1                               */
S
S#define  DMA_CCR_PL                          ((uint32_t)0x00003000)        /*!< PL[1:0] bits(Channel Priority level)*/
S#define  DMA_CCR_PL_0                        ((uint32_t)0x00001000)        /*!< Bit 0                               */
S#define  DMA_CCR_PL_1                        ((uint32_t)0x00002000)        /*!< Bit 1                               */
S
S#define  DMA_CCR_MEM2MEM                     ((uint32_t)0x00004000)        /*!< Memory to memory mode               */
S
S/******************  Bit definition for DMA_CNDTR register  *******************/
S#define  DMA_CNDTR_NDT                       ((uint32_t)0x0000FFFF)        /*!< Number of data to Transfer          */
S
S/******************  Bit definition for DMA_CPAR register  ********************/
S#define  DMA_CPAR_PA                         ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address                  */
S
S/******************  Bit definition for DMA_CMAR register  ********************/
S#define  DMA_CMAR_MA                         ((uint32_t)0xFFFFFFFF)        /*!< Memory Address                      */
S
S/******************************************************************************/
S/*                                                                            */
S/*                    External Interrupt/Event Controller (EXTI)              */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for EXTI_IMR register  *******************/
S#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */
S#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */
S#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */
S#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */
S#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */
S#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */
S#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */
S#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */
S#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */
S#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */
S#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */
S#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */
S#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */
S#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */
S#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */
S#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */
S#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */
S#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */
S#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */
S#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */
S#define  EXTI_IMR_MR20                       ((uint32_t)0x00100000)        /*!< Interrupt Mask on line 20 */
S#define  EXTI_IMR_MR21                       ((uint32_t)0x00200000)        /*!< Interrupt Mask on line 21 */
S#define  EXTI_IMR_MR22                       ((uint32_t)0x00400000)        /*!< Interrupt Mask on line 22 */
S#define  EXTI_IMR_MR23                       ((uint32_t)0x00800000)        /*!< Interrupt Mask on line 23 */
S#define  EXTI_IMR_MR24                       ((uint32_t)0x01000000)        /*!< Interrupt Mask on line 24 */
S#define  EXTI_IMR_MR25                       ((uint32_t)0x02000000)        /*!< Interrupt Mask on line 25 */
S#define  EXTI_IMR_MR26                       ((uint32_t)0x04000000)        /*!< Interrupt Mask on line 26 */
S#define  EXTI_IMR_MR27                       ((uint32_t)0x08000000)        /*!< Interrupt Mask on line 27 */
S#define  EXTI_IMR_MR28                       ((uint32_t)0x10000000)        /*!< Interrupt Mask on line 28 */
S
S/*******************  Bit definition for EXTI_EMR register  *******************/
S#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */
S#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */
S#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */
S#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */
S#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */
S#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */
S#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */
S#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */
S#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */
S#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */
S#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */
S#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */
S#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */
S#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */
S#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */
S#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */
S#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */
S#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */
S#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */
S#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */
S#define  EXTI_EMR_MR20                       ((uint32_t)0x00100000)        /*!< Event Mask on line 20 */
S#define  EXTI_EMR_MR21                       ((uint32_t)0x00200000)        /*!< Event Mask on line 21 */
S#define  EXTI_EMR_MR22                       ((uint32_t)0x00400000)        /*!< Event Mask on line 22 */
S#define  EXTI_EMR_MR23                       ((uint32_t)0x00800000)        /*!< Event Mask on line 23 */
S#define  EXTI_EMR_MR24                       ((uint32_t)0x01000000)        /*!< Event Mask on line 24 */
S#define  EXTI_EMR_MR25                       ((uint32_t)0x02000000)        /*!< Event Mask on line 25 */
S#define  EXTI_EMR_MR26                       ((uint32_t)0x04000000)        /*!< Event Mask on line 26 */
S#define  EXTI_EMR_MR27                       ((uint32_t)0x08000000)        /*!< Event Mask on line 27 */
S#define  EXTI_EMR_MR28                       ((uint32_t)0x10000000)        /*!< Event Mask on line 28 */
S
S/******************  Bit definition for EXTI_RTSR register  *******************/
S#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */
S#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */
S#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */
S#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */
S#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */
S#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */
S#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */
S#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */
S#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */
S#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */
S#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */
S#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */
S#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */
S#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */
S#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */
S#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */
S#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */
S#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */
S#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */
S#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */
S#define  EXTI_RTSR_TR20                      ((uint32_t)0x00100000)        /*!< Rising trigger event configuration bit of line 20 */
S#define  EXTI_RTSR_TR21                      ((uint32_t)0x00200000)        /*!< Rising trigger event configuration bit of line 21 */
S#define  EXTI_RTSR_TR22                      ((uint32_t)0x00400000)        /*!< Rising trigger event configuration bit of line 22 */
S#define  EXTI_RTSR_TR23                      ((uint32_t)0x00800000)        /*!< Rising trigger event configuration bit of line 23 */
S#define  EXTI_RTSR_TR24                      ((uint32_t)0x01000000)        /*!< Rising trigger event configuration bit of line 24 */
S#define  EXTI_RTSR_TR25                      ((uint32_t)0x02000000)        /*!< Rising trigger event configuration bit of line 25 */
S#define  EXTI_RTSR_TR26                      ((uint32_t)0x04000000)        /*!< Rising trigger event configuration bit of line 26 */
S#define  EXTI_RTSR_TR27                      ((uint32_t)0x08000000)        /*!< Rising trigger event configuration bit of line 27 */
S#define  EXTI_RTSR_TR28                      ((uint32_t)0x10000000)        /*!< Rising trigger event configuration bit of line 28 */
S
S/******************  Bit definition for EXTI_FTSR register  *******************/
S#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */
S#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */
S#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */
S#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */
S#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */
S#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */
S#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */
S#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */
S#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */
S#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */
S#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */
S#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */
S#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */
S#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */
S#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */
S#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */
S#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */
S#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */
S#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */
S#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */
S#define  EXTI_FTSR_TR20                      ((uint32_t)0x00100000)        /*!< Falling trigger event configuration bit of line 20 */
S#define  EXTI_FTSR_TR21                      ((uint32_t)0x00200000)        /*!< Falling trigger event configuration bit of line 21 */
S#define  EXTI_FTSR_TR22                      ((uint32_t)0x00400000)        /*!< Falling trigger event configuration bit of line 22 */
S#define  EXTI_FTSR_TR23                      ((uint32_t)0x00800000)        /*!< Falling trigger event configuration bit of line 23 */
S#define  EXTI_FTSR_TR24                      ((uint32_t)0x01000000)        /*!< Falling trigger event configuration bit of line 24 */
S#define  EXTI_FTSR_TR25                      ((uint32_t)0x02000000)        /*!< Falling trigger event configuration bit of line 25 */
S#define  EXTI_FTSR_TR26                      ((uint32_t)0x04000000)        /*!< Falling trigger event configuration bit of line 26 */
S#define  EXTI_FTSR_TR27                      ((uint32_t)0x08000000)        /*!< Falling trigger event configuration bit of line 27 */
S#define  EXTI_FTSR_TR28                      ((uint32_t)0x10000000)        /*!< Falling trigger event configuration bit of line 28 */
S
S/******************  Bit definition for EXTI_SWIER register  ******************/
S#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */
S#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */
S#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */
S#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */
S#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */
S#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */
S#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */
S#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */
S#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */
S#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */
S#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */
S#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */
S#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */
S#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */
S#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */
S#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */
S#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */
S#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */
S#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */
S#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */
S#define  EXTI_SWIER_SWIER20                  ((uint32_t)0x00100000)        /*!< Software Interrupt on line 20 */
S#define  EXTI_SWIER_SWIER21                  ((uint32_t)0x00200000)        /*!< Software Interrupt on line 21 */
S#define  EXTI_SWIER_SWIER22                  ((uint32_t)0x00400000)        /*!< Software Interrupt on line 22 */
S#define  EXTI_SWIER_SWIER23                  ((uint32_t)0x00800000)        /*!< Software Interrupt on line 23 */
S#define  EXTI_SWIER_SWIER24                  ((uint32_t)0x01000000)        /*!< Software Interrupt on line 24 */
S#define  EXTI_SWIER_SWIER25                  ((uint32_t)0x02000000)        /*!< Software Interrupt on line 25 */
S#define  EXTI_SWIER_SWIER26                  ((uint32_t)0x04000000)        /*!< Software Interrupt on line 26 */
S#define  EXTI_SWIER_SWIER27                  ((uint32_t)0x08000000)        /*!< Software Interrupt on line 27 */
S#define  EXTI_SWIER_SWIER28                  ((uint32_t)0x10000000)        /*!< Software Interrupt on line 28 */
S
S/*******************  Bit definition for EXTI_PR register  ********************/
S#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */
S#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */
S#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */
S#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */
S#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */
S#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */
S#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */
S#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */
S#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */
S#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */
S#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */
S#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */
S#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */
S#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */
S#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */
S#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */
S#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */
S#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */
S#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */
S#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */
S#define  EXTI_PR_PR20                        ((uint32_t)0x00100000)        /*!< Pending bit for line 20 */
S#define  EXTI_PR_PR21                        ((uint32_t)0x00200000)        /*!< Pending bit for line 21 */
S#define  EXTI_PR_PR22                        ((uint32_t)0x00400000)        /*!< Pending bit for line 22 */
S#define  EXTI_PR_PR23                        ((uint32_t)0x00800000)        /*!< Pending bit for line 23 */
S#define  EXTI_PR_PR24                        ((uint32_t)0x01000000)        /*!< Pending bit for line 24 */
S#define  EXTI_PR_PR25                        ((uint32_t)0x02000000)        /*!< Pending bit for line 25 */
S#define  EXTI_PR_PR26                        ((uint32_t)0x04000000)        /*!< Pending bit for line 26 */
S#define  EXTI_PR_PR27                        ((uint32_t)0x08000000)        /*!< Pending bit for line 27 */
S#define  EXTI_PR_PR28                        ((uint32_t)0x10000000)        /*!< Pending bit for line 28 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                    FLASH                                   */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for FLASH_ACR register  ******************/
S#define  FLASH_ACR_LATENCY                   ((uint8_t)0x03)               /*!< LATENCY[2:0] bits (Latency) */
S#define  FLASH_ACR_LATENCY_0                 ((uint8_t)0x01)               /*!< Bit 0 */
S#define  FLASH_ACR_LATENCY_1                 ((uint8_t)0x02)               /*!< Bit 1 */
S
S#define  FLASH_ACR_HLFCYA                    ((uint8_t)0x08)               /*!< Flash Half Cycle Access Enable */
S#define  FLASH_ACR_PRFTBE                    ((uint8_t)0x10)               /*!< Prefetch Buffer Enable */
S#define  FLASH_ACR_PRFTBS                    ((uint8_t)0x20)
S
S/******************  Bit definition for FLASH_KEYR register  ******************/
S#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */
S
S/*****************  Bit definition for FLASH_OPTKEYR register  ****************/
S#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */
S
S/******************  Bit definition for FLASH_SR register  *******************/
S#define  FLASH_SR_BSY                        ((uint32_t)0x00000001)        /*!< Busy */
S#define  FLASH_SR_PGERR                      ((uint32_t)0x00000004)        /*!< Programming Error */
S#define  FLASH_SR_WRPERR                     ((uint32_t)0x00000010)        /*!< Write Protection Error */
S#define  FLASH_SR_EOP                        ((uint32_t)0x00000020)        /*!< End of operation */
S
S/*******************  Bit definition for FLASH_CR register  *******************/
S#define  FLASH_CR_PG                         ((uint32_t)0x00000001)        /*!< Programming */
S#define  FLASH_CR_PER                        ((uint32_t)0x00000002)        /*!< Page Erase */
S#define  FLASH_CR_MER                        ((uint32_t)0x00000004)        /*!< Mass Erase */
S#define  FLASH_CR_OPTPG                      ((uint32_t)0x00000010)        /*!< Option Byte Programming */
S#define  FLASH_CR_OPTER                      ((uint32_t)0x00000020)        /*!< Option Byte Erase */
S#define  FLASH_CR_STRT                       ((uint32_t)0x00000040)        /*!< Start */
S#define  FLASH_CR_LOCK                       ((uint32_t)0x00000080)        /*!< Lock */
S#define  FLASH_CR_OPTWRE                     ((uint32_t)0x00000200)        /*!< Option Bytes Write Enable */
S#define  FLASH_CR_ERRIE                      ((uint32_t)0x00000400)        /*!< Error Interrupt Enable */
S#define  FLASH_CR_EOPIE                      ((uint32_t)0x00001000)        /*!< End of operation interrupt enable */
S#define  FLASH_CR_OBL_LAUNCH                 ((uint32_t)0x00002000)        /*!< OptionBytes Loader Launch */
S
S/*******************  Bit definition for FLASH_AR register  *******************/
S#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */
S
S/******************  Bit definition for FLASH_OBR register  *******************/
S#define  FLASH_OBR_OPTERR                    ((uint32_t)0x00000001)        /*!< Option Byte Error */
S#define  FLASH_OBR_RDPRT1                    ((uint32_t)0x00000002)        /*!< Read protection Level 1 */
S#define  FLASH_OBR_RDPRT2                    ((uint32_t)0x00000004)        /*!< Read protection Level 2 */
S
S#define  FLASH_OBR_USER                      ((uint32_t)0x00003700)        /*!< User Option Bytes */
S#define  FLASH_OBR_IWDG_SW                   ((uint32_t)0x00000100)        /*!< IWDG SW */
S#define  FLASH_OBR_nRST_STOP                 ((uint32_t)0x00000200)        /*!< nRST_STOP */
S#define  FLASH_OBR_nRST_STDBY                ((uint32_t)0x00000400)        /*!< nRST_STDBY */
S
S/******************  Bit definition for FLASH_WRPR register  ******************/
S#define  FLASH_WRPR_WRP                        ((uint32_t)0xFFFFFFFF)      /*!< Write Protect */
S
S/*----------------------------------------------------------------------------*/
S
S/******************  Bit definition for OB_RDP register  **********************/
S#define  OB_RDP_RDP                          ((uint32_t)0x000000FF)        /*!< Read protection option byte */
S#define  OB_RDP_nRDP                         ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */
S
S/******************  Bit definition for OB_USER register  *********************/
S#define  OB_USER_USER                        ((uint32_t)0x00FF0000)        /*!< User option byte */
S#define  OB_USER_nUSER                       ((uint32_t)0xFF000000)        /*!< User complemented option byte */
S
S/******************  Bit definition for FLASH_WRP0 register  ******************/
S#define  OB_WRP0_WRP0                        ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
S#define  OB_WRP0_nWRP0                       ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
S
S/******************  Bit definition for FLASH_WRP1 register  ******************/
S#define  OB_WRP1_WRP1                        ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
S#define  OB_WRP1_nWRP1                       ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
S
S/******************  Bit definition for FLASH_WRP2 register  ******************/
S#define  OB_WRP2_WRP2                        ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */
S#define  OB_WRP2_nWRP2                       ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */
S
S/******************  Bit definition for FLASH_WRP3 register  ******************/
S#define  OB_WRP3_WRP3                        ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */
S#define  OB_WRP3_nWRP3                       ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */
S/******************************************************************************/
S/*                                                                            */
S/*                            General Purpose I/O (GPIO)                      */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for GPIO_MODER register  *****************/
S#define GPIO_MODER_MODER0          ((uint32_t)0x00000003)
S#define GPIO_MODER_MODER0_0        ((uint32_t)0x00000001)
S#define GPIO_MODER_MODER0_1        ((uint32_t)0x00000002)
S#define GPIO_MODER_MODER1          ((uint32_t)0x0000000C)
S#define GPIO_MODER_MODER1_0        ((uint32_t)0x00000004)
S#define GPIO_MODER_MODER1_1        ((uint32_t)0x00000008)
S#define GPIO_MODER_MODER2          ((uint32_t)0x00000030)
S#define GPIO_MODER_MODER2_0        ((uint32_t)0x00000010)
S#define GPIO_MODER_MODER2_1        ((uint32_t)0x00000020)
S#define GPIO_MODER_MODER3          ((uint32_t)0x000000C0)
S#define GPIO_MODER_MODER3_0        ((uint32_t)0x00000040)
S#define GPIO_MODER_MODER3_1        ((uint32_t)0x00000080)
S#define GPIO_MODER_MODER4          ((uint32_t)0x00000300)
S#define GPIO_MODER_MODER4_0        ((uint32_t)0x00000100)
S#define GPIO_MODER_MODER4_1        ((uint32_t)0x00000200)
S#define GPIO_MODER_MODER5          ((uint32_t)0x00000C00)
S#define GPIO_MODER_MODER5_0        ((uint32_t)0x00000400)
S#define GPIO_MODER_MODER5_1        ((uint32_t)0x00000800)
S#define GPIO_MODER_MODER6          ((uint32_t)0x00003000)
S#define GPIO_MODER_MODER6_0        ((uint32_t)0x00001000)
S#define GPIO_MODER_MODER6_1        ((uint32_t)0x00002000)
S#define GPIO_MODER_MODER7          ((uint32_t)0x0000C000)
S#define GPIO_MODER_MODER7_0        ((uint32_t)0x00004000)
S#define GPIO_MODER_MODER7_1        ((uint32_t)0x00008000)
S#define GPIO_MODER_MODER8          ((uint32_t)0x00030000)
S#define GPIO_MODER_MODER8_0        ((uint32_t)0x00010000)
S#define GPIO_MODER_MODER8_1        ((uint32_t)0x00020000)
S#define GPIO_MODER_MODER9          ((uint32_t)0x000C0000)
S#define GPIO_MODER_MODER9_0        ((uint32_t)0x00040000)
S#define GPIO_MODER_MODER9_1        ((uint32_t)0x00080000)
S#define GPIO_MODER_MODER10         ((uint32_t)0x00300000)
S#define GPIO_MODER_MODER10_0       ((uint32_t)0x00100000)
S#define GPIO_MODER_MODER10_1       ((uint32_t)0x00200000)
S#define GPIO_MODER_MODER11         ((uint32_t)0x00C00000)
S#define GPIO_MODER_MODER11_0       ((uint32_t)0x00400000)
S#define GPIO_MODER_MODER11_1       ((uint32_t)0x00800000)
S#define GPIO_MODER_MODER12         ((uint32_t)0x03000000)
S#define GPIO_MODER_MODER12_0       ((uint32_t)0x01000000)
S#define GPIO_MODER_MODER12_1       ((uint32_t)0x02000000)
S#define GPIO_MODER_MODER13         ((uint32_t)0x0C000000)
S#define GPIO_MODER_MODER13_0       ((uint32_t)0x04000000)
S#define GPIO_MODER_MODER13_1       ((uint32_t)0x08000000)
S#define GPIO_MODER_MODER14         ((uint32_t)0x30000000)
S#define GPIO_MODER_MODER14_0       ((uint32_t)0x10000000)
S#define GPIO_MODER_MODER14_1       ((uint32_t)0x20000000)
S#define GPIO_MODER_MODER15         ((uint32_t)0xC0000000)
S#define GPIO_MODER_MODER15_0       ((uint32_t)0x40000000)
S#define GPIO_MODER_MODER15_1       ((uint32_t)0x80000000)
S
S/******************  Bit definition for GPIO_OTYPER register  *****************/
S#define GPIO_OTYPER_OT_0           ((uint32_t)0x00000001)
S#define GPIO_OTYPER_OT_1           ((uint32_t)0x00000002)
S#define GPIO_OTYPER_OT_2           ((uint32_t)0x00000004)
S#define GPIO_OTYPER_OT_3           ((uint32_t)0x00000008)
S#define GPIO_OTYPER_OT_4           ((uint32_t)0x00000010)
S#define GPIO_OTYPER_OT_5           ((uint32_t)0x00000020)
S#define GPIO_OTYPER_OT_6           ((uint32_t)0x00000040)
S#define GPIO_OTYPER_OT_7           ((uint32_t)0x00000080)
S#define GPIO_OTYPER_OT_8           ((uint32_t)0x00000100)
S#define GPIO_OTYPER_OT_9           ((uint32_t)0x00000200)
S#define GPIO_OTYPER_OT_10          ((uint32_t)0x00000400)
S#define GPIO_OTYPER_OT_11          ((uint32_t)0x00000800)
S#define GPIO_OTYPER_OT_12          ((uint32_t)0x00001000)
S#define GPIO_OTYPER_OT_13          ((uint32_t)0x00002000)
S#define GPIO_OTYPER_OT_14          ((uint32_t)0x00004000)
S#define GPIO_OTYPER_OT_15          ((uint32_t)0x00008000)
S
S/****************  Bit definition for GPIO_OSPEEDR register  ******************/
S#define GPIO_OSPEEDER_OSPEEDR0     ((uint32_t)0x00000003)
S#define GPIO_OSPEEDER_OSPEEDR0_0   ((uint32_t)0x00000001)
S#define GPIO_OSPEEDER_OSPEEDR0_1   ((uint32_t)0x00000002)
S#define GPIO_OSPEEDER_OSPEEDR1     ((uint32_t)0x0000000C)
S#define GPIO_OSPEEDER_OSPEEDR1_0   ((uint32_t)0x00000004)
S#define GPIO_OSPEEDER_OSPEEDR1_1   ((uint32_t)0x00000008)
S#define GPIO_OSPEEDER_OSPEEDR2     ((uint32_t)0x00000030)
S#define GPIO_OSPEEDER_OSPEEDR2_0   ((uint32_t)0x00000010)
S#define GPIO_OSPEEDER_OSPEEDR2_1   ((uint32_t)0x00000020)
S#define GPIO_OSPEEDER_OSPEEDR3     ((uint32_t)0x000000C0)
S#define GPIO_OSPEEDER_OSPEEDR3_0   ((uint32_t)0x00000040)
S#define GPIO_OSPEEDER_OSPEEDR3_1   ((uint32_t)0x00000080)
S#define GPIO_OSPEEDER_OSPEEDR4     ((uint32_t)0x00000300)
S#define GPIO_OSPEEDER_OSPEEDR4_0   ((uint32_t)0x00000100)
S#define GPIO_OSPEEDER_OSPEEDR4_1   ((uint32_t)0x00000200)
S#define GPIO_OSPEEDER_OSPEEDR5     ((uint32_t)0x00000C00)
S#define GPIO_OSPEEDER_OSPEEDR5_0   ((uint32_t)0x00000400)
S#define GPIO_OSPEEDER_OSPEEDR5_1   ((uint32_t)0x00000800)
S#define GPIO_OSPEEDER_OSPEEDR6     ((uint32_t)0x00003000)
S#define GPIO_OSPEEDER_OSPEEDR6_0   ((uint32_t)0x00001000)
S#define GPIO_OSPEEDER_OSPEEDR6_1   ((uint32_t)0x00002000)
S#define GPIO_OSPEEDER_OSPEEDR7     ((uint32_t)0x0000C000)
S#define GPIO_OSPEEDER_OSPEEDR7_0   ((uint32_t)0x00004000)
S#define GPIO_OSPEEDER_OSPEEDR7_1   ((uint32_t)0x00008000)
S#define GPIO_OSPEEDER_OSPEEDR8     ((uint32_t)0x00030000)
S#define GPIO_OSPEEDER_OSPEEDR8_0   ((uint32_t)0x00010000)
S#define GPIO_OSPEEDER_OSPEEDR8_1   ((uint32_t)0x00020000)
S#define GPIO_OSPEEDER_OSPEEDR9     ((uint32_t)0x000C0000)
S#define GPIO_OSPEEDER_OSPEEDR9_0   ((uint32_t)0x00040000)
S#define GPIO_OSPEEDER_OSPEEDR9_1   ((uint32_t)0x00080000)
S#define GPIO_OSPEEDER_OSPEEDR10    ((uint32_t)0x00300000)
S#define GPIO_OSPEEDER_OSPEEDR10_0  ((uint32_t)0x00100000)
S#define GPIO_OSPEEDER_OSPEEDR10_1  ((uint32_t)0x00200000)
S#define GPIO_OSPEEDER_OSPEEDR11    ((uint32_t)0x00C00000)
S#define GPIO_OSPEEDER_OSPEEDR11_0  ((uint32_t)0x00400000)
S#define GPIO_OSPEEDER_OSPEEDR11_1  ((uint32_t)0x00800000)
S#define GPIO_OSPEEDER_OSPEEDR12    ((uint32_t)0x03000000)
S#define GPIO_OSPEEDER_OSPEEDR12_0  ((uint32_t)0x01000000)
S#define GPIO_OSPEEDER_OSPEEDR12_1  ((uint32_t)0x02000000)
S#define GPIO_OSPEEDER_OSPEEDR13    ((uint32_t)0x0C000000)
S#define GPIO_OSPEEDER_OSPEEDR13_0  ((uint32_t)0x04000000)
S#define GPIO_OSPEEDER_OSPEEDR13_1  ((uint32_t)0x08000000)
S#define GPIO_OSPEEDER_OSPEEDR14    ((uint32_t)0x30000000)
S#define GPIO_OSPEEDER_OSPEEDR14_0  ((uint32_t)0x10000000)
S#define GPIO_OSPEEDER_OSPEEDR14_1  ((uint32_t)0x20000000)
S#define GPIO_OSPEEDER_OSPEEDR15    ((uint32_t)0xC0000000)
S#define GPIO_OSPEEDER_OSPEEDR15_0  ((uint32_t)0x40000000)
S#define GPIO_OSPEEDER_OSPEEDR15_1  ((uint32_t)0x80000000)
S
S/*******************  Bit definition for GPIO_PUPDR register ******************/
S#define GPIO_PUPDR_PUPDR0          ((uint32_t)0x00000003)
S#define GPIO_PUPDR_PUPDR0_0        ((uint32_t)0x00000001)
S#define GPIO_PUPDR_PUPDR0_1        ((uint32_t)0x00000002)
S#define GPIO_PUPDR_PUPDR1          ((uint32_t)0x0000000C)
S#define GPIO_PUPDR_PUPDR1_0        ((uint32_t)0x00000004)
S#define GPIO_PUPDR_PUPDR1_1        ((uint32_t)0x00000008)
S#define GPIO_PUPDR_PUPDR2          ((uint32_t)0x00000030)
S#define GPIO_PUPDR_PUPDR2_0        ((uint32_t)0x00000010)
S#define GPIO_PUPDR_PUPDR2_1        ((uint32_t)0x00000020)
S#define GPIO_PUPDR_PUPDR3          ((uint32_t)0x000000C0)
S#define GPIO_PUPDR_PUPDR3_0        ((uint32_t)0x00000040)
S#define GPIO_PUPDR_PUPDR3_1        ((uint32_t)0x00000080)
S#define GPIO_PUPDR_PUPDR4          ((uint32_t)0x00000300)
S#define GPIO_PUPDR_PUPDR4_0        ((uint32_t)0x00000100)
S#define GPIO_PUPDR_PUPDR4_1        ((uint32_t)0x00000200)
S#define GPIO_PUPDR_PUPDR5          ((uint32_t)0x00000C00)
S#define GPIO_PUPDR_PUPDR5_0        ((uint32_t)0x00000400)
S#define GPIO_PUPDR_PUPDR5_1        ((uint32_t)0x00000800)
S#define GPIO_PUPDR_PUPDR6          ((uint32_t)0x00003000)
S#define GPIO_PUPDR_PUPDR6_0        ((uint32_t)0x00001000)
S#define GPIO_PUPDR_PUPDR6_1        ((uint32_t)0x00002000)
S#define GPIO_PUPDR_PUPDR7          ((uint32_t)0x0000C000)
S#define GPIO_PUPDR_PUPDR7_0        ((uint32_t)0x00004000)
S#define GPIO_PUPDR_PUPDR7_1        ((uint32_t)0x00008000)
S#define GPIO_PUPDR_PUPDR8          ((uint32_t)0x00030000)
S#define GPIO_PUPDR_PUPDR8_0        ((uint32_t)0x00010000)
S#define GPIO_PUPDR_PUPDR8_1        ((uint32_t)0x00020000)
S#define GPIO_PUPDR_PUPDR9          ((uint32_t)0x000C0000)
S#define GPIO_PUPDR_PUPDR9_0        ((uint32_t)0x00040000)
S#define GPIO_PUPDR_PUPDR9_1        ((uint32_t)0x00080000)
S#define GPIO_PUPDR_PUPDR10         ((uint32_t)0x00300000)
S#define GPIO_PUPDR_PUPDR10_0       ((uint32_t)0x00100000)
S#define GPIO_PUPDR_PUPDR10_1       ((uint32_t)0x00200000)
S#define GPIO_PUPDR_PUPDR11         ((uint32_t)0x00C00000)
S#define GPIO_PUPDR_PUPDR11_0       ((uint32_t)0x00400000)
S#define GPIO_PUPDR_PUPDR11_1       ((uint32_t)0x00800000)
S#define GPIO_PUPDR_PUPDR12         ((uint32_t)0x03000000)
S#define GPIO_PUPDR_PUPDR12_0       ((uint32_t)0x01000000)
S#define GPIO_PUPDR_PUPDR12_1       ((uint32_t)0x02000000)
S#define GPIO_PUPDR_PUPDR13         ((uint32_t)0x0C000000)
S#define GPIO_PUPDR_PUPDR13_0       ((uint32_t)0x04000000)
S#define GPIO_PUPDR_PUPDR13_1       ((uint32_t)0x08000000)
S#define GPIO_PUPDR_PUPDR14         ((uint32_t)0x30000000)
S#define GPIO_PUPDR_PUPDR14_0       ((uint32_t)0x10000000)
S#define GPIO_PUPDR_PUPDR14_1       ((uint32_t)0x20000000)
S#define GPIO_PUPDR_PUPDR15         ((uint32_t)0xC0000000)
S#define GPIO_PUPDR_PUPDR15_0       ((uint32_t)0x40000000)
S#define GPIO_PUPDR_PUPDR15_1       ((uint32_t)0x80000000)
S
S/*******************  Bit definition for GPIO_IDR register  *******************/
S#define GPIO_IDR_0                 ((uint32_t)0x00000001)
S#define GPIO_IDR_1                 ((uint32_t)0x00000002)
S#define GPIO_IDR_2                 ((uint32_t)0x00000004)
S#define GPIO_IDR_3                 ((uint32_t)0x00000008)
S#define GPIO_IDR_4                 ((uint32_t)0x00000010)
S#define GPIO_IDR_5                 ((uint32_t)0x00000020)
S#define GPIO_IDR_6                 ((uint32_t)0x00000040)
S#define GPIO_IDR_7                 ((uint32_t)0x00000080)
S#define GPIO_IDR_8                 ((uint32_t)0x00000100)
S#define GPIO_IDR_9                 ((uint32_t)0x00000200)
S#define GPIO_IDR_10                ((uint32_t)0x00000400)
S#define GPIO_IDR_11                ((uint32_t)0x00000800)
S#define GPIO_IDR_12                ((uint32_t)0x00001000)
S#define GPIO_IDR_13                ((uint32_t)0x00002000)
S#define GPIO_IDR_14                ((uint32_t)0x00004000)
S#define GPIO_IDR_15                ((uint32_t)0x00008000)
S
S/******************  Bit definition for GPIO_ODR register  ********************/
S#define GPIO_ODR_0                 ((uint32_t)0x00000001)
S#define GPIO_ODR_1                 ((uint32_t)0x00000002)
S#define GPIO_ODR_2                 ((uint32_t)0x00000004)
S#define GPIO_ODR_3                 ((uint32_t)0x00000008)
S#define GPIO_ODR_4                 ((uint32_t)0x00000010)
S#define GPIO_ODR_5                 ((uint32_t)0x00000020)
S#define GPIO_ODR_6                 ((uint32_t)0x00000040)
S#define GPIO_ODR_7                 ((uint32_t)0x00000080)
S#define GPIO_ODR_8                 ((uint32_t)0x00000100)
S#define GPIO_ODR_9                 ((uint32_t)0x00000200)
S#define GPIO_ODR_10                ((uint32_t)0x00000400)
S#define GPIO_ODR_11                ((uint32_t)0x00000800)
S#define GPIO_ODR_12                ((uint32_t)0x00001000)
S#define GPIO_ODR_13                ((uint32_t)0x00002000)
S#define GPIO_ODR_14                ((uint32_t)0x00004000)
S#define GPIO_ODR_15                ((uint32_t)0x00008000)
S
S/****************** Bit definition for GPIO_BSRR register  ********************/
S#define GPIO_BSRR_BS_0             ((uint32_t)0x00000001)
S#define GPIO_BSRR_BS_1             ((uint32_t)0x00000002)
S#define GPIO_BSRR_BS_2             ((uint32_t)0x00000004)
S#define GPIO_BSRR_BS_3             ((uint32_t)0x00000008)
S#define GPIO_BSRR_BS_4             ((uint32_t)0x00000010)
S#define GPIO_BSRR_BS_5             ((uint32_t)0x00000020)
S#define GPIO_BSRR_BS_6             ((uint32_t)0x00000040)
S#define GPIO_BSRR_BS_7             ((uint32_t)0x00000080)
S#define GPIO_BSRR_BS_8             ((uint32_t)0x00000100)
S#define GPIO_BSRR_BS_9             ((uint32_t)0x00000200)
S#define GPIO_BSRR_BS_10            ((uint32_t)0x00000400)
S#define GPIO_BSRR_BS_11            ((uint32_t)0x00000800)
S#define GPIO_BSRR_BS_12            ((uint32_t)0x00001000)
S#define GPIO_BSRR_BS_13            ((uint32_t)0x00002000)
S#define GPIO_BSRR_BS_14            ((uint32_t)0x00004000)
S#define GPIO_BSRR_BS_15            ((uint32_t)0x00008000)
S#define GPIO_BSRR_BR_0             ((uint32_t)0x00010000)
S#define GPIO_BSRR_BR_1             ((uint32_t)0x00020000)
S#define GPIO_BSRR_BR_2             ((uint32_t)0x00040000)
S#define GPIO_BSRR_BR_3             ((uint32_t)0x00080000)
S#define GPIO_BSRR_BR_4             ((uint32_t)0x00100000)
S#define GPIO_BSRR_BR_5             ((uint32_t)0x00200000)
S#define GPIO_BSRR_BR_6             ((uint32_t)0x00400000)
S#define GPIO_BSRR_BR_7             ((uint32_t)0x00800000)
S#define GPIO_BSRR_BR_8             ((uint32_t)0x01000000)
S#define GPIO_BSRR_BR_9             ((uint32_t)0x02000000)
S#define GPIO_BSRR_BR_10            ((uint32_t)0x04000000)
S#define GPIO_BSRR_BR_11            ((uint32_t)0x08000000)
S#define GPIO_BSRR_BR_12            ((uint32_t)0x10000000)
S#define GPIO_BSRR_BR_13            ((uint32_t)0x20000000)
S#define GPIO_BSRR_BR_14            ((uint32_t)0x40000000)
S#define GPIO_BSRR_BR_15            ((uint32_t)0x80000000)
S
S/****************** Bit definition for GPIO_LCKR register  ********************/
S#define GPIO_LCKR_LCK0             ((uint32_t)0x00000001)
S#define GPIO_LCKR_LCK1             ((uint32_t)0x00000002)
S#define GPIO_LCKR_LCK2             ((uint32_t)0x00000004)
S#define GPIO_LCKR_LCK3             ((uint32_t)0x00000008)
S#define GPIO_LCKR_LCK4             ((uint32_t)0x00000010)
S#define GPIO_LCKR_LCK5             ((uint32_t)0x00000020)
S#define GPIO_LCKR_LCK6             ((uint32_t)0x00000040)
S#define GPIO_LCKR_LCK7             ((uint32_t)0x00000080)
S#define GPIO_LCKR_LCK8             ((uint32_t)0x00000100)
S#define GPIO_LCKR_LCK9             ((uint32_t)0x00000200)
S#define GPIO_LCKR_LCK10            ((uint32_t)0x00000400)
S#define GPIO_LCKR_LCK11            ((uint32_t)0x00000800)
S#define GPIO_LCKR_LCK12            ((uint32_t)0x00001000)
S#define GPIO_LCKR_LCK13            ((uint32_t)0x00002000)
S#define GPIO_LCKR_LCK14            ((uint32_t)0x00004000)
S#define GPIO_LCKR_LCK15            ((uint32_t)0x00008000)
S#define GPIO_LCKR_LCKK             ((uint32_t)0x00010000)
S
S/****************** Bit definition for GPIO_AFRL register  ********************/
S#define GPIO_AFRL_AFRL0            ((uint32_t)0x0000000F)
S#define GPIO_AFRL_AFRL1            ((uint32_t)0x000000F0)
S#define GPIO_AFRL_AFRL2            ((uint32_t)0x00000F00)
S#define GPIO_AFRL_AFRL3            ((uint32_t)0x0000F000)
S#define GPIO_AFRL_AFRL4            ((uint32_t)0x000F0000)
S#define GPIO_AFRL_AFRL5            ((uint32_t)0x00F00000)
S#define GPIO_AFRL_AFRL6            ((uint32_t)0x0F000000)
S#define GPIO_AFRL_AFRL7            ((uint32_t)0xF0000000)
S
S/****************** Bit definition for GPIO_AFRH register  ********************/
S#define GPIO_AFRH_AFRH0            ((uint32_t)0x0000000F)
S#define GPIO_AFRH_AFRH1            ((uint32_t)0x000000F0)
S#define GPIO_AFRH_AFRH2            ((uint32_t)0x00000F00)
S#define GPIO_AFRH_AFRH3            ((uint32_t)0x0000F000)
S#define GPIO_AFRH_AFRH4            ((uint32_t)0x000F0000)
S#define GPIO_AFRH_AFRH5            ((uint32_t)0x00F00000)
S#define GPIO_AFRH_AFRH6            ((uint32_t)0x0F000000)
S#define GPIO_AFRH_AFRH7            ((uint32_t)0xF0000000)
S
S/****************** Bit definition for GPIO_BRR register  *********************/
S#define GPIO_BRR_BR_0              ((uint32_t)0x00000001)
S#define GPIO_BRR_BR_1              ((uint32_t)0x00000002)
S#define GPIO_BRR_BR_2              ((uint32_t)0x00000004)
S#define GPIO_BRR_BR_3              ((uint32_t)0x00000008)
S#define GPIO_BRR_BR_4              ((uint32_t)0x00000010)
S#define GPIO_BRR_BR_5              ((uint32_t)0x00000020)
S#define GPIO_BRR_BR_6              ((uint32_t)0x00000040)
S#define GPIO_BRR_BR_7              ((uint32_t)0x00000080)
S#define GPIO_BRR_BR_8              ((uint32_t)0x00000100)
S#define GPIO_BRR_BR_9              ((uint32_t)0x00000200)
S#define GPIO_BRR_BR_10             ((uint32_t)0x00000400)
S#define GPIO_BRR_BR_11             ((uint32_t)0x00000800)
S#define GPIO_BRR_BR_12             ((uint32_t)0x00001000)
S#define GPIO_BRR_BR_13             ((uint32_t)0x00002000)
S#define GPIO_BRR_BR_14             ((uint32_t)0x00004000)
S#define GPIO_BRR_BR_15             ((uint32_t)0x00008000)
S
S/******************************************************************************/
S/*                                                                            */
S/*                      Inter-integrated Circuit Interface (I2C)              */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for I2C_CR1 register  *******************/
S#define  I2C_CR1_PE                          ((uint32_t)0x00000001)        /*!< Peripheral enable */
S#define  I2C_CR1_TXIE                        ((uint32_t)0x00000002)        /*!< TX interrupt enable */
S#define  I2C_CR1_RXIE                        ((uint32_t)0x00000004)        /*!< RX interrupt enable */
S#define  I2C_CR1_ADDRIE                      ((uint32_t)0x00000008)        /*!< Address match interrupt enable */
S#define  I2C_CR1_NACKIE                      ((uint32_t)0x00000010)        /*!< NACK received interrupt enable */
S#define  I2C_CR1_STOPIE                      ((uint32_t)0x00000020)        /*!< STOP detection interrupt enable */
S#define  I2C_CR1_TCIE                        ((uint32_t)0x00000040)        /*!< Transfer complete interrupt enable */
S#define  I2C_CR1_ERRIE                       ((uint32_t)0x00000080)        /*!< Errors interrupt enable */
S#define  I2C_CR1_DFN                         ((uint32_t)0x00000F00)        /*!< Digital noise filter */
S#define  I2C_CR1_ANFOFF                      ((uint32_t)0x00001000)        /*!< Analog noise filter OFF */
S#define  I2C_CR1_SWRST                       ((uint32_t)0x00002000)        /*!< Software reset */
S#define  I2C_CR1_TXDMAEN                     ((uint32_t)0x00004000)        /*!< DMA transmission requests enable */
S#define  I2C_CR1_RXDMAEN                     ((uint32_t)0x00008000)        /*!< DMA reception requests enable */
S#define  I2C_CR1_SBC                         ((uint32_t)0x00010000)        /*!< Slave byte control */
S#define  I2C_CR1_NOSTRETCH                   ((uint32_t)0x00020000)        /*!< Clock stretching disable */
S#define  I2C_CR1_WUPEN                       ((uint32_t)0x00040000)        /*!< Wakeup from STOP enable */
S#define  I2C_CR1_GCEN                        ((uint32_t)0x00080000)        /*!< General call enable */
S#define  I2C_CR1_SMBHEN                      ((uint32_t)0x00100000)        /*!< SMBus host address enable */
S#define  I2C_CR1_SMBDEN                      ((uint32_t)0x00200000)        /*!< SMBus device default address enable */
S#define  I2C_CR1_ALERTEN                     ((uint32_t)0x00400000)        /*!< SMBus alert enable */
S#define  I2C_CR1_PECEN                       ((uint32_t)0x00800000)        /*!< PEC enable */
S
S/******************  Bit definition for I2C_CR2 register  ********************/
S#define  I2C_CR2_SADD                        ((uint32_t)0x000003FF)        /*!< Slave address (master mode) */
S#define  I2C_CR2_RD_WRN                      ((uint32_t)0x00000400)        /*!< Transfer direction (master mode) */
S#define  I2C_CR2_ADD10                       ((uint32_t)0x00000800)        /*!< 10-bit addressing mode (master mode) */
S#define  I2C_CR2_HEAD10R                     ((uint32_t)0x00001000)        /*!< 10-bit address header only read direction (master mode) */
S#define  I2C_CR2_START                       ((uint32_t)0x00002000)        /*!< START generation */
S#define  I2C_CR2_STOP                        ((uint32_t)0x00004000)        /*!< STOP generation (master mode) */
S#define  I2C_CR2_NACK                        ((uint32_t)0x00008000)        /*!< NACK generation (slave mode) */
S#define  I2C_CR2_NBYTES                      ((uint32_t)0x00FF0000)        /*!< Number of bytes */
S#define  I2C_CR2_RELOAD                      ((uint32_t)0x01000000)        /*!< NBYTES reload mode */
S#define  I2C_CR2_AUTOEND                     ((uint32_t)0x02000000)        /*!< Automatic end mode (master mode) */
S#define  I2C_CR2_PECBYTE                     ((uint32_t)0x04000000)        /*!< Packet error checking byte */
S
S/*******************  Bit definition for I2C_OAR1 register  ******************/
S#define  I2C_OAR1_OA1                        ((uint32_t)0x000003FF)        /*!< Interface own address 1 */
S#define  I2C_OAR1_OA1MODE                    ((uint32_t)0x00000400)        /*!< Own address 1 10-bit mode */
S#define  I2C_OAR1_OA1EN                      ((uint32_t)0x00008000)        /*!< Own address 1 enable */
S
S/*******************  Bit definition for I2C_OAR2 register  ******************/
S#define  I2C_OAR2_OA2                        ((uint32_t)0x000000FE)        /*!< Interface own address 2 */
S#define  I2C_OAR2_OA2MSK                     ((uint32_t)0x00000700)        /*!< Own address 2 masks */
S#define  I2C_OAR2_OA2EN                      ((uint32_t)0x00008000)        /*!< Own address 2 enable */
S
S/*******************  Bit definition for I2C_TIMINGR register *******************/
S#define  I2C_TIMINGR_SCLL                    ((uint32_t)0x000000FF)        /*!< SCL low period (master mode) */
S#define  I2C_TIMINGR_SCLH                    ((uint32_t)0x0000FF00)        /*!< SCL high period (master mode) */
S#define  I2C_TIMINGR_SDADEL                  ((uint32_t)0x000F0000)        /*!< Data hold time */
S#define  I2C_TIMINGR_SCLDEL                  ((uint32_t)0x00F00000)        /*!< Data setup time */
S#define  I2C_TIMINGR_PRESC                   ((uint32_t)0xF0000000)        /*!< Timings prescaler */
S
S/******************* Bit definition for I2C_TIMEOUTR register *******************/
S#define  I2C_TIMEOUTR_TIMEOUTA               ((uint32_t)0x00000FFF)        /*!< Bus timeout A */
S#define  I2C_TIMEOUTR_TIDLE                  ((uint32_t)0x00001000)        /*!< Idle clock timeout detection */
S#define  I2C_TIMEOUTR_TIMOUTEN               ((uint32_t)0x00008000)        /*!< Clock timeout enable */
S#define  I2C_TIMEOUTR_TIMEOUTB               ((uint32_t)0x0FFF0000)        /*!< Bus timeout B*/
S#define  I2C_TIMEOUTR_TEXTEN                 ((uint32_t)0x80000000)        /*!< Extended clock timeout enable */
S
S/******************  Bit definition for I2C_ISR register  *********************/
S#define  I2C_ISR_TXE                         ((uint32_t)0x00000001)        /*!< Transmit data register empty */
S#define  I2C_ISR_TXIS                        ((uint32_t)0x00000002)        /*!< Transmit interrupt status */
S#define  I2C_ISR_RXNE                        ((uint32_t)0x00000004)        /*!< Receive data register not empty */
S#define  I2C_ISR_ADDR                        ((uint32_t)0x00000008)        /*!< Address matched (slave mode)*/
S#define  I2C_ISR_NACKF                       ((uint32_t)0x00000010)        /*!< NACK received flag */
S#define  I2C_ISR_STOPF                       ((uint32_t)0x00000020)        /*!< STOP detection flag */
S#define  I2C_ISR_TC                          ((uint32_t)0x00000040)        /*!< Transfer complete (master mode) */
S#define  I2C_ISR_TCR                         ((uint32_t)0x00000080)        /*!< Transfer complete reload */
S#define  I2C_ISR_BERR                        ((uint32_t)0x00000100)        /*!< Bus error */
S#define  I2C_ISR_ARLO                        ((uint32_t)0x00000200)        /*!< Arbitration lost */
S#define  I2C_ISR_OVR                         ((uint32_t)0x00000400)        /*!< Overrun/Underrun */
S#define  I2C_ISR_PECERR                      ((uint32_t)0x00000800)        /*!< PEC error in reception */
S#define  I2C_ISR_TIMEOUT                     ((uint32_t)0x00001000)        /*!< Timeout or Tlow detection flag */
S#define  I2C_ISR_ALERT                       ((uint32_t)0x00002000)        /*!< SMBus alert */
S#define  I2C_ISR_BUSY                        ((uint32_t)0x00008000)        /*!< Bus busy */
S#define  I2C_ISR_DIR                         ((uint32_t)0x00010000)        /*!< Transfer direction (slave mode) */
S#define  I2C_ISR_ADDCODE                     ((uint32_t)0x00FE0000)        /*!< Address match code (slave mode) */
S
S/******************  Bit definition for I2C_ICR register  *********************/
S#define  I2C_ICR_ADDRCF                      ((uint32_t)0x00000008)        /*!< Address matched clear flag */
S#define  I2C_ICR_NACKCF                      ((uint32_t)0x00000010)        /*!< NACK clear flag */
S#define  I2C_ICR_STOPCF                      ((uint32_t)0x00000020)        /*!< STOP detection clear flag */
S#define  I2C_ICR_BERRCF                      ((uint32_t)0x00000100)        /*!< Bus error clear flag */
S#define  I2C_ICR_ARLOCF                      ((uint32_t)0x00000200)        /*!< Arbitration lost clear flag */
S#define  I2C_ICR_OVRCF                       ((uint32_t)0x00000400)        /*!< Overrun/Underrun clear flag */
S#define  I2C_ICR_PECCF                       ((uint32_t)0x00000800)        /*!< PAC error clear flag */
S#define  I2C_ICR_TIMOUTCF                    ((uint32_t)0x00001000)        /*!< Timeout clear flag */
S#define  I2C_ICR_ALERTCF                     ((uint32_t)0x00002000)        /*!< Alert clear flag */
S
S/******************  Bit definition for I2C_PECR register  *********************/
S#define  I2C_PECR_PEC                        ((uint32_t)0x000000FF)        /*!< PEC register */
S
S/******************  Bit definition for I2C_RXDR register  *********************/
S#define  I2C_RXDR_RXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit receive data */
S
S/******************  Bit definition for I2C_TXDR register  *********************/
S#define  I2C_TXDR_TXDATA                     ((uint32_t)0x000000FF)        /*!< 8-bit transmit data */
S
S
S/******************************************************************************/
S/*                                                                            */
S/*                           Independent WATCHDOG (IWDG)                      */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for IWDG_KR register  ********************/
S#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */
S
S/*******************  Bit definition for IWDG_PR register  ********************/
S#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */
S#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */
S#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */
S#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */
S
S/*******************  Bit definition for IWDG_RLR register  *******************/
S#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */
S
S/*******************  Bit definition for IWDG_SR register  ********************/
S#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */
S#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */
S#define  IWDG_SR_WVU                         ((uint8_t)0x04)               /*!< Watchdog counter window value update */
S
S/*******************  Bit definition for IWDG_KR register  ********************/
S#define  IWDG_WINR_WIN                       ((uint16_t)0x0FFF)            /*!< Watchdog counter window value */
S
S/******************************************************************************/
S/*                                                                            */
S/*                          HDMI-CEC (CEC)                                    */
S/*                                                                            */
S/******************************************************************************/
S
S/*******************  Bit definition for CEC_CR register  *********************/
S#define  CEC_CR_CECEN                        ((uint32_t)0x00000001)       /*!< CEC Enable                              */
S#define  CEC_CR_TXSOM                        ((uint32_t)0x00000002)       /*!< CEC Tx Start Of Message                 */
S#define  CEC_CR_TXEOM                        ((uint32_t)0x00000004)       /*!< CEC Tx End Of Message                   */
S
S/*******************  Bit definition for CEC_CFGR register  *******************/
S#define  CEC_CFGR_SFT                        ((uint32_t)0x00000007)       /*!< CEC Signal Free Time                    */
S#define  CEC_CFGR_RXTOL                      ((uint32_t)0x00000008)       /*!< CEC Tolerance                           */
S#define  CEC_CFGR_BRESTP                     ((uint32_t)0x00000010)       /*!< CEC Rx Stop                             */
S#define  CEC_CFGR_BREGEN                     ((uint32_t)0x00000020)       /*!< CEC Bit Rising Error generation         */
S#define  CEC_CFGR_LREGEN                     ((uint32_t)0x00000040)       /*!< CEC Long Period Error generation        */
S#define  CEC_CFGR_SFTOPT                     ((uint32_t)0x00000100)       /*!< CEC Signal Free Time optional           */
S#define  CEC_CFGR_BRDNOGEN                   ((uint32_t)0x00000080)       /*!< CEC Broadcast No error generation       */
S#define  CEC_CFGR_OAR                        ((uint32_t)0x7FFF0000)       /*!< CEC Own Address                         */
S#define  CEC_CFGR_LSTN                       ((uint32_t)0x80000000)       /*!< CEC Listen mode                         */
S
S/*******************  Bit definition for CEC_TXDR register  *******************/
S#define  CEC_TXDR_TXD                        ((uint32_t)0x000000FF)       /*!< CEC Tx Data                              */
S
S/*******************  Bit definition for CEC_RXDR register  *******************/
S#define  CEC_TXDR_RXD                        ((uint32_t)0x000000FF)       /*!< CEC Rx Data                              */
S
S/*******************  Bit definition for CEC_ISR register  ********************/
S#define  CEC_ISR_RXBR                        ((uint32_t)0x00000001)       /*!< CEC Rx-Byte Received                      */
S#define  CEC_ISR_RXEND                       ((uint32_t)0x00000002)       /*!< CEC End Of Reception                      */
S#define  CEC_ISR_RXOVR                       ((uint32_t)0x00000004)       /*!< CEC Rx-Overrun                            */
S#define  CEC_ISR_BRE                         ((uint32_t)0x00000008)       /*!< CEC Rx Bit Rising Error                   */
S#define  CEC_ISR_SBPE                        ((uint32_t)0x00000010)       /*!< CEC Rx Short Bit period Error             */
S#define  CEC_ISR_LBPE                        ((uint32_t)0x00000020)       /*!< CEC Rx Long Bit period Error              */
S#define  CEC_ISR_RXACKE                      ((uint32_t)0x00000040)       /*!< CEC Rx Missing Acknowledge                */
S#define  CEC_ISR_ARBLST                      ((uint32_t)0x00000080)       /*!< CEC Arbitration Lost                      */
S#define  CEC_ISR_TXBR                        ((uint32_t)0x00000100)       /*!< CEC Tx Byte Request                       */
S#define  CEC_ISR_TXEND                       ((uint32_t)0x00000200)       /*!< CEC End of Transmission                   */
S#define  CEC_ISR_TXUDR                       ((uint32_t)0x00000400)       /*!< CEC Tx-Buffer Underrun                    */
S#define  CEC_ISR_TXERR                       ((uint32_t)0x00000800)       /*!< CEC Tx-Error                              */
S#define  CEC_ISR_TXACKE                      ((uint32_t)0x00001000)       /*!< CEC Tx Missing Acknowledge                */
S
S/*******************  Bit definition for CEC_IER register  ********************/
S#define  CEC_IER_RXBRIE                      ((uint32_t)0x00000001)       /*!< CEC Rx-Byte Received IT Enable            */
S#define  CEC_IER_RXENDIE                     ((uint32_t)0x00000002)       /*!< CEC End Of Reception IT Enable            */
S#define  CEC_IER_RXOVRIE                     ((uint32_t)0x00000004)       /*!< CEC Rx-Overrun IT Enable                  */
S#define  CEC_IER_BREIEIE                     ((uint32_t)0x00000008)       /*!< CEC Rx Bit Rising Error IT Enable         */
S#define  CEC_IER_SBPEIE                      ((uint32_t)0x00000010)       /*!< CEC Rx Short Bit period Error IT Enable   */
S#define  CEC_IER_LBPEIE                      ((uint32_t)0x00000020)       /*!< CEC Rx Long Bit period Error IT Enable    */
S#define  CEC_IER_RXACKEIE                    ((uint32_t)0x00000040)       /*!< CEC Rx Missing Acknowledge IT Enable      */
S#define  CEC_IER_ARBLSTIE                    ((uint32_t)0x00000080)       /*!< CEC Arbitration Lost IT Enable            */
S#define  CEC_IER_TXBRIE                      ((uint32_t)0x00000100)       /*!< CEC Tx Byte Request  IT Enable            */
S#define  CEC_IER_TXENDIE                     ((uint32_t)0x00000200)       /*!< CEC End of Transmission IT Enable         */
S#define  CEC_IER_TXUDRIE                     ((uint32_t)0x00000400)       /*!< CEC Tx-Buffer Underrun IT Enable          */
S#define  CEC_IER_TXERRIE                     ((uint32_t)0x00000800)       /*!< CEC Tx-Error IT Enable                    */
S#define  CEC_IER_TXACKEIE                    ((uint32_t)0x00001000)       /*!< CEC Tx Missing Acknowledge IT Enable      */
S
S/******************************************************************************/
S/*                                                                            */
S/*                             Power Control                                  */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for PWR_CR register  ********************/
S#define  PWR_CR_LPSDSR                       ((uint16_t)0x0001)     /*!< Low-power deepsleep/sleep/low power run */
S#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */
S#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */
S#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */
S#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */
S
S#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */
S#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */
S#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */
S#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */
S
S/*!< PVD level configuration */
S#define  PWR_CR_PLS_LEV0                     ((uint16_t)0x0000)     /*!< PVD level 0 */
S#define  PWR_CR_PLS_LEV1                     ((uint16_t)0x0020)     /*!< PVD level 1 */
S#define  PWR_CR_PLS_LEV2                     ((uint16_t)0x0040)     /*!< PVD level 2 */
S#define  PWR_CR_PLS_LEV3                     ((uint16_t)0x0060)     /*!< PVD level 3 */
S#define  PWR_CR_PLS_LEV4                     ((uint16_t)0x0080)     /*!< PVD level 4 */
S#define  PWR_CR_PLS_LEV5                     ((uint16_t)0x00A0)     /*!< PVD level 5 */
S#define  PWR_CR_PLS_LEV6                     ((uint16_t)0x00C0)     /*!< PVD level 6 */
S#define  PWR_CR_PLS_LEV7                     ((uint16_t)0x00E0)     /*!< PVD level 7 */
S
S#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */
S#define  PWR_CR_SDADC1EN                     ((uint16_t)0x0200)     /*!< Enable Analog part of the SDADC1 */
S#define  PWR_CR_SDADC2EN                     ((uint16_t)0x0400)     /*!< Enable Analog part of the SDADC2 */
S#define  PWR_CR_SDADC3EN                     ((uint16_t)0x0800)     /*!< Enable Analog part of the SDADC3 */
S
S/*******************  Bit definition for PWR_CSR register  ********************/
S#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */
S#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */
S#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */
S#define  PWR_CSR_VREFINTRDYF                 ((uint16_t)0x0008)     /*!< Internal voltage reference (VREFINT) ready flag */
S
S#define  PWR_CSR_EWUP1                       ((uint16_t)0x0100)     /*!< Enable WKUP pin 1 */
S#define  PWR_CSR_EWUP2                       ((uint16_t)0x0200)     /*!< Enable WKUP pin 2 */
S#define  PWR_CSR_EWUP3                       ((uint16_t)0x0400)     /*!< Enable WKUP pin 3 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                         Reset and Clock Control                            */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bit definition for RCC_CR register  ********************/
S#define  RCC_CR_HSION                        ((uint32_t)0x00000001)
S#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)
S
S#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)
S#define  RCC_CR_HSITRIM_0                    ((uint32_t)0x00000008)/*!<Bit 0 */
S#define  RCC_CR_HSITRIM_1                    ((uint32_t)0x00000010)/*!<Bit 1 */
S#define  RCC_CR_HSITRIM_2                    ((uint32_t)0x00000020)/*!<Bit 2 */
S#define  RCC_CR_HSITRIM_3                    ((uint32_t)0x00000040)/*!<Bit 3 */
S#define  RCC_CR_HSITRIM_4                    ((uint32_t)0x00000080)/*!<Bit 4 */
S
S#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)
S#define  RCC_CR_HSICAL_0                     ((uint32_t)0x00000100)/*!<Bit 0 */
S#define  RCC_CR_HSICAL_1                     ((uint32_t)0x00000200)/*!<Bit 1 */
S#define  RCC_CR_HSICAL_2                     ((uint32_t)0x00000400)/*!<Bit 2 */
S#define  RCC_CR_HSICAL_3                     ((uint32_t)0x00000800)/*!<Bit 3 */
S#define  RCC_CR_HSICAL_4                     ((uint32_t)0x00001000)/*!<Bit 4 */
S#define  RCC_CR_HSICAL_5                     ((uint32_t)0x00002000)/*!<Bit 5 */
S#define  RCC_CR_HSICAL_6                     ((uint32_t)0x00004000)/*!<Bit 6 */
S#define  RCC_CR_HSICAL_7                     ((uint32_t)0x00008000)/*!<Bit 7 */
S
S#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)
S#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)
S#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)
S#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)
S#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)
S#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)
S
S/********************  Bit definition for RCC_CFGR register  ******************/
S/*!< SW configuration */
S#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */
S#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */
S
S#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */
S#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */
S#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */
S
S/*!< SWS configuration */
S#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */
S#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */
S#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */
S
S#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */
S#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */
S#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */
S
S/*!< HPRE configuration */
S#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */
S#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */
S#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */
S#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */
S#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */
S
S#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */
S#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */
S#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */
S#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */
S#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */
S#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */
S#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */
S#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */
S#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */
S
S/*!< PPRE1 configuration */
S#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */
S#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */
S#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */
S
S#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
S#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */
S#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */
S#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */
S#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */
S
S/*!< PPRE2 configuration */
S#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */
S#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */
S#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */
S#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */
S
S#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */
S#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */
S#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */
S#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */
S#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */
S
S/*!< ADCPRE configuration */
S#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x0000C000)
S#define  RCC_CFGR_ADCPRE_0                   ((uint32_t)0x00004000)
S#define  RCC_CFGR_ADCPRE_1                   ((uint32_t)0x00008000)
S
S#define  RCC_CFGR_ADCPRE_DIV2                ((uint32_t)0x00000000)        /*!< ADC CLK divided by 2 */
S#define  RCC_CFGR_ADCPRE_DIV4                ((uint32_t)0x00004000)        /*!< ADC CLK divided by 4 */
S#define  RCC_CFGR_ADCPRE_DIV6                ((uint32_t)0x00008000)        /*!< ADC CLK divided by 6 */
S#define  RCC_CFGR_ADCPRE_DIV8                ((uint32_t)0x0000C000)        /*!< ADC CLK divided by 8 */
S
S#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */
S
S#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */
S
S/*!< PLLMUL configuration */
S#define  RCC_CFGR_PLLMULL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */
S#define  RCC_CFGR_PLLMULL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  RCC_CFGR_PLLMULL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */
S#define  RCC_CFGR_PLLMULL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */
S#define  RCC_CFGR_PLLMULL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */
S
S#define  RCC_CFGR_PLLSRC_HSI_Div2            ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */
S#define  RCC_CFGR_PLLSRC_PREDIV1             ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */
S
S#define  RCC_CFGR_PLLXTPRE_PREDIV1           ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */
S#define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2      ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */
S
S#define  RCC_CFGR_PLLMULL2                   ((uint32_t)0x00000000)        /*!< PLL input clock*2 */
S#define  RCC_CFGR_PLLMULL3                   ((uint32_t)0x00040000)        /*!< PLL input clock*3 */
S#define  RCC_CFGR_PLLMULL4                   ((uint32_t)0x00080000)        /*!< PLL input clock*4 */
S#define  RCC_CFGR_PLLMULL5                   ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */
S#define  RCC_CFGR_PLLMULL6                   ((uint32_t)0x00100000)        /*!< PLL input clock*6 */
S#define  RCC_CFGR_PLLMULL7                   ((uint32_t)0x00140000)        /*!< PLL input clock*7 */
S#define  RCC_CFGR_PLLMULL8                   ((uint32_t)0x00180000)        /*!< PLL input clock*8 */
S#define  RCC_CFGR_PLLMULL9                   ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */
S#define  RCC_CFGR_PLLMULL10                  ((uint32_t)0x00200000)        /*!< PLL input clock10 */
S#define  RCC_CFGR_PLLMULL11                  ((uint32_t)0x00240000)        /*!< PLL input clock*11 */
S#define  RCC_CFGR_PLLMULL12                  ((uint32_t)0x00280000)        /*!< PLL input clock*12 */
S#define  RCC_CFGR_PLLMULL13                  ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */
S#define  RCC_CFGR_PLLMULL14                  ((uint32_t)0x00300000)        /*!< PLL input clock*14 */
S#define  RCC_CFGR_PLLMULL15                  ((uint32_t)0x00340000)        /*!< PLL input clock*15 */
S#define  RCC_CFGR_PLLMULL16                  ((uint32_t)0x00380000)        /*!< PLL input clock*16 */
S
S/*!< USB configuration */
S#define  RCC_CFGR_USBPRE                     ((uint32_t)0x00400000)        /*!< USB prescaler */
S
S/*!< MCO configuration */
S#define  RCC_CFGR_MCO                        ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */
S#define  RCC_CFGR_MCO_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */
S#define  RCC_CFGR_MCO_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */
S#define  RCC_CFGR_MCO_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */
S
S#define  RCC_CFGR_MCO_NOCLOCK                ((uint32_t)0x00000000)        /*!< No clock */
S#define  RCC_CFGR_MCO_LSI                    ((uint32_t)0x02000000)        /*!< LSI clock selected as MCO source */
S#define  RCC_CFGR_MCO_LSE                    ((uint32_t)0x03000000)        /*!< LSE clock selected as MCO source */
S#define  RCC_CFGR_MCO_SYSCLK                 ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */
S#define  RCC_CFGR_MCO_HSI                    ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */
S#define  RCC_CFGR_MCO_HSE                    ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */
S#define  RCC_CFGR_MCO_PLL                    ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */
S
S/*!< SDADCPRE configuration */
S#define  RCC_CFGR_SDADCPRE                   ((uint32_t)0xF8000000)        /*!< SDADCPRE[4:0] bits (Sigma Delta ADC prescaler) */
S#define  RCC_CFGR_SDADCPRE_0                 ((uint32_t)0x08000000)        /*!< Bit 0 */
S#define  RCC_CFGR_SDADCPRE_1                 ((uint32_t)0x10000000)        /*!< Bit 1 */
S#define  RCC_CFGR_SDADCPRE_2                 ((uint32_t)0x20000000)        /*!< Bit 2 */
S#define  RCC_CFGR_SDADCPRE_3                 ((uint32_t)0x40000000)        /*!< Bit 3 */
S#define  RCC_CFGR_SDADCPRE_4                 ((uint32_t)0x80000000)        /*!< Bit 4 */
S
S#define  RCC_CFGR_SDADCPRE_DIV1              ((uint32_t)0x00000000)        /*!< SDADC CLK not divided */
S#define  RCC_CFGR_SDADCPRE_DIV2              ((uint32_t)0x80000000)        /*!< SDADC CLK divided by 2 */
S#define  RCC_CFGR_SDADCPRE_DIV4              ((uint32_t)0x88000000)        /*!< SDADC CLK divided by 4 */
S#define  RCC_CFGR_SDADCPRE_DIV6              ((uint32_t)0x90000000)        /*!< SDADC CLK divided by 6 */
S#define  RCC_CFGR_SDADCPRE_DIV8              ((uint32_t)0x98000000)        /*!< SDADC CLK divided by 8 */
S#define  RCC_CFGR_SDADCPRE_DIV10             ((uint32_t)0xA0000000)        /*!< SDADC CLK divided by 10 */
S#define  RCC_CFGR_SDADCPRE_DIV12             ((uint32_t)0xA8000000)        /*!< SDADC CLK divided by 12 */
S#define  RCC_CFGR_SDADCPRE_DIV14             ((uint32_t)0xB0000000)        /*!< SDADC CLK divided by 14 */
S#define  RCC_CFGR_SDADCPRE_DIV16             ((uint32_t)0xB8000000)        /*!< SDADC CLK divided by 16 */
S#define  RCC_CFGR_SDADCPRE_DIV20             ((uint32_t)0xC0000000)        /*!< SDADC CLK divided by 20 */
S#define  RCC_CFGR_SDADCPRE_DIV24             ((uint32_t)0xC8000000)        /*!< SDADC CLK divided by 24 */
S#define  RCC_CFGR_SDADCPRE_DIV28             ((uint32_t)0xD0000000)        /*!< SDADC CLK divided by 28 */
S#define  RCC_CFGR_SDADCPRE_DIV32             ((uint32_t)0xD8000000)        /*!< SDADC CLK divided by 32 */
S#define  RCC_CFGR_SDADCPRE_DIV36             ((uint32_t)0xE0000000)        /*!< SDADC CLK divided by 36 */
S#define  RCC_CFGR_SDADCPRE_DIV40             ((uint32_t)0xE8000000)        /*!< SDADC CLK divided by 40 */
S#define  RCC_CFGR_SDADCPRE_DIV44             ((uint32_t)0xF0000000)        /*!< SDADC CLK divided by 44 */
S#define  RCC_CFGR_SDADCPRE_DIV48             ((uint32_t)0xF8000000)        /*!< SDADC CLK divided by 48 */
S
S/*********************  Bit definition for RCC_CIR register  ********************/
S#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */
S#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */
S#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */
S#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */
S#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */
S#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */
S#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */
S#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */
S#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */
S#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */
S#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */
S#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */
S#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */
S#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */
S#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */
S#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */
S#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */
S
S/******************  Bit definition for RCC_APB2RSTR register  *****************/
S#define  RCC_APB2RSTR_SYSCFGRST              ((uint32_t)0x00000001)        /*!< SYSCFG reset */
S#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC1 reset */
S#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI1 reset */
S#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */
S#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 reset */
S#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 reset */
S#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 reset */
S#define  RCC_APB2RSTR_TIM19RST               ((uint32_t)0x00080000)        /*!< TIM19 reset */
S#define  RCC_APB2RSTR_SDADC1RST              ((uint32_t)0x01000000)        /*!< SDADC1 reset */
S#define  RCC_APB2RSTR_SDADC2RST              ((uint32_t)0x02000000)        /*!< SDADC2 reset */
S#define  RCC_APB2RSTR_SDADC3RST              ((uint32_t)0x04000000)        /*!< SDADC3 reset */
S
S/******************  Bit definition for RCC_APB1RSTR register  ******************/
S#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */
S#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */
S#define  RCC_APB1RSTR_TIM4RST                ((uint32_t)0x00000004)        /*!< Timer 4 reset */
S#define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */
S#define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */
S#define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */
S#define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)        /*!< Timer 12 reset */
S#define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)        /*!< Timer 13 reset */
S#define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< Timer 14 reset */
S#define  RCC_APB1RSTR_TIM18RST               ((uint32_t)0x00000200)        /*!< Timer 18 reset */
S#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */
S#define  RCC_APB1RSTR_SPI2RST                ((uint32_t)0x00004000)        /*!< SPI2 reset */
S#define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI3 reset */
S#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */
S#define  RCC_APB1RSTR_USART3RST              ((uint32_t)0x00040000)        /*!< USART 3 reset */
S#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */
S#define  RCC_APB1RSTR_I2C2RST                ((uint32_t)0x00400000)        /*!< I2C 2 reset */
S#define  RCC_APB1RSTR_USBRST                 ((uint32_t)0x00800000)        /*!< USB reset */
S#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)        /*!< CAN reset */
S#define  RCC_APB1RSTR_DAC2RST                ((uint32_t)0x04000000)        /*!< DAC 2 reset */
S#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< PWR reset */
S#define  RCC_APB1RSTR_DAC1RST                ((uint32_t)0x20000000)        /*!< DAC 1 reset */
S#define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC reset */
S
S/******************  Bit definition for RCC_AHBENR register  ******************/
S#define  RCC_AHBENR_DMA1EN                   ((uint32_t)0x00000001)        /*!< DMA1 clock enable */
S#define  RCC_AHBENR_DMA2EN                   ((uint32_t)0x00000002)        /*!< DMA2 clock enable */
S#define  RCC_AHBENR_SRAMEN                   ((uint32_t)0x00000004)        /*!< SRAM interface clock enable */
S#define  RCC_AHBENR_FLITFEN                  ((uint32_t)0x00000010)        /*!< FLITF clock enable */
S#define  RCC_AHBENR_CRCEN                    ((uint32_t)0x00000040)        /*!< CRC clock enable */
S#define  RCC_AHBENR_GPIOAEN                  ((uint32_t)0x00020000)        /*!< GPIOA clock enable */
S#define  RCC_AHBENR_GPIOBEN                  ((uint32_t)0x00040000)        /*!< GPIOB clock enable */
S#define  RCC_AHBENR_GPIOCEN                  ((uint32_t)0x00080000)        /*!< GPIOC clock enable */
S#define  RCC_AHBENR_GPIODEN                  ((uint32_t)0x00100000)        /*!< GPIOD clock enable */
S#define  RCC_AHBENR_GPIOEEN                  ((uint32_t)0x00200000)        /*!< GPIOE clock enable */
S#define  RCC_AHBENR_GPIOFEN                  ((uint32_t)0x00400000)        /*!< GPIOF clock enable */
S
S#define  RCC_AHBENR_TSEN                     ((uint32_t)0x01000000)        /*!< TS clock enable */
S
S/*****************  Bit definition for RCC_APB2ENR register  ******************/
S#define  RCC_APB2ENR_SYSCFGEN                ((uint32_t)0x00000001)        /*!< SYSCFG clock enable */
S#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)        /*!< ADC1 clock enable */
S#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)        /*!< SPI1 clock enable */
S#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)        /*!< USART1 clock enable */
S#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)        /*!< TIM15 clock enable */
S#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)        /*!< TIM16 clock enable */
S#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)        /*!< TIM17 clock enable */
S#define  RCC_APB2ENR_TIM19EN                 ((uint32_t)0x00080000)        /*!< TIM19 clock enable */
S#define  RCC_APB2ENR_SDADC1EN                ((uint32_t)0x01000000)        /*!< SDADC1 clock enable */
S#define  RCC_APB2ENR_SDADC2EN                ((uint32_t)0x02000000)        /*!< SDADC2 clock enable */
S#define  RCC_APB2ENR_SDADC3EN                ((uint32_t)0x04000000)        /*!< SDADC3 clock enable */
S
S/******************  Bit definition for RCC_APB1ENR register  ******************/
S#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enable */
S#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */
S#define  RCC_APB1ENR_TIM4EN                  ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */
S#define  RCC_APB1ENR_TIM5EN                  ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */
S#define  RCC_APB1ENR_TIM6EN                  ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */
S#define  RCC_APB1ENR_TIM7EN                  ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */
S#define  RCC_APB1ENR_TIM12EN                 ((uint32_t)0x00000040)        /*!< Timer 12 clock enable */
S#define  RCC_APB1ENR_TIM13EN                 ((uint32_t)0x00000080)        /*!< Timer 13 clock enable */
S#define  RCC_APB1ENR_TIM14EN                 ((uint32_t)0x00000100)        /*!< Timer 14 clock enable */
S#define  RCC_APB1ENR_TIM18EN                 ((uint32_t)0x00000200)        /*!< Timer 18 clock enable */
S#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */
S#define  RCC_APB1ENR_SPI2EN                  ((uint32_t)0x00004000)        /*!< SPI2 clock enable */
S#define  RCC_APB1ENR_SPI3EN                  ((uint32_t)0x00008000)        /*!< SPI3 clock enable */
S#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */
S#define  RCC_APB1ENR_USART3EN                ((uint32_t)0x00040000)        /*!< USART 3 clock enable */
S#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */
S#define  RCC_APB1ENR_I2C2EN                  ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */
S#define  RCC_APB1ENR_USBEN                   ((uint32_t)0x00800000)        /*!< USB clock enable */
S#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)        /*!< CAN clock enable */
S#define  RCC_APB1ENR_DAC2EN                  ((uint32_t)0x04000000)        /*!< DAC 2 clock enable */
S#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< PWR clock enable */
S#define  RCC_APB1ENR_DAC1EN                  ((uint32_t)0x20000000)        /*!< DAC 1 clock enable */
S#define  RCC_APB1ENR_CECEN                   ((uint32_t)0x40000000)        /*!< CEC clock enable */
S
S/********************  Bit definition for RCC_BDCR register  ******************/
S#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */
S#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */
S#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */
S
S#define  RCC_BDCR_LSEDRV                     ((uint32_t)0x00000018)        /*!< LSEDRV[1:0] bits (LSE Osc. drive capability) */
S#define  RCC_BDCR_LSEDRV_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */
S#define  RCC_BDCR_LSEDRV_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */
S
S
S#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */
S#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */
S#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */
S
S/*!< RTC configuration */
S#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */
S#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */
S#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */
S#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 32 used as RTC clock */
S
S#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */
S#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */
S
S/********************  Bit definition for RCC_CSR register  *******************/
S#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */
S#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */
S#define  RCC_CSR_V18PWRRSTF                  ((uint32_t)0x00800000)        /*!< V1.8 power domain reset flag */
S#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */
S#define  RCC_CSR_OBL                         ((uint32_t)0x02000000)        /*!< OBL reset flag */
S#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */
S#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */
S#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */
S#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */
S#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */
S#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */
S
S/*******************  Bit definition for RCC_AHBRSTR register  ****************/
S#define  RCC_AHBRSTR_GPIOARST                ((uint32_t)0x00020000)         /*!< GPIOA reset */
S#define  RCC_AHBRSTR_GPIOBRST                ((uint32_t)0x00040000)         /*!< GPIOB reset */
S#define  RCC_AHBRSTR_GPIOCRST                ((uint32_t)0x00080000)         /*!< GPIOC reset */
S#define  RCC_AHBRSTR_GPIODRST                ((uint32_t)0x00010000)         /*!< GPIOD reset */
S#define  RCC_AHBRSTR_GPIOFRST                ((uint32_t)0x00040000)         /*!< GPIOF reset */
S#define  RCC_AHBRSTR_TSRST                   ((uint32_t)0x00100000)         /*!< TS reset */
S
S/*******************  Bit definition for RCC_CFGR2 register  ******************/
S/*!< PREDIV1 configuration */
S#define  RCC_CFGR2_PREDIV1                   ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */
S#define  RCC_CFGR2_PREDIV1_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  RCC_CFGR2_PREDIV1_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */
S#define  RCC_CFGR2_PREDIV1_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */
S#define  RCC_CFGR2_PREDIV1_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */
S
S#define  RCC_CFGR2_PREDIV1_DIV1              ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */
S#define  RCC_CFGR2_PREDIV1_DIV2              ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */
S#define  RCC_CFGR2_PREDIV1_DIV3              ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */
S#define  RCC_CFGR2_PREDIV1_DIV4              ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */
S#define  RCC_CFGR2_PREDIV1_DIV5              ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */
S#define  RCC_CFGR2_PREDIV1_DIV6              ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */
S#define  RCC_CFGR2_PREDIV1_DIV7              ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */
S#define  RCC_CFGR2_PREDIV1_DIV8              ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */
S#define  RCC_CFGR2_PREDIV1_DIV9              ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */
S#define  RCC_CFGR2_PREDIV1_DIV10             ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */
S#define  RCC_CFGR2_PREDIV1_DIV11             ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */
S#define  RCC_CFGR2_PREDIV1_DIV12             ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */
S#define  RCC_CFGR2_PREDIV1_DIV13             ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */
S#define  RCC_CFGR2_PREDIV1_DIV14             ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */
S#define  RCC_CFGR2_PREDIV1_DIV15             ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */
S#define  RCC_CFGR2_PREDIV1_DIV16             ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */
S
S/*******************  Bit definition for RCC_CFGR3 register  ******************/
S#define  RCC_CFGR3_USART1SW                  ((uint32_t)0x00000003)        /*!< USART1SW[1:0] bits */
S#define  RCC_CFGR3_USART1SW_0                ((uint32_t)0x00000001)        /*!< Bit 0 */
S#define  RCC_CFGR3_USART1SW_1                ((uint32_t)0x00000002)        /*!< Bit 1 */
S
S#define  RCC_CFGR3_I2CSW                     ((uint32_t)0x00000030)        /*!< I2CSW bits */
S#define  RCC_CFGR3_I2C1SW                    ((uint32_t)0x00000010)        /*!< I2C1SW bits */ 
S#define  RCC_CFGR3_I2C2SW                    ((uint32_t)0x00000020)        /*!< I2C2SW bits */
S#define  RCC_CFGR3_CECSW                     ((uint32_t)0x00000040)        /*!< CECSW bits */ 
S
S#define  RCC_CFGR3_USART2SW                  ((uint32_t)0x00030000)        /*!< USART2SW[1:0] bits */
S#define  RCC_CFGR3_USART2SW_0                ((uint32_t)0x00010000)        /*!< Bit 0 */
S#define  RCC_CFGR3_USART2SW_1                ((uint32_t)0x00020000)        /*!< Bit 1 */
S
S#define  RCC_CFGR3_USART3SW                  ((uint32_t)0x000C0000)        /*!< USART3SW[1:0] bits */
S#define  RCC_CFGR3_USART3SW_0                ((uint32_t)0x00040000)        /*!< Bit 0 */
S#define  RCC_CFGR3_USART3SW_1                ((uint32_t)0x00080000)        /*!< Bit 1 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                           Real-Time Clock (RTC)                            */
S/*                                                                            */
S/******************************************************************************/
S/********************  Bits definition for RTC_TR register  *******************/
S#define RTC_TR_PM                            ((uint32_t)0x00400000)
S#define RTC_TR_HT                            ((uint32_t)0x00300000)
S#define RTC_TR_HT_0                          ((uint32_t)0x00100000)
S#define RTC_TR_HT_1                          ((uint32_t)0x00200000)
S#define RTC_TR_HU                            ((uint32_t)0x000F0000)
S#define RTC_TR_HU_0                          ((uint32_t)0x00010000)
S#define RTC_TR_HU_1                          ((uint32_t)0x00020000)
S#define RTC_TR_HU_2                          ((uint32_t)0x00040000)
S#define RTC_TR_HU_3                          ((uint32_t)0x00080000)
S#define RTC_TR_MNT                           ((uint32_t)0x00007000)
S#define RTC_TR_MNT_0                         ((uint32_t)0x00001000)
S#define RTC_TR_MNT_1                         ((uint32_t)0x00002000)
S#define RTC_TR_MNT_2                         ((uint32_t)0x00004000)
S#define RTC_TR_MNU                           ((uint32_t)0x00000F00)
S#define RTC_TR_MNU_0                         ((uint32_t)0x00000100)
S#define RTC_TR_MNU_1                         ((uint32_t)0x00000200)
S#define RTC_TR_MNU_2                         ((uint32_t)0x00000400)
S#define RTC_TR_MNU_3                         ((uint32_t)0x00000800)
S#define RTC_TR_ST                            ((uint32_t)0x00000070)
S#define RTC_TR_ST_0                          ((uint32_t)0x00000010)
S#define RTC_TR_ST_1                          ((uint32_t)0x00000020)
S#define RTC_TR_ST_2                          ((uint32_t)0x00000040)
S#define RTC_TR_SU                            ((uint32_t)0x0000000F)
S#define RTC_TR_SU_0                          ((uint32_t)0x00000001)
S#define RTC_TR_SU_1                          ((uint32_t)0x00000002)
S#define RTC_TR_SU_2                          ((uint32_t)0x00000004)
S#define RTC_TR_SU_3                          ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_DR register  *******************/
S#define RTC_DR_YT                            ((uint32_t)0x00F00000)
S#define RTC_DR_YT_0                          ((uint32_t)0x00100000)
S#define RTC_DR_YT_1                          ((uint32_t)0x00200000)
S#define RTC_DR_YT_2                          ((uint32_t)0x00400000)
S#define RTC_DR_YT_3                          ((uint32_t)0x00800000)
S#define RTC_DR_YU                            ((uint32_t)0x000F0000)
S#define RTC_DR_YU_0                          ((uint32_t)0x00010000)
S#define RTC_DR_YU_1                          ((uint32_t)0x00020000)
S#define RTC_DR_YU_2                          ((uint32_t)0x00040000)
S#define RTC_DR_YU_3                          ((uint32_t)0x00080000)
S#define RTC_DR_WDU                           ((uint32_t)0x0000E000)
S#define RTC_DR_WDU_0                         ((uint32_t)0x00002000)
S#define RTC_DR_WDU_1                         ((uint32_t)0x00004000)
S#define RTC_DR_WDU_2                         ((uint32_t)0x00008000)
S#define RTC_DR_MT                            ((uint32_t)0x00001000)
S#define RTC_DR_MU                            ((uint32_t)0x00000F00)
S#define RTC_DR_MU_0                          ((uint32_t)0x00000100)
S#define RTC_DR_MU_1                          ((uint32_t)0x00000200)
S#define RTC_DR_MU_2                          ((uint32_t)0x00000400)
S#define RTC_DR_MU_3                          ((uint32_t)0x00000800)
S#define RTC_DR_DT                            ((uint32_t)0x00000030)
S#define RTC_DR_DT_0                          ((uint32_t)0x00000010)
S#define RTC_DR_DT_1                          ((uint32_t)0x00000020)
S#define RTC_DR_DU                            ((uint32_t)0x0000000F)
S#define RTC_DR_DU_0                          ((uint32_t)0x00000001)
S#define RTC_DR_DU_1                          ((uint32_t)0x00000002)
S#define RTC_DR_DU_2                          ((uint32_t)0x00000004)
S#define RTC_DR_DU_3                          ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_CR register  *******************/
S#define RTC_CR_COE                           ((uint32_t)0x00800000)
S#define RTC_CR_OSEL                          ((uint32_t)0x00600000)
S#define RTC_CR_OSEL_0                        ((uint32_t)0x00200000)
S#define RTC_CR_OSEL_1                        ((uint32_t)0x00400000)
S#define RTC_CR_POL                           ((uint32_t)0x00100000)
S#define RTC_CR_COSEL                         ((uint32_t)0x00080000)
S#define RTC_CR_BCK                           ((uint32_t)0x00040000)
S#define RTC_CR_SUB1H                         ((uint32_t)0x00020000)
S#define RTC_CR_ADD1H                         ((uint32_t)0x00010000)
S#define RTC_CR_TSIE                          ((uint32_t)0x00008000)
S#define RTC_CR_WUTIE                         ((uint32_t)0x00004000)
S#define RTC_CR_ALRBIE                        ((uint32_t)0x00002000)
S#define RTC_CR_ALRAIE                        ((uint32_t)0x00001000)
S#define RTC_CR_TSE                           ((uint32_t)0x00000800)
S#define RTC_CR_WUTE                          ((uint32_t)0x00000400)
S#define RTC_CR_ALRBE                         ((uint32_t)0x00000200)
S#define RTC_CR_ALRAE                         ((uint32_t)0x00000100)
S#define RTC_CR_FMT                           ((uint32_t)0x00000040)
S#define RTC_CR_BYPSHAD                       ((uint32_t)0x00000020)
S#define RTC_CR_REFCKON                       ((uint32_t)0x00000010)
S#define RTC_CR_TSEDGE                        ((uint32_t)0x00000008)
S#define RTC_CR_WUCKSEL                       ((uint32_t)0x00000007)
S#define RTC_CR_WUCKSEL_0                     ((uint32_t)0x00000001)
S#define RTC_CR_WUCKSEL_1                     ((uint32_t)0x00000002)
S#define RTC_CR_WUCKSEL_2                     ((uint32_t)0x00000004)
S
S/********************  Bits definition for RTC_ISR register  ******************/
S#define RTC_ISR_RECALPF                      ((uint32_t)0x00010000)
S#define RTC_ISR_TAMP3F                       ((uint32_t)0x00008000)
S#define RTC_ISR_TAMP2F                       ((uint32_t)0x00004000)
S#define RTC_ISR_TAMP1F                       ((uint32_t)0x00002000)
S#define RTC_ISR_TSOVF                        ((uint32_t)0x00001000)
S#define RTC_ISR_TSF                          ((uint32_t)0x00000800)
S#define RTC_ISR_WUTF                         ((uint32_t)0x00000400)
S#define RTC_ISR_ALRBF                        ((uint32_t)0x00000200)
S#define RTC_ISR_ALRAF                        ((uint32_t)0x00000100)
S#define RTC_ISR_INIT                         ((uint32_t)0x00000080)
S#define RTC_ISR_INITF                        ((uint32_t)0x00000040)
S#define RTC_ISR_RSF                          ((uint32_t)0x00000020)
S#define RTC_ISR_INITS                        ((uint32_t)0x00000010)
S#define RTC_ISR_SHPF                         ((uint32_t)0x00000008)
S#define RTC_ISR_WUTWF                        ((uint32_t)0x00000004)
S#define RTC_ISR_ALRBWF                       ((uint32_t)0x00000002)
S#define RTC_ISR_ALRAWF                       ((uint32_t)0x00000001)
S
S/********************  Bits definition for RTC_PRER register  *****************/
S#define RTC_PRER_PREDIV_A                    ((uint32_t)0x007F0000)
S#define RTC_PRER_PREDIV_S                    ((uint32_t)0x00007FFF)
S
S/********************  Bits definition for RTC_WUTR register  *****************/
S#define RTC_WUTR_WUT                         ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_ALRMAR register  ***************/
S#define RTC_ALRMAR_MSK4                      ((uint32_t)0x80000000)
S#define RTC_ALRMAR_WDSEL                     ((uint32_t)0x40000000)
S#define RTC_ALRMAR_DT                        ((uint32_t)0x30000000)
S#define RTC_ALRMAR_DT_0                      ((uint32_t)0x10000000)
S#define RTC_ALRMAR_DT_1                      ((uint32_t)0x20000000)
S#define RTC_ALRMAR_DU                        ((uint32_t)0x0F000000)
S#define RTC_ALRMAR_DU_0                      ((uint32_t)0x01000000)
S#define RTC_ALRMAR_DU_1                      ((uint32_t)0x02000000)
S#define RTC_ALRMAR_DU_2                      ((uint32_t)0x04000000)
S#define RTC_ALRMAR_DU_3                      ((uint32_t)0x08000000)
S#define RTC_ALRMAR_MSK3                      ((uint32_t)0x00800000)
S#define RTC_ALRMAR_PM                        ((uint32_t)0x00400000)
S#define RTC_ALRMAR_HT                        ((uint32_t)0x00300000)
S#define RTC_ALRMAR_HT_0                      ((uint32_t)0x00100000)
S#define RTC_ALRMAR_HT_1                      ((uint32_t)0x00200000)
S#define RTC_ALRMAR_HU                        ((uint32_t)0x000F0000)
S#define RTC_ALRMAR_HU_0                      ((uint32_t)0x00010000)
S#define RTC_ALRMAR_HU_1                      ((uint32_t)0x00020000)
S#define RTC_ALRMAR_HU_2                      ((uint32_t)0x00040000)
S#define RTC_ALRMAR_HU_3                      ((uint32_t)0x00080000)
S#define RTC_ALRMAR_MSK2                      ((uint32_t)0x00008000)
S#define RTC_ALRMAR_MNT                       ((uint32_t)0x00007000)
S#define RTC_ALRMAR_MNT_0                     ((uint32_t)0x00001000)
S#define RTC_ALRMAR_MNT_1                     ((uint32_t)0x00002000)
S#define RTC_ALRMAR_MNT_2                     ((uint32_t)0x00004000)
S#define RTC_ALRMAR_MNU                       ((uint32_t)0x00000F00)
S#define RTC_ALRMAR_MNU_0                     ((uint32_t)0x00000100)
S#define RTC_ALRMAR_MNU_1                     ((uint32_t)0x00000200)
S#define RTC_ALRMAR_MNU_2                     ((uint32_t)0x00000400)
S#define RTC_ALRMAR_MNU_3                     ((uint32_t)0x00000800)
S#define RTC_ALRMAR_MSK1                      ((uint32_t)0x00000080)
S#define RTC_ALRMAR_ST                        ((uint32_t)0x00000070)
S#define RTC_ALRMAR_ST_0                      ((uint32_t)0x00000010)
S#define RTC_ALRMAR_ST_1                      ((uint32_t)0x00000020)
S#define RTC_ALRMAR_ST_2                      ((uint32_t)0x00000040)
S#define RTC_ALRMAR_SU                        ((uint32_t)0x0000000F)
S#define RTC_ALRMAR_SU_0                      ((uint32_t)0x00000001)
S#define RTC_ALRMAR_SU_1                      ((uint32_t)0x00000002)
S#define RTC_ALRMAR_SU_2                      ((uint32_t)0x00000004)
S#define RTC_ALRMAR_SU_3                      ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_ALRMBR register  ***************/
S#define RTC_ALRMBR_MSK4                      ((uint32_t)0x80000000)
S#define RTC_ALRMBR_WDSEL                     ((uint32_t)0x40000000)
S#define RTC_ALRMBR_DT                        ((uint32_t)0x30000000)
S#define RTC_ALRMBR_DT_0                      ((uint32_t)0x10000000)
S#define RTC_ALRMBR_DT_1                      ((uint32_t)0x20000000)
S#define RTC_ALRMBR_DU                        ((uint32_t)0x0F000000)
S#define RTC_ALRMBR_DU_0                      ((uint32_t)0x01000000)
S#define RTC_ALRMBR_DU_1                      ((uint32_t)0x02000000)
S#define RTC_ALRMBR_DU_2                      ((uint32_t)0x04000000)
S#define RTC_ALRMBR_DU_3                      ((uint32_t)0x08000000)
S#define RTC_ALRMBR_MSK3                      ((uint32_t)0x00800000)
S#define RTC_ALRMBR_PM                        ((uint32_t)0x00400000)
S#define RTC_ALRMBR_HT                        ((uint32_t)0x00300000)
S#define RTC_ALRMBR_HT_0                      ((uint32_t)0x00100000)
S#define RTC_ALRMBR_HT_1                      ((uint32_t)0x00200000)
S#define RTC_ALRMBR_HU                        ((uint32_t)0x000F0000)
S#define RTC_ALRMBR_HU_0                      ((uint32_t)0x00010000)
S#define RTC_ALRMBR_HU_1                      ((uint32_t)0x00020000)
S#define RTC_ALRMBR_HU_2                      ((uint32_t)0x00040000)
S#define RTC_ALRMBR_HU_3                      ((uint32_t)0x00080000)
S#define RTC_ALRMBR_MSK2                      ((uint32_t)0x00008000)
S#define RTC_ALRMBR_MNT                       ((uint32_t)0x00007000)
S#define RTC_ALRMBR_MNT_0                     ((uint32_t)0x00001000)
S#define RTC_ALRMBR_MNT_1                     ((uint32_t)0x00002000)
S#define RTC_ALRMBR_MNT_2                     ((uint32_t)0x00004000)
S#define RTC_ALRMBR_MNU                       ((uint32_t)0x00000F00)
S#define RTC_ALRMBR_MNU_0                     ((uint32_t)0x00000100)
S#define RTC_ALRMBR_MNU_1                     ((uint32_t)0x00000200)
S#define RTC_ALRMBR_MNU_2                     ((uint32_t)0x00000400)
S#define RTC_ALRMBR_MNU_3                     ((uint32_t)0x00000800)
S#define RTC_ALRMBR_MSK1                      ((uint32_t)0x00000080)
S#define RTC_ALRMBR_ST                        ((uint32_t)0x00000070)
S#define RTC_ALRMBR_ST_0                      ((uint32_t)0x00000010)
S#define RTC_ALRMBR_ST_1                      ((uint32_t)0x00000020)
S#define RTC_ALRMBR_ST_2                      ((uint32_t)0x00000040)
S#define RTC_ALRMBR_SU                        ((uint32_t)0x0000000F)
S#define RTC_ALRMBR_SU_0                      ((uint32_t)0x00000001)
S#define RTC_ALRMBR_SU_1                      ((uint32_t)0x00000002)
S#define RTC_ALRMBR_SU_2                      ((uint32_t)0x00000004)
S#define RTC_ALRMBR_SU_3                      ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_WPR register  ******************/
S#define RTC_WPR_KEY                          ((uint32_t)0x000000FF)
S
S/********************  Bits definition for RTC_SSR register  ******************/
S#define RTC_SSR_SS                           ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_SHIFTR register  ***************/
S#define RTC_SHIFTR_SUBFS                     ((uint32_t)0x00007FFF)
S#define RTC_SHIFTR_ADD1S                     ((uint32_t)0x80000000)
S
S/********************  Bits definition for RTC_TSTR register  *****************/
S#define RTC_TSTR_PM                          ((uint32_t)0x00400000)
S#define RTC_TSTR_HT                          ((uint32_t)0x00300000)
S#define RTC_TSTR_HT_0                        ((uint32_t)0x00100000)
S#define RTC_TSTR_HT_1                        ((uint32_t)0x00200000)
S#define RTC_TSTR_HU                          ((uint32_t)0x000F0000)
S#define RTC_TSTR_HU_0                        ((uint32_t)0x00010000)
S#define RTC_TSTR_HU_1                        ((uint32_t)0x00020000)
S#define RTC_TSTR_HU_2                        ((uint32_t)0x00040000)
S#define RTC_TSTR_HU_3                        ((uint32_t)0x00080000)
S#define RTC_TSTR_MNT                         ((uint32_t)0x00007000)
S#define RTC_TSTR_MNT_0                       ((uint32_t)0x00001000)
S#define RTC_TSTR_MNT_1                       ((uint32_t)0x00002000)
S#define RTC_TSTR_MNT_2                       ((uint32_t)0x00004000)
S#define RTC_TSTR_MNU                         ((uint32_t)0x00000F00)
S#define RTC_TSTR_MNU_0                       ((uint32_t)0x00000100)
S#define RTC_TSTR_MNU_1                       ((uint32_t)0x00000200)
S#define RTC_TSTR_MNU_2                       ((uint32_t)0x00000400)
S#define RTC_TSTR_MNU_3                       ((uint32_t)0x00000800)
S#define RTC_TSTR_ST                          ((uint32_t)0x00000070)
S#define RTC_TSTR_ST_0                        ((uint32_t)0x00000010)
S#define RTC_TSTR_ST_1                        ((uint32_t)0x00000020)
S#define RTC_TSTR_ST_2                        ((uint32_t)0x00000040)
S#define RTC_TSTR_SU                          ((uint32_t)0x0000000F)
S#define RTC_TSTR_SU_0                        ((uint32_t)0x00000001)
S#define RTC_TSTR_SU_1                        ((uint32_t)0x00000002)
S#define RTC_TSTR_SU_2                        ((uint32_t)0x00000004)
S#define RTC_TSTR_SU_3                        ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_TSDR register  *****************/
S#define RTC_TSDR_WDU                         ((uint32_t)0x0000E000)
S#define RTC_TSDR_WDU_0                       ((uint32_t)0x00002000)
S#define RTC_TSDR_WDU_1                       ((uint32_t)0x00004000)
S#define RTC_TSDR_WDU_2                       ((uint32_t)0x00008000)
S#define RTC_TSDR_MT                          ((uint32_t)0x00001000)
S#define RTC_TSDR_MU                          ((uint32_t)0x00000F00)
S#define RTC_TSDR_MU_0                        ((uint32_t)0x00000100)
S#define RTC_TSDR_MU_1                        ((uint32_t)0x00000200)
S#define RTC_TSDR_MU_2                        ((uint32_t)0x00000400)
S#define RTC_TSDR_MU_3                        ((uint32_t)0x00000800)
S#define RTC_TSDR_DT                          ((uint32_t)0x00000030)
S#define RTC_TSDR_DT_0                        ((uint32_t)0x00000010)
S#define RTC_TSDR_DT_1                        ((uint32_t)0x00000020)
S#define RTC_TSDR_DU                          ((uint32_t)0x0000000F)
S#define RTC_TSDR_DU_0                        ((uint32_t)0x00000001)
S#define RTC_TSDR_DU_1                        ((uint32_t)0x00000002)
S#define RTC_TSDR_DU_2                        ((uint32_t)0x00000004)
S#define RTC_TSDR_DU_3                        ((uint32_t)0x00000008)
S
S/********************  Bits definition for RTC_TSSSR register  ****************/
S#define RTC_TSSSR_SS                         ((uint32_t)0x0000FFFF)
S
S/********************  Bits definition for RTC_CAL register  *****************/
S#define RTC_CALR_CALP                        ((uint32_t)0x00008000)
S#define RTC_CALR_CALW8                       ((uint32_t)0x00004000)
S#define RTC_CALR_CALW16                      ((uint32_t)0x00002000)
S#define RTC_CALR_CALM                        ((uint32_t)0x000001FF)
S#define RTC_CALR_CALM_0                      ((uint32_t)0x00000001)
S#define RTC_CALR_CALM_1                      ((uint32_t)0x00000002)
S#define RTC_CALR_CALM_2                      ((uint32_t)0x00000004)
S#define RTC_CALR_CALM_3                      ((uint32_t)0x00000008)
S#define RTC_CALR_CALM_4                      ((uint32_t)0x00000010)
S#define RTC_CALR_CALM_5                      ((uint32_t)0x00000020)
S#define RTC_CALR_CALM_6                      ((uint32_t)0x00000040)
S#define RTC_CALR_CALM_7                      ((uint32_t)0x00000080)
S#define RTC_CALR_CALM_8                      ((uint32_t)0x00000100)
S
S/********************  Bits definition for RTC_TAFCR register  ****************/
S#define RTC_TAFCR_ALARMOUTTYPE               ((uint32_t)0x00040000)
S#define RTC_TAFCR_TAMPPUDIS                  ((uint32_t)0x00008000)
S#define RTC_TAFCR_TAMPPRCH                   ((uint32_t)0x00006000)
S#define RTC_TAFCR_TAMPPRCH_0                 ((uint32_t)0x00002000)
S#define RTC_TAFCR_TAMPPRCH_1                 ((uint32_t)0x00004000)
S#define RTC_TAFCR_TAMPFLT                    ((uint32_t)0x00001800)
S#define RTC_TAFCR_TAMPFLT_0                  ((uint32_t)0x00000800)
S#define RTC_TAFCR_TAMPFLT_1                  ((uint32_t)0x00001000)
S#define RTC_TAFCR_TAMPFREQ                   ((uint32_t)0x00000700)
S#define RTC_TAFCR_TAMPFREQ_0                 ((uint32_t)0x00000100)
S#define RTC_TAFCR_TAMPFREQ_1                 ((uint32_t)0x00000200)
S#define RTC_TAFCR_TAMPFREQ_2                 ((uint32_t)0x00000400)
S#define RTC_TAFCR_TAMPTS                     ((uint32_t)0x00000080)
S#define RTC_TAFCR_TAMP3TRG                   ((uint32_t)0x00000040)
S#define RTC_TAFCR_TAMP3E                     ((uint32_t)0x00000020)
S#define RTC_TAFCR_TAMP2TRG                   ((uint32_t)0x00000010)
S#define RTC_TAFCR_TAMP2E                     ((uint32_t)0x00000008)
S#define RTC_TAFCR_TAMPIE                     ((uint32_t)0x00000004)
S#define RTC_TAFCR_TAMP1TRG                   ((uint32_t)0x00000002)
S#define RTC_TAFCR_TAMP1E                     ((uint32_t)0x00000001)
S
S/********************  Bits definition for RTC_ALRMASSR register  *************/
S#define RTC_ALRMASSR_MASKSS                  ((uint32_t)0x0F000000)
S#define RTC_ALRMASSR_MASKSS_0                ((uint32_t)0x01000000)
S#define RTC_ALRMASSR_MASKSS_1                ((uint32_t)0x02000000)
S#define RTC_ALRMASSR_MASKSS_2                ((uint32_t)0x04000000)
S#define RTC_ALRMASSR_MASKSS_3                ((uint32_t)0x08000000)
S#define RTC_ALRMASSR_SS                      ((uint32_t)0x00007FFF)
S
S/********************  Bits definition for RTC_ALRMBSSR register  *************/
S#define RTC_ALRMBSSR_MASKSS                  ((uint32_t)0x0F000000)
S#define RTC_ALRMBSSR_MASKSS_0                ((uint32_t)0x01000000)
S#define RTC_ALRMBSSR_MASKSS_1                ((uint32_t)0x02000000)
S#define RTC_ALRMBSSR_MASKSS_2                ((uint32_t)0x04000000)
S#define RTC_ALRMBSSR_MASKSS_3                ((uint32_t)0x08000000)
S#define RTC_ALRMBSSR_SS                      ((uint32_t)0x00007FFF)
S
S/********************  Bits definition for RTC_BKP0R register  ****************/
S#define RTC_BKP0R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP1R register  ****************/
S#define RTC_BKP1R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP2R register  ****************/
S#define RTC_BKP2R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP3R register  ****************/
S#define RTC_BKP3R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP4R register  ****************/
S#define RTC_BKP4R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP5R register  ****************/
S#define RTC_BKP5R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP6R register  ****************/
S#define RTC_BKP6R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP7R register  ****************/
S#define RTC_BKP7R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP8R register  ****************/
S#define RTC_BKP8R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP9R register  ****************/
S#define RTC_BKP9R                            ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP10R register  ***************/
S#define RTC_BKP10R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP11R register  ***************/
S#define RTC_BKP11R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP12R register  ***************/
S#define RTC_BKP12R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP13R register  ***************/
S#define RTC_BKP13R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP14R register  ***************/
S#define RTC_BKP14R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP15R register  ***************/
S#define RTC_BKP15R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP16R register  ***************/
S#define RTC_BKP16R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP17R register  ***************/
S#define RTC_BKP17R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP18R register  ***************/
S#define RTC_BKP18R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP19R register  ***************/
S#define RTC_BKP19R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP20R register  ***************/
S#define RTC_BKP20R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP21R register  ***************/
S#define RTC_BKP21R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP22R register  ***************/
S#define RTC_BKP22R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP23R register  ***************/
S#define RTC_BKP23R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP24R register  ***************/
S#define RTC_BKP24R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP25R register  ***************/
S#define RTC_BKP25R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP26R register  ***************/
S#define RTC_BKP26R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP27R register  ***************/
S#define RTC_BKP27R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP28R register  ***************/
S#define RTC_BKP28R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP29R register  ***************/
S#define RTC_BKP29R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP30R register  ***************/
S#define RTC_BKP30R                           ((uint32_t)0xFFFFFFFF)
S
S/********************  Bits definition for RTC_BKP31R register  ***************/
S#define RTC_BKP31R                           ((uint32_t)0xFFFFFFFF)
S
S/******************************************************************************/
S/*                                                                            */
S/*             Sigma-Delta Analog to Digital Converter (SDADC)                */
S/*                                                                            */
S/******************************************************************************/
S
S/*****************  Bit definition for SDADC_CR1 register  ********************/
S#define  SDADC_CR1_EOCALIE                       ((uint32_t)0x00000001)        /*!< End of calibration interrupt enable */
S#define  SDADC_CR1_JEOCIE                        ((uint32_t)0x00000002)        /*!< Injected end of conversion interrupt enable */
S#define  SDADC_CR1_JOVRIE                        ((uint32_t)0x00000004)        /*!< Injected data overrun interrupt enable */
S#define  SDADC_CR1_REOCIE                        ((uint32_t)0x00000008)        /*!< Regular end of conversion interrupt enable */
S#define  SDADC_CR1_ROVRIE                        ((uint32_t)0x00000010)        /*!< Regular data overrun interrupt enable */
S#define  SDADC_CR1_REFV                          ((uint32_t)0x00000300)        /*!< Reference voltage selection */
S#define  SDADC_CR1_REFV_0                        ((uint32_t)0x00000100)        /*!< Reference voltage selection bit 0 */
S#define  SDADC_CR1_REFV_1                        ((uint32_t)0x00000200)        /*!< Reference voltage selection bit 1 */
S#define  SDADC_CR1_SLOWCK                        ((uint32_t)0x00000400)        /*!< Slow clock mode enable */
S#define  SDADC_CR1_SBI                           ((uint32_t)0x00000800)        /*!< Enter standby mode when idle */
S#define  SDADC_CR1_PDI                           ((uint32_t)0x00001000)        /*!< Enter power down mode when idle */
S#define  SDADC_CR1_JSYNC                         ((uint32_t)0x00004000)        /*!< Launch a injected conversion synchronously with SDADC1 */
S#define  SDADC_CR1_RSYNC                         ((uint32_t)0x00008000)        /*!< Launch regular conversion synchronously with SDADC1 */
S#define  SDADC_CR1_JDMAEN                        ((uint32_t)0x00010000)        /*!< DMA channel enabled to read data for the injected channel group */
S#define  SDADC_CR1_RDMAEN                        ((uint32_t)0x00020000)        /*!< DMA channel enabled to read data for the regular channel */
S#define  SDADC_CR1_INIT                          ((uint32_t)0x80000000)        /*!< Initialization mode request */
S
S/*****************  Bit definition for SDADC_CR2 register  ********************/
S#define  SDADC_CR2_ADON                          ((uint32_t)0x00000001)        /*!< SDADC enable */
S#define  SDADC_CR2_CALIBCNT                      ((uint32_t)0x00000006)        /*!< Number of calibration sequences to be performed */
S#define  SDADC_CR2_CALIBCNT_0                    ((uint32_t)0x00000002)        /*!< Number of calibration sequences to be performed bit 0 */
S#define  SDADC_CR2_CALIBCNT_1                    ((uint32_t)0x00000004)        /*!< Number of calibration sequences to be performed bit 1 */
S#define  SDADC_CR2_STARTCALIB                    ((uint32_t)0x00000010)        /*!< Start calibration */
S#define  SDADC_CR2_JCONT                         ((uint32_t)0x00000020)        /*!< Continuous mode selection for injected conversions */
S#define  SDADC_CR2_JDS                           ((uint32_t)0x00000040)        /*!< Delay start of injected conversions */
S#define  SDADC_CR2_JEXTSEL                       ((uint32_t)0x00000F00)        /*!< Trigger signal selection for launching injected conversions */
S#define  SDADC_CR2_JEXTSEL_0                     ((uint32_t)0x00000100)        /*!< Trigger signal selection for launching injected conversions bit 0 */
S#define  SDADC_CR2_JEXTSEL_1                     ((uint32_t)0x00000200)        /*!< Trigger signal selection for launching injected conversions bit 1 */
S#define  SDADC_CR2_JEXTSEL_2                     ((uint32_t)0x00000400)        /*!< Trigger signal selection for launching injected conversions bit 2 */
S#define  SDADC_CR2_JEXTSEL_3                     ((uint32_t)0x00000800)        /*!< Trigger signal selection for launching injected conversions bit 3 */
S#define  SDADC_CR2_JEXTEN                        ((uint32_t)0x00006000)        /*!< Trigger enable and trigger edge selection for injected conversions */
S#define  SDADC_CR2_JEXTEN_0                      ((uint32_t)0x00002000)        /*!< Trigger enable and trigger edge selection for injected conversions bit 0 */
S#define  SDADC_CR2_JEXTEN_1                      ((uint32_t)0x00004000)        /*!< Trigger enable and trigger edge selection for injected conversions bit 1 */
S#define  SDADC_CR2_JSWSTART                      ((uint32_t)0x00008000)        /*!< Start a conversion of the injected group of channels */
S#define  SDADC_CR2_RCH                           ((uint32_t)0x000F0000)        /*!< Regular channel selection */
S#define  SDADC_CR2_RCH_0                         ((uint32_t)0x00010000)        /*!< Regular channel selection bit 0 */
S#define  SDADC_CR2_RCH_1                         ((uint32_t)0x00020000)        /*!< Regular channel selection bit 1 */
S#define  SDADC_CR2_RCH_2                         ((uint32_t)0x00040000)        /*!< Regular channel selection bit 2 */
S#define  SDADC_CR2_RCH_3                         ((uint32_t)0x00080000)        /*!< Regular channel selection bit 3 */
S#define  SDADC_CR2_RCONT                         ((uint32_t)0x00400000)        /*!< Continuous mode selection for regular conversions */
S#define  SDADC_CR2_RSWSTART                      ((uint32_t)0x00800000)        /*!< Software start of a conversion on the regular channel */
S#define  SDADC_CR2_FAST                          ((uint32_t)0x01000000)        /*!< Fast conversion mode selection */
S
S/********************  Bit definition for SDADC_ISR register  *****************/
S#define  SDADC_ISR_EOCALF                        ((uint32_t)0x00000001)        /*!< End of calibration flag */
S#define  SDADC_ISR_JEOCF                         ((uint32_t)0x00000002)        /*!< End of injected conversion flag */
S#define  SDADC_ISR_JOVRF                         ((uint32_t)0x00000004)        /*!< Injected conversion overrun flag */
S#define  SDADC_ISR_REOCF                         ((uint32_t)0x00000010)        /*!< End of regular conversion flag */
S#define  SDADC_ISR_ROVRF                         ((uint32_t)0x00000020)        /*!< Regular conversion overrun flag */
S#define  SDADC_ISR_CALIBIP                       ((uint32_t)0x00001000)        /*!< Calibration in progress status */
S#define  SDADC_ISR_JCIP                          ((uint32_t)0x00002000)        /*!< Injected conversion in progress status */
S#define  SDADC_ISR_RCIP                          ((uint32_t)0x00004000)        /*!< Regular conversion in progress status */
S#define  SDADC_ISR_STABIP                        ((uint32_t)0x00008000)        /*!< Stabilization in progress status */
S#define  SDADC_ISR_INITRDY                       ((uint32_t)0x80000000)        /*!< Initialization mode is ready */
S
S/******************  Bit definition for SDADC_CLRISR register  ****************/
S#define  SDADC_ISR_CLREOCALF                     ((uint32_t)0x00000001)       /*!< Clear the end of calibration flag */
S#define  SDADC_ISR_CLRJOVRF                      ((uint32_t)0x00000004)       /*!< Clear the injected conversion overrun flag */
S#define  SDADC_ISR_CLRROVRF                      ((uint32_t)0x00000010)       /*!< Clear the regular conversion overrun flag */
S
S/******************  Bit definition for SDADC_JCHGR register  *****************/
S#define  SDADC_JCHGR_JCHG                        ((uint32_t)0x000001FF)       /*!< Injected channel group selection */
S#define  SDADC_JCHGR_JCHG_0                      ((uint32_t)0x00000001)       /*!< Injected channel 0 selection */
S#define  SDADC_JCHGR_JCHG_1                      ((uint32_t)0x00000002)       /*!< Injected channel 1 selection */
S#define  SDADC_JCHGR_JCHG_2                      ((uint32_t)0x00000004)       /*!< Injected channel 2 selection */
S#define  SDADC_JCHGR_JCHG_3                      ((uint32_t)0x00000008)       /*!< Injected channel 3 selection */
S#define  SDADC_JCHGR_JCHG_4                      ((uint32_t)0x00000010)       /*!< Injected channel 4 selection */
S#define  SDADC_JCHGR_JCHG_5                      ((uint32_t)0x00000020)       /*!< Injected channel 5 selection */
S#define  SDADC_JCHGR_JCHG_6                      ((uint32_t)0x00000040)       /*!< Injected channel 6 selection */
S#define  SDADC_JCHGR_JCHG_7                      ((uint32_t)0x00000080)       /*!< Injected channel 7 selection */
S#define  SDADC_JCHGR_JCHG_8                      ((uint32_t)0x00000100)       /*!< Injected channel 8 selection */
S
S/******************  Bit definition for SDADC_CONF0R register  ****************/
S#define  SDADC_CONF0R_OFFSET0                    ((uint32_t)0x00000FFF)       /*!< 12-bit calibration offset for configuration 0 */
S#define  SDADC_CONF0R_GAIN0                      ((uint32_t)0x00700000)       /*!< Gain setting for configuration 0 */
S#define  SDADC_CONF0R_GAIN0_0                    ((uint32_t)0x00100000)       /*!< Gain setting for configuration 0 Bit 0*/
S#define  SDADC_CONF0R_GAIN0_1                    ((uint32_t)0x00200000)       /*!< Gain setting for configuration 0 Bit 1 */
S#define  SDADC_CONF0R_GAIN0_2                    ((uint32_t)0x00400000)       /*!< Gain setting for configuration 0 Bit 2 */
S#define  SDADC_CONF0R_SE0                        ((uint32_t)0x0C000000)       /*!< Single ended mode for configuration 0 */
S#define  SDADC_CONF0R_SE0_0                      ((uint32_t)0x04000000)       /*!< Single ended mode for configuration 0 Bit 0 */
S#define  SDADC_CONF0R_SE0_1                      ((uint32_t)0x08000000)       /*!< Single ended mode for configuration 0 Bit 1 */
S#define  SDADC_CONF0R_COMMON0                    ((uint32_t)0xC0000000)       /*!< Common mode for configuration 0 */
S#define  SDADC_CONF0R_COMMON0_0                  ((uint32_t)0x40000000)       /*!< Common mode for configuration 0 Bit 0 */
S#define  SDADC_CONF0R_COMMON0_1                  ((uint32_t)0x80000000)       /*!< Common mode for configuration 0 Bit 1 */
S
S/******************  Bit definition for SDADC_CONF1R register  ****************/
S#define  SDADC_CONF1R_OFFSET1                    ((uint32_t)0x00000FFF)       /*!< 12-bit calibration offset for configuration 1 */
S#define  SDADC_CONF1R_GAIN1                      ((uint32_t)0x00700000)       /*!< Gain setting for configuration 1 */
S#define  SDADC_CONF1R_GAIN1_0                    ((uint32_t)0x00100000)       /*!< Gain setting for configuration 1 Bit 0 */
S#define  SDADC_CONF1R_GAIN1_1                    ((uint32_t)0x00200000)       /*!< Gain setting for configuration 1 Bit 1 */
S#define  SDADC_CONF1R_GAIN1_2                    ((uint32_t)0x00400000)       /*!< Gain setting for configuration 1 Bit 2 */
S#define  SDADC_CONF1R_SE1                        ((uint32_t)0x0C000000)       /*!< Single ended mode for configuration 1 */
S#define  SDADC_CONF1R_SE1_0                      ((uint32_t)0x04000000)       /*!< Single ended mode for configuration 1 Bit 0 */
S#define  SDADC_CONF1R_SE1_1                      ((uint32_t)0x08000000)       /*!< Single ended mode for configuration 1 Bit 1 */
S#define  SDADC_CONF1R_COMMON1                    ((uint32_t)0xC0000000)       /*!< Common mode for configuration 1 */
S#define  SDADC_CONF1R_COMMON1_0                  ((uint32_t)0x40000000)       /*!< Common mode for configuration 1 Bit 0 */
S#define  SDADC_CONF1R_COMMON1_1                  ((uint32_t)0x40000000)       /*!< Common mode for configuration 1 Bit 1 */
S
S/******************  Bit definition for SDADC_CONF2R register  ****************/
S#define  SDADC_CONF2R_OFFSET2                    ((uint32_t)0x00000FFF)       /*!< 12-bit calibration offset for configuration 2 */
S#define  SDADC_CONF2R_GAIN2                      ((uint32_t)0x00700000)       /*!< Gain setting for configuration 2 */
S#define  SDADC_CONF2R_GAIN2_0                    ((uint32_t)0x00100000)       /*!< Gain setting for configuration 2 Bit 0 */
S#define  SDADC_CONF2R_GAIN2_1                    ((uint32_t)0x00200000)       /*!< Gain setting for configuration 2 Bit 1 */
S#define  SDADC_CONF2R_GAIN2_2                    ((uint32_t)0x00400000)       /*!< Gain setting for configuration 2 Bit 2 */
S#define  SDADC_CONF2R_SE2                        ((uint32_t)0x0C000000)       /*!< Single ended mode for configuration 2 */
S#define  SDADC_CONF2R_SE2_0                      ((uint32_t)0x04000000)       /*!< Single ended mode for configuration 2 Bit 0 */
S#define  SDADC_CONF2R_SE2_1                      ((uint32_t)0x08000000)       /*!< Single ended mode for configuration 2 Bit 1 */
S#define  SDADC_CONF2R_COMMON2                    ((uint32_t)0xC0000000)       /*!< Common mode for configuration 2 */
S#define  SDADC_CONF2R_COMMON2_0                  ((uint32_t)0x40000000)       /*!< Common mode for configuration 2 Bit 0 */
S#define  SDADC_CONF2R_COMMON2_1                  ((uint32_t)0x80000000)       /*!< Common mode for configuration 2 Bit 1 */
S
S/*****************  Bit definition for SDADC_CONFCHR1 register  ***************/
S#define  SDADC_CONFCHR1_CONFCH0                  ((uint32_t)0x00000003)      /*!< Channel 0 configuration */
S#define  SDADC_CONFCHR1_CONFCH1                  ((uint32_t)0x00000030)      /*!< Channel 1 configuration */
S#define  SDADC_CONFCHR1_CONFCH2                  ((uint32_t)0x00000300)      /*!< Channel 2 configuration */
S#define  SDADC_CONFCHR1_CONFCH3                  ((uint32_t)0x00003000)      /*!< Channel 3 configuration */
S#define  SDADC_CONFCHR1_CONFCH4                  ((uint32_t)0x00030000)      /*!< Channel 4 configuration */
S#define  SDADC_CONFCHR1_CONFCH5                  ((uint32_t)0x00300000)      /*!< Channel 5 configuration */
S#define  SDADC_CONFCHR1_CONFCH6                  ((uint32_t)0x03000000)      /*!< Channel 6 configuration */
S#define  SDADC_CONFCHR1_CONFCH7                  ((uint32_t)0x30000000)      /*!< Channel 7 configuration */
S
S/*****************  Bit definition for SDADC_CONFCHR2 register  ***************/
S#define  SDADC_CONFCHR2_CONFCH8                  ((uint32_t)0x00000003)      /*!< Channel 8 configuration */
S
S/*****************  Bit definition for SDADC_JDATAR register  ***************/
S#define  SDADC_JDATAR_JDATA                      ((uint32_t)0x0000FFFF)      /*!< Injected group conversion data */
S#define  SDADC_JDATAR_JDATACH                    ((uint32_t)0x0F000000)      /*!< Injected channel most recently converted */
S#define  SDADC_JDATAR_JDATACH_0                  ((uint32_t)0x01000000)      /*!< Injected channel most recently converted bit 0 */
S#define  SDADC_JDATAR_JDATACH_1                  ((uint32_t)0x02000000)      /*!< Injected channel most recently converted bit 1 */
S#define  SDADC_JDATAR_JDATACH_2                  ((uint32_t)0x04000000)      /*!< Injected channel most recently converted bit 2 */
S#define  SDADC_JDATAR_JDATACH_3                  ((uint32_t)0x08000000)      /*!< Injected channel most recently converted bit 3 */
S
S/*****************  Bit definition for SDADC_RDATAR register  ***************/
S#define  SDADC_RDATAR_RDATA                      ((uint32_t)0x0000FFFF)      /*!< Injected group conversion data */
S
S/*****************  Bit definition for SDADC_JDATA12R register  ***************/
S#define  SDADC_JDATA12R_JDATA2                      ((uint32_t)0xFFFF0000)      /*!< Injected group conversion data for SDADC2 */
S#define  SDADC_JDATA12R_JDATA1                      ((uint32_t)0x0000FFFF)      /*!< Injected group conversion data for SDADC1 */
S
S/*****************  Bit definition for SDADC_RDATA12R register  ***************/
S#define  SDADC_RDATA12R_RDATA2                      ((uint32_t)0xFFFF0000)      /*!< Regular conversion data for SDADC2 */
S#define  SDADC_RDATA12R_RDATA1                      ((uint32_t)0x0000FFFF)      /*!< Regular conversion data for SDADC1 */
S
S/*****************  Bit definition for SDADC_JDATA13R register  ***************/
S#define  SDADC_JDATA13R_JDATA3                      ((uint32_t)0xFFFF0000)      /*!< Injected group conversion data for SDADC3 */
S#define  SDADC_JDATA13R_JDATA1                      ((uint32_t)0x0000FFFF)      /*!< Injected group conversion data for SDADC1 */
S
S/*****************  Bit definition for SDADC_RDATA13R register  ***************/
S#define  SDADC_RDATA13R_RDATA3                      ((uint32_t)0xFFFF0000)      /*!< Regular conversion data for SDADC3 */
S#define  SDADC_RDATA13R_RDATA1                      ((uint32_t)0x0000FFFF)      /*!< Regular conversion data for SDADC1 */
S
S/******************************************************************************/
S/*                                                                            */
S/*                        Serial Peripheral Interface (SPI)                   */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for SPI_CR1 register  ********************/
S#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */
S#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */
S#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */
S#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */
S#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */
S#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */
S#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */
S#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */
S#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */
S#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */
S#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */
S#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */
S#define  SPI_CR1_CRCL                        ((uint16_t)0x0800)            /*!< CRC Length */
S#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */
S#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */
S#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */
S#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */
S
S/*******************  Bit definition for SPI_CR2 register  ********************/
S#define  SPI_CR2_RXDMAEN                     ((uint16_t)0x0001)            /*!< Rx Buffer DMA Enable */
S#define  SPI_CR2_TXDMAEN                     ((uint16_t)0x0002)            /*!< Tx Buffer DMA Enable */
S#define  SPI_CR2_SSOE                        ((uint16_t)0x0004)            /*!< SS Output Enable */
S#define  SPI_CR2_NSSP                        ((uint16_t)0x0008)            /*!< NSS pulse management Enable */
S#define  SPI_CR2_FRF                         ((uint16_t)0x0010)            /*!< Frame Format Enable */
S#define  SPI_CR2_ERRIE                       ((uint16_t)0x0020)            /*!< Error Interrupt Enable */
S#define  SPI_CR2_RXNEIE                      ((uint16_t)0x0040)            /*!< RX buffer Not Empty Interrupt Enable */
S#define  SPI_CR2_TXEIE                       ((uint16_t)0x0080)            /*!< Tx buffer Empty Interrupt Enable */
S#define  SPI_CR2_DS                          ((uint16_t)0x0F00)            /*!< DS[3:0] Data Size */
S#define  SPI_CR2_DS_0                        ((uint16_t)0x0100)            /*!< Bit 0 */
S#define  SPI_CR2_DS_1                        ((uint16_t)0x0200)            /*!< Bit 1 */
S#define  SPI_CR2_DS_2                        ((uint16_t)0x0400)            /*!< Bit 2 */
S#define  SPI_CR2_DS_3                        ((uint16_t)0x0800)            /*!< Bit 3 */
S#define  SPI_CR2_FRXTH                       ((uint16_t)0x1000)            /*!< FIFO reception Threshold */
S#define  SPI_CR2_LDMARX                      ((uint16_t)0x2000)            /*!< Last DMA transfer for reception */
S#define  SPI_CR2_LDMATX                      ((uint16_t)0x4000)            /*!< Last DMA transfer for transmission */
S
S/********************  Bit definition for SPI_SR register  ********************/
S#define  SPI_SR_RXNE                         ((uint16_t)0x0001)            /*!< Receive buffer Not Empty */
S#define  SPI_SR_TXE                          ((uint16_t)0x0002)            /*!< Transmit buffer Empty */
S#define  SPI_SR_CHSIDE                       ((uint16_t)0x0004)            /*!< Channel side */
S#define  SPI_SR_UDR                          ((uint16_t)0x0008)            /*!< Underrun flag */
S#define  SPI_SR_CRCERR                       ((uint16_t)0x0010)            /*!< CRC Error flag */
S#define  SPI_SR_MODF                         ((uint16_t)0x0020)            /*!< Mode fault */
S#define  SPI_SR_OVR                          ((uint16_t)0x0040)            /*!< Overrun flag */
S#define  SPI_SR_BSY                          ((uint16_t)0x0080)            /*!< Busy flag */
S#define  SPI_SR_FRE                          ((uint16_t)0x0100)            /*!< TI frame format error */
S#define  SPI_SR_FRLVL                        ((uint16_t)0x0600)            /*!< FIFO Reception Level */
S#define  SPI_SR_FRLVL_0                      ((uint16_t)0x0200)            /*!< Bit 0 */
S#define  SPI_SR_FRLVL_1                      ((uint16_t)0x0400)            /*!< Bit 1 */
S#define  SPI_SR_FTLVL                        ((uint16_t)0x1800)            /*!< FIFO Transmission Level */
S#define  SPI_SR_FTLVL_0                      ((uint16_t)0x0800)            /*!< Bit 0 */
S#define  SPI_SR_FTLVL_1                      ((uint16_t)0x1000)            /*!< Bit 1 */  
S
S/********************  Bit definition for SPI_DR register  ********************/
S#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */
S
S/*******************  Bit definition for SPI_CRCPR register  ******************/
S#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */
S
S/******************  Bit definition for SPI_RXCRCR register  ******************/
S#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */
S
S/******************  Bit definition for SPI_TXCRCR register  ******************/
S#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */
S
S/******************  Bit definition for SPI_I2SCFGR register  *****************/
S#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!<Channel length (number of bits per audio channel) */
S#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!<DATLEN[1:0] bits (Data length to be transferred) */
S#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!<Bit 1 */
S#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!<steady state clock polarity */
S#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!<I2SSTD[1:0] bits (I2S standard selection) */
S#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!<PCM frame synchronization */
S#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!<I2SCFG[1:0] bits (I2S configuration mode) */
S#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!<Bit 1 */
S#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!<I2S Enable */
S#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!<I2S mode selection */
S
S/******************  Bit definition for SPI_I2SPR register  *******************/
S#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!<I2S Linear prescaler */
S#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!<Odd factor for the prescaler */
S#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!<Master Clock Output Enable */
S
S/******************************************************************************/
S/*                                                                            */
S/*                        System Configuration(SYSCFG)                        */
S/*                                                                            */
S/******************************************************************************/
S/*****************  Bit definition for SYSCFG_CFGR1 register  ****************/
S#define SYSCFG_CFGR1_MEM_MODE               ((uint32_t)0x00000003) /*!< SYSCFG_Memory Remap Config */
S#define SYSCFG_CFGR1_MEM_MODE_0             ((uint32_t)0x00000001) /*!< Bit 0 */
S#define SYSCFG_CFGR1_MEM_MODE_1             ((uint32_t)0x00000002) /*!< Bit 1 */
S#define SYSCFG_CFGR1_TIM16_DMA_RMP          ((uint32_t)0x00000800) /*!< Timer 16 DMA remap */
S#define SYSCFG_CFGR1_TIM17_DMA_RMP          ((uint32_t)0x00001000) /*!< Timer 17 DMA remap */
S#define SYSCFG_CFGR1_TIM6DAC1Ch1_DMA_RMP    ((uint32_t)0x00002000) /*!< Timer 6 / DAC1 Ch1 DMA remap */
S#define SYSCFG_CFGR1_TIM7DAC1Ch2_DMA_RMP    ((uint32_t)0x00004000) /*!< Timer 7 / DAC1 Ch2 DMA remap */
S#define SYSCFG_CFGR1_TIM18DAC2Ch1_DMA_RMP   ((uint32_t)0x00008000) /*!< Timer 18 / DAC2 Ch1 DMA remap */
S#define SYSCFG_CFGR1_I2C_FMP_PB6            ((uint32_t)0x00010000) /*!< I2C PB6 Fast mode plus */
S#define SYSCFG_CFGR1_I2C_FMP_PB7            ((uint32_t)0x00020000) /*!< I2C PB7 Fast mode plus */
S#define SYSCFG_CFGR1_I2C_FMP_PB8            ((uint32_t)0x00040000) /*!< I2C PB8 Fast mode plus */
S#define SYSCFG_CFGR1_I2C_FMP_PB9            ((uint32_t)0x00080000) /*!< I2C PB9 Fast mode plus */
S#define SYSCFG_CFGR1_I2C_FMP_I2C1           ((uint32_t)0x00100000) /*!< I2C1 Fast mode plus */
S#define SYSCFG_CFGR1_I2C_FMP_I2C2           ((uint32_t)0x00200000) /*!< I2C2 Fast mode plus */
S#define SYSCFG_CFGR1_VBAT                   ((uint32_t)0x01000000) /*!< VBAT monitoring */
S#define SYSCFG_CFGR1_FPU_IE                 ((uint32_t)0xFC000000) /*!< Floating Point Unit Interrupt Enable */
S#define SYSCFG_CFGR1_FPU_IE_0               ((uint32_t)0x04000000) /*!< Floating Point Unit Interrupt Enable 0 */
S#define SYSCFG_CFGR1_FPU_IE_1               ((uint32_t)0x08000000) /*!< Floating Point Unit Interrupt Enable 1 */
S#define SYSCFG_CFGR1_FPU_IE_2               ((uint32_t)0x10000000) /*!< Floating Point Unit Interrupt Enable 2 */
S#define SYSCFG_CFGR1_FPU_IE_3               ((uint32_t)0x20000000) /*!< Floating Point Unit Interrupt Enable 3 */
S#define SYSCFG_CFGR1_FPU_IE_4               ((uint32_t)0x40000000) /*!< Floating Point Unit Interrupt Enable 4 */
S#define SYSCFG_CFGR1_FPU_IE_5               ((uint32_t)0x80000000) /*!< Floating Point Unit Interrupt Enable 5 */
S
S/*****************  Bit definition for SYSCFG_EXTICR1 register  ***************/
S#define SYSCFG_EXTICR1_EXTI0            ((uint16_t)0x000F) /*!< EXTI 0 configuration */
S#define SYSCFG_EXTICR1_EXTI1            ((uint16_t)0x00F0) /*!< EXTI 1 configuration */
S#define SYSCFG_EXTICR1_EXTI2            ((uint16_t)0x0F00) /*!< EXTI 2 configuration */
S#define SYSCFG_EXTICR1_EXTI3            ((uint16_t)0xF000) /*!< EXTI 3 configuration */
S
S/** 
S  * @brief  EXTI0 configuration  
S  */ 
S#define SYSCFG_EXTICR1_EXTI0_PA         ((uint16_t)0x0000) /*!< PA[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PB         ((uint16_t)0x0001) /*!< PB[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PC         ((uint16_t)0x0002) /*!< PC[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PD         ((uint16_t)0x0003) /*!< PD[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PE         ((uint16_t)0x0004) /*!< PE[0] pin */
S#define SYSCFG_EXTICR1_EXTI0_PF         ((uint16_t)0x0005) /*!< PF[0] pin */
S
S/** 
S  * @brief  EXTI1 configuration  
S  */
S#define SYSCFG_EXTICR1_EXTI1_PA         ((uint16_t)0x0000) /*!< PA[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PB         ((uint16_t)0x0010) /*!< PB[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PC         ((uint16_t)0x0020) /*!< PC[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PD         ((uint16_t)0x0030) /*!< PD[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PE         ((uint16_t)0x0040) /*!< PE[1] pin */
S#define SYSCFG_EXTICR1_EXTI1_PF         ((uint16_t)0x0050) /*!< PF[1] pin */
S
S/** 
S  * @brief  EXTI2 configuration  
S  */
S#define SYSCFG_EXTICR1_EXTI2_PA         ((uint16_t)0x0000) /*!< PA[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PB         ((uint16_t)0x0100) /*!< PB[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PC         ((uint16_t)0x0200) /*!< PC[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PD         ((uint16_t)0x0300) /*!< PD[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PE         ((uint16_t)0x0400) /*!< PE[2] pin */
S#define SYSCFG_EXTICR1_EXTI2_PF         ((uint16_t)0x0500) /*!< PF[2] pin */
S
S/** 
S  * @brief  EXTI3 configuration  
S  */
S#define SYSCFG_EXTICR1_EXTI3_PA         ((uint16_t)0x0000) /*!< PA[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PB         ((uint16_t)0x1000) /*!< PB[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PC         ((uint16_t)0x2000) /*!< PC[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PD         ((uint16_t)0x3000) /*!< PD[3] pin */
S#define SYSCFG_EXTICR1_EXTI3_PE         ((uint16_t)0x4000) /*!< PE[3] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR2 register  *****************/
S#define SYSCFG_EXTICR2_EXTI4            ((uint16_t)0x000F) /*!< EXTI 4 configuration */
S#define SYSCFG_EXTICR2_EXTI5            ((uint16_t)0x00F0) /*!< EXTI 5 configuration */
S#define SYSCFG_EXTICR2_EXTI6            ((uint16_t)0x0F00) /*!< EXTI 6 configuration */
S#define SYSCFG_EXTICR2_EXTI7            ((uint16_t)0xF000) /*!< EXTI 7 configuration */
S
S/** 
S  * @brief  EXTI4 configuration  
S  */ 
S#define SYSCFG_EXTICR2_EXTI4_PA         ((uint16_t)0x0000) /*!< PA[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PB         ((uint16_t)0x0001) /*!< PB[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PC         ((uint16_t)0x0002) /*!< PC[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PD         ((uint16_t)0x0003) /*!< PD[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PE         ((uint16_t)0x0004) /*!< PE[4] pin */
S#define SYSCFG_EXTICR2_EXTI4_PF         ((uint16_t)0x0005) /*!< PF[4] pin */
S
S/** 
S  * @brief  EXTI5 configuration  
S  */
S#define SYSCFG_EXTICR2_EXTI5_PA         ((uint16_t)0x0000) /*!< PA[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PB         ((uint16_t)0x0010) /*!< PB[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PC         ((uint16_t)0x0020) /*!< PC[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PD         ((uint16_t)0x0030) /*!< PD[5] pin */
S#define SYSCFG_EXTICR2_EXTI5_PE         ((uint16_t)0x0040) /*!< PE[5] pin */
S
S/** 
S  * @brief  EXTI6 configuration  
S  */
S#define SYSCFG_EXTICR2_EXTI6_PA         ((uint16_t)0x0000) /*!< PA[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PB         ((uint16_t)0x0100) /*!< PB[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PC         ((uint16_t)0x0200) /*!< PC[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PD         ((uint16_t)0x0300) /*!< PD[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PE         ((uint16_t)0x0400) /*!< PE[6] pin */
S#define SYSCFG_EXTICR2_EXTI6_PF         ((uint16_t)0x0500) /*!< PF[6] pin */
S
S/** 
S  * @brief  EXTI7 configuration  
S  */
S#define SYSCFG_EXTICR2_EXTI7_PA         ((uint16_t)0x0000) /*!< PA[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PB         ((uint16_t)0x1000) /*!< PB[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PC         ((uint16_t)0x2000) /*!< PC[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PD         ((uint16_t)0x3000) /*!< PD[7] pin */
S#define SYSCFG_EXTICR2_EXTI7_PE         ((uint16_t)0x4000) /*!< PE[7] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR3 register  *****************/
S#define SYSCFG_EXTICR3_EXTI8            ((uint16_t)0x000F) /*!< EXTI 8 configuration */
S#define SYSCFG_EXTICR3_EXTI9            ((uint16_t)0x00F0) /*!< EXTI 9 configuration */
S#define SYSCFG_EXTICR3_EXTI10           ((uint16_t)0x0F00) /*!< EXTI 10 configuration */
S#define SYSCFG_EXTICR3_EXTI11           ((uint16_t)0xF000) /*!< EXTI 11 configuration */
S
S/** 
S  * @brief  EXTI8 configuration  
S  */
S#define SYSCFG_EXTICR3_EXTI8_PA         ((uint16_t)0x0000) /*!< PA[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PB         ((uint16_t)0x0001) /*!< PB[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PC         ((uint16_t)0x0002) /*!< PC[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PD         ((uint16_t)0x0003) /*!< PD[8] pin */
S#define SYSCFG_EXTICR3_EXTI8_PE         ((uint16_t)0x0004) /*!< PE[8] pin */
S
S/** 
S  * @brief  EXTI9 configuration  
S  */
S#define SYSCFG_EXTICR3_EXTI9_PA         ((uint16_t)0x0000) /*!< PA[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PB         ((uint16_t)0x0010) /*!< PB[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PC         ((uint16_t)0x0020) /*!< PC[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PD         ((uint16_t)0x0030) /*!< PD[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PE         ((uint16_t)0x0040) /*!< PE[9] pin */
S#define SYSCFG_EXTICR3_EXTI9_PF         ((uint16_t)0x0050) /*!< PF[9] pin */
S
S/** 
S  * @brief  EXTI10 configuration  
S  */
S#define SYSCFG_EXTICR3_EXTI10_PA        ((uint16_t)0x0000) /*!< PA[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PB        ((uint16_t)0x0100) /*!< PB[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PC        ((uint16_t)0x0200) /*!< PC[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PD        ((uint16_t)0x0300) /*!< PD[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PE        ((uint16_t)0x0400) /*!< PE[10] pin */
S#define SYSCFG_EXTICR3_EXTI10_PF        ((uint16_t)0x0500) /*!< PF[10] pin */
S
S/** 
S  * @brief  EXTI11 configuration  
S  */
S#define SYSCFG_EXTICR3_EXTI11_PA        ((uint16_t)0x0000) /*!< PA[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PC        ((uint16_t)0x2000) /*!< PC[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PD        ((uint16_t)0x3000) /*!< PD[11] pin */
S#define SYSCFG_EXTICR3_EXTI11_PE        ((uint16_t)0x4000) /*!< PE[11] pin */
S
S/*****************  Bit definition for SYSCFG_EXTICR4 register  *****************/
S#define SYSCFG_EXTICR4_EXTI12           ((uint16_t)0x000F) /*!< EXTI 12 configuration */
S#define SYSCFG_EXTICR4_EXTI13           ((uint16_t)0x00F0) /*!< EXTI 13 configuration */
S#define SYSCFG_EXTICR4_EXTI14           ((uint16_t)0x0F00) /*!< EXTI 14 configuration */
S#define SYSCFG_EXTICR4_EXTI15           ((uint16_t)0xF000) /*!< EXTI 15 configuration */
S
S/** 
S  * @brief  EXTI12 configuration  
S  */
S#define SYSCFG_EXTICR4_EXTI12_PA        ((uint16_t)0x0000) /*!< PA[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PC        ((uint16_t)0x0002) /*!< PC[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PD        ((uint16_t)0x0003) /*!< PD[12] pin */
S#define SYSCFG_EXTICR4_EXTI12_PE        ((uint16_t)0x0004) /*!< PE[12] pin */
S
S/** 
S  * @brief  EXTI13 configuration  
S  */
S#define SYSCFG_EXTICR4_EXTI13_PA        ((uint16_t)0x0000) /*!< PA[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PC        ((uint16_t)0x0020) /*!< PC[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PD        ((uint16_t)0x0030) /*!< PD[13] pin */
S#define SYSCFG_EXTICR4_EXTI13_PE        ((uint16_t)0x0040) /*!< PE[13] pin */
S
S/** 
S  * @brief  EXTI14 configuration  
S  */
S#define SYSCFG_EXTICR4_EXTI14_PA        ((uint16_t)0x0000) /*!< PA[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PB        ((uint16_t)0x0100) /*!< PB[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PC        ((uint16_t)0x0200) /*!< PC[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PD        ((uint16_t)0x0300) /*!< PD[14] pin */
S#define SYSCFG_EXTICR4_EXTI14_PE        ((uint16_t)0x0400) /*!< PE[14] pin */
S
S/** 
S  * @brief  EXTI15 configuration  
S  */
S#define SYSCFG_EXTICR4_EXTI15_PA        ((uint16_t)0x0000) /*!< PA[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PB        ((uint16_t)0x1000) /*!< PB[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PC        ((uint16_t)0x2000) /*!< PC[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PD        ((uint16_t)0x3000) /*!< PD[15] pin */
S#define SYSCFG_EXTICR4_EXTI15_PE        ((uint16_t)0x4000) /*!< PE[15] pin */
S
S/*****************  Bit definition for SYSCFG_CFGR2 register  ****************/
S#define SYSCFG_CFGR2_LOCKUP_LOCK               ((uint32_t)0x00000001) /*!< Enables and locks the PVD connection with Timer1 Break Input and also the PVD_EN and PVDSEL[2:0] bits of the Power Control Interface */
S#define SYSCFG_CFGR2_SRAM_PARITY_LOCK          ((uint32_t)0x00000002) /*!< Enables and locks the SRAM_PARITY error signal with Break Input of TIMER1 */
S#define SYSCFG_CFGR2_PVD_LOCK                  ((uint32_t)0x00000004) /*!< Enables and locks the LOCKUP (Hardfault) output of CortexM0 with Break Input of TIMER1 */
S#define SYSCFG_CFGR2_SRAM_PE                   ((uint32_t)0x00000100) /*!< SRAM Parity error flag */
S
S/******************************************************************************/
S/*                                                                            */
S/*                                    TIM                                     */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for TIM_CR1 register  ********************/
S#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!<Counter enable */
S#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!<Update disable */
S#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!<Update request source */
S#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!<One pulse mode */
S#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!<Direction */
S
S#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!<CMS[1:0] bits (Center-aligned mode selection) */
S#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!<Bit 0 */
S#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!<Bit 1 */
S
S#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!<Auto-reload preload enable */
S
S#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!<CKD[1:0] bits (clock division) */
S#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
S
S/*******************  Bit definition for TIM_CR2 register  ********************/
S#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!<Capture/Compare Preloaded Control */
S#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!<Capture/Compare Control Update Selection */
S#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!<Capture/Compare DMA Selection */
S
S#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!<MMS[2:0] bits (Master Mode Selection) */
S#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!<TI1 Selection */
S#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!<Output Idle state 1 (OC1 output) */
S#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!<Output Idle state 1 (OC1N output) */
S#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!<Output Idle state 2 (OC2 output) */
S#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!<Output Idle state 2 (OC2N output) */
S#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!<Output Idle state 3 (OC3 output) */
S#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!<Output Idle state 3 (OC3N output) */
S#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!<Output Idle state 4 (OC4 output) */
S
S/*******************  Bit definition for TIM_SMCR register  *******************/
S#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!<SMS[2:0] bits (Slave mode selection) */
S#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
S
S#define  TIM_SMCR_OCCS                       ((uint16_t)0x0008)            /*!< OCREF clear selection */
S
S#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!<TS[2:0] bits (Trigger selection) */
S#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!<Master/slave mode */
S
S#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!<ETF[3:0] bits (External trigger filter) */
S#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!<Bit 1 */
S#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!<Bit 2 */
S#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!<Bit 3 */
S
S#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!<ETPS[1:0] bits (External trigger prescaler) */
S#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!<Bit 1 */
S
S#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!<External clock enable */
S#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!<External trigger polarity */
S
S/*******************  Bit definition for TIM_DIER register  *******************/
S#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!<Update interrupt enable */
S#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt enable */
S#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt enable */
S#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt enable */
S#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt enable */
S#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!<COM interrupt enable */
S#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!<Trigger interrupt enable */
S#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!<Break interrupt enable */
S#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!<Update DMA request enable */
S#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!<Capture/Compare 1 DMA request enable */
S#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!<Capture/Compare 2 DMA request enable */
S#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 DMA request enable */
S#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!<Capture/Compare 4 DMA request enable */
S#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!<COM DMA request enable */
S#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!<Trigger DMA request enable */
S
S/********************  Bit definition for TIM_SR register  ********************/
S#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!<Update interrupt Flag */
S#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!<Capture/Compare 1 interrupt Flag */
S#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!<Capture/Compare 2 interrupt Flag */
S#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!<Capture/Compare 3 interrupt Flag */
S#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!<Capture/Compare 4 interrupt Flag */
S#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!<COM interrupt Flag */
S#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!<Trigger interrupt Flag */
S#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!<Break interrupt Flag */
S#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!<Capture/Compare 1 Overcapture Flag */
S#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!<Capture/Compare 2 Overcapture Flag */
S#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!<Capture/Compare 3 Overcapture Flag */
S#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!<Capture/Compare 4 Overcapture Flag */
S
S/*******************  Bit definition for TIM_EGR register  ********************/
S#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!<Update Generation */
S#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!<Capture/Compare 1 Generation */
S#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!<Capture/Compare 2 Generation */
S#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!<Capture/Compare 3 Generation */
S#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!<Capture/Compare 4 Generation */
S#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!<Capture/Compare Control Update Generation */
S#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!<Trigger Generation */
S#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!<Break Generation */
S
S/******************  Bit definition for TIM_CCMR1 register  *******************/
S#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!<CC1S[1:0] bits (Capture/Compare 1 Selection) */
S#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!<Output Compare 1 Fast enable */
S#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!<Output Compare 1 Preload enable */
S
S#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!<OC1M[2:0] bits (Output Compare 1 Mode) */
S#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!<Output Compare 1Clear Enable */
S
S#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!<CC2S[1:0] bits (Capture/Compare 2 Selection) */
S#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!<Output Compare 2 Fast enable */
S#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!<Output Compare 2 Preload enable */
S
S#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!<OC2M[2:0] bits (Output Compare 2 Mode) */
S#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S
S#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!<Output Compare 2 Clear Enable */
S
S/*----------------------------------------------------------------------------*/
S
S#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!<IC1PSC[1:0] bits (Input Capture 1 Prescaler) */
S#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!<IC1F[3:0] bits (Input Capture 1 Filter) */
S#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
S
S#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!<IC2PSC[1:0] bits (Input Capture 2 Prescaler) */
S#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
S
S#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!<IC2F[3:0] bits (Input Capture 2 Filter) */
S#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
S
S/******************  Bit definition for TIM_CCMR2 register  *******************/
S#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!<CC3S[1:0] bits (Capture/Compare 3 Selection) */
S#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!<Output Compare 3 Fast enable */
S#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!<Output Compare 3 Preload enable */
S
S#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!<OC3M[2:0] bits (Output Compare 3 Mode) */
S#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S
S#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!<Output Compare 3 Clear Enable */
S
S#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!<CC4S[1:0] bits (Capture/Compare 4 Selection) */
S#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!<Output Compare 4 Fast enable */
S#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!<Output Compare 4 Preload enable */
S
S#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!<OC4M[2:0] bits (Output Compare 4 Mode) */
S#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S
S#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!<Output Compare 4 Clear Enable */
S
S/*----------------------------------------------------------------------------*/
S
S#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!<IC3PSC[1:0] bits (Input Capture 3 Prescaler) */
S#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!<IC3F[3:0] bits (Input Capture 3 Filter) */
S#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!<Bit 1 */
S#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!<Bit 2 */
S#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!<Bit 3 */
S
S#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!<IC4PSC[1:0] bits (Input Capture 4 Prescaler) */
S#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!<Bit 1 */
S
S#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!<IC4F[3:0] bits (Input Capture 4 Filter) */
S#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!<Bit 0 */
S#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!<Bit 1 */
S#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!<Bit 2 */
S#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!<Bit 3 */
S
S/*******************  Bit definition for TIM_CCER register  *******************/
S#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!<Capture/Compare 1 output enable */
S#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!<Capture/Compare 1 output Polarity */
S#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!<Capture/Compare 1 Complementary output enable */
S#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!<Capture/Compare 1 Complementary output Polarity */
S#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!<Capture/Compare 2 output enable */
S#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!<Capture/Compare 2 output Polarity */
S#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!<Capture/Compare 2 Complementary output enable */
S#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!<Capture/Compare 2 Complementary output Polarity */
S#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!<Capture/Compare 3 output enable */
S#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!<Capture/Compare 3 output Polarity */
S#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!<Capture/Compare 3 Complementary output enable */
S#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!<Capture/Compare 3 Complementary output Polarity */
S#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!<Capture/Compare 4 output enable */
S#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!<Capture/Compare 4 output Polarity */
S#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!<Capture/Compare 4 Complementary output Polarity */
S
S/*******************  Bit definition for TIM_CNT register  ********************/
S#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!<Counter Value */
S
S/*******************  Bit definition for TIM_PSC register  ********************/
S#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!<Prescaler Value */
S
S/*******************  Bit definition for TIM_ARR register  ********************/
S#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!<actual auto-reload Value */
S
S/*******************  Bit definition for TIM_RCR register  ********************/
S#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!<Repetition Counter Value */
S
S/*******************  Bit definition for TIM_CCR1 register  *******************/
S#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 1 Value */
S
S/*******************  Bit definition for TIM_CCR2 register  *******************/
S#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 2 Value */
S
S/*******************  Bit definition for TIM_CCR3 register  *******************/
S#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 3 Value */
S
S/*******************  Bit definition for TIM_CCR4 register  *******************/
S#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!<Capture/Compare 4 Value */
S
S/*******************  Bit definition for TIM_BDTR register  *******************/
S#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!<DTG[0:7] bits (Dead-Time Generator set-up) */
S#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!<Bit 4 */
S#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!<Bit 5 */
S#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!<Bit 6 */
S#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!<Bit 7 */
S
S#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!<LOCK[1:0] bits (Lock Configuration) */
S#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!<Bit 1 */
S
S#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!<Off-State Selection for Idle mode */
S#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!<Off-State Selection for Run mode */
S#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!<Break enable */
S#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!<Break Polarity */
S#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!<Automatic Output enable */
S#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!<Main Output enable */
S
S/*******************  Bit definition for TIM_DCR register  ********************/
S#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!<DBA[4:0] bits (DMA Base Address) */
S#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!<Bit 4 */
S
S#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!<DBL[4:0] bits (DMA Burst Length) */
S#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!<Bit 0 */
S#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!<Bit 1 */
S#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!<Bit 2 */
S#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!<Bit 3 */
S#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!<Bit 4 */
S
S/*******************  Bit definition for TIM_DMAR register  *******************/
S#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!<DMA register for burst accesses */
S
S/*******************  Bit definition for TIM_OR register  *********************/
S#define TIM14_OR_TI1_RMP                       ((uint16_t)0x00C0)            /*!<TI1_RMP[1:0] bits (TIM14 Input 4 remap) */
S#define TIM14_OR_TI1_RMP_0                     ((uint16_t)0x0040)            /*!<Bit 0 */
S#define TIM14_OR_TI1_RMP_1                     ((uint16_t)0x0080)            /*!<Bit 1 */
S
S/******************************************************************************/
S/*                                                                            */
S/*      Universal Synchronous Asynchronous Receiver Transmitter (USART)       */
S/*                                                                            */
S/******************************************************************************/
S/******************  Bit definition for USART_CR1 register  *******************/
S#define  USART_CR1_UE                        ((uint32_t)0x00000001)            /*!< USART Enable */
S#define  USART_CR1_UESM                      ((uint32_t)0x00000002)            /*!< USART Enable in STOP Mode */
S#define  USART_CR1_RE                        ((uint32_t)0x00000004)            /*!< Receiver Enable */
S#define  USART_CR1_TE                        ((uint32_t)0x00000008)            /*!< Transmitter Enable */
S#define  USART_CR1_IDLEIE                    ((uint32_t)0x00000010)            /*!< IDLE Interrupt Enable */
S#define  USART_CR1_RXNEIE                    ((uint32_t)0x00000020)            /*!< RXNE Interrupt Enable */
S#define  USART_CR1_TCIE                      ((uint32_t)0x00000040)            /*!< Transmission Complete Interrupt Enable */
S#define  USART_CR1_TXEIE                     ((uint32_t)0x00000080)            /*!< TXE Interrupt Enable */
S#define  USART_CR1_PEIE                      ((uint32_t)0x00000100)            /*!< PE Interrupt Enable */
S#define  USART_CR1_PS                        ((uint32_t)0x00000200)            /*!< Parity Selection */
S#define  USART_CR1_PCE                       ((uint32_t)0x00000400)            /*!< Parity Control Enable */
S#define  USART_CR1_WAKE                      ((uint32_t)0x00000800)            /*!< Receiver Wakeup method */
S#define  USART_CR1_M                         ((uint32_t)0x00001000)            /*!< Word length */
S#define  USART_CR1_MME                       ((uint32_t)0x00002000)            /*!< Mute Mode Enable */
S#define  USART_CR1_CMIE                      ((uint32_t)0x00004000)            /*!< Character match interrupt enable */
S#define  USART_CR1_OVER8                     ((uint32_t)0x00008000)            /*!< Oversampling by 8-bit or 16-bit mode */
S#define  USART_CR1_DEDT                      ((uint32_t)0x001F0000)            /*!< DEDT[4:0] bits (Driver Enable Deassertion Time) */
S#define  USART_CR1_DEDT_0                    ((uint32_t)0x00010000)            /*!< Bit 0 */
S#define  USART_CR1_DEDT_1                    ((uint32_t)0x00020000)            /*!< Bit 1 */
S#define  USART_CR1_DEDT_2                    ((uint32_t)0x00040000)            /*!< Bit 2 */
S#define  USART_CR1_DEDT_3                    ((uint32_t)0x00080000)            /*!< Bit 3 */
S#define  USART_CR1_DEDT_4                    ((uint32_t)0x00100000)            /*!< Bit 4 */
S#define  USART_CR1_DEAT                      ((uint32_t)0x03E00000)            /*!< DEAT[4:0] bits (Driver Enable Assertion Time) */
S#define  USART_CR1_DEAT_0                    ((uint32_t)0x00200000)            /*!< Bit 0 */
S#define  USART_CR1_DEAT_1                    ((uint32_t)0x00400000)            /*!< Bit 1 */
S#define  USART_CR1_DEAT_2                    ((uint32_t)0x00800000)            /*!< Bit 2 */
S#define  USART_CR1_DEAT_3                    ((uint32_t)0x01000000)            /*!< Bit 3 */
S#define  USART_CR1_DEAT_4                    ((uint32_t)0x02000000)            /*!< Bit 4 */
S#define  USART_CR1_RTOIE                     ((uint32_t)0x04000000)            /*!< Receive Time Out interrupt enable */
S#define  USART_CR1_EOBIE                     ((uint32_t)0x08000000)            /*!< End of Block interrupt enable */
S
S/******************  Bit definition for USART_CR2 register  *******************/
S#define  USART_CR2_ADDM7                     ((uint32_t)0x00000010)            /*!< 7-bit or 4-bit Address Detection */
S#define  USART_CR2_LBDL                      ((uint32_t)0x00000020)            /*!< LIN Break Detection Length */
S#define  USART_CR2_LBDIE                     ((uint32_t)0x00000040)            /*!< LIN Break Detection Interrupt Enable */
S#define  USART_CR2_LBCL                      ((uint32_t)0x00000100)            /*!< Last Bit Clock pulse */
S#define  USART_CR2_CPHA                      ((uint32_t)0x00000200)            /*!< Clock Phase */
S#define  USART_CR2_CPOL                      ((uint32_t)0x00000400)            /*!< Clock Polarity */
S#define  USART_CR2_CLKEN                     ((uint32_t)0x00000800)            /*!< Clock Enable */
S#define  USART_CR2_STOP                      ((uint32_t)0x00003000)            /*!< STOP[1:0] bits (STOP bits) */
S#define  USART_CR2_STOP_0                    ((uint32_t)0x00001000)            /*!< Bit 0 */
S#define  USART_CR2_STOP_1                    ((uint32_t)0x00002000)            /*!< Bit 1 */
S#define  USART_CR2_LINEN                     ((uint32_t)0x00004000)            /*!< LIN mode enable */
S#define  USART_CR2_SWAP                      ((uint32_t)0x00008000)            /*!< SWAP TX/RX pins */
S#define  USART_CR2_RXINV                     ((uint32_t)0x00010000)            /*!< RX pin active level inversion */
S#define  USART_CR2_TXINV                     ((uint32_t)0x00020000)            /*!< TX pin active level inversion */
S#define  USART_CR2_DATAINV                   ((uint32_t)0x00040000)            /*!< Binary data inversion */
S#define  USART_CR2_MSBFIRST                  ((uint32_t)0x00080000)            /*!< Most Significant Bit First */
S#define  USART_CR2_ABREN                     ((uint32_t)0x00100000)            /*!< Auto Baud-Rate Enable*/
S#define  USART_CR2_ABRMODE                   ((uint32_t)0x00600000)            /*!< ABRMOD[1:0] bits (Auto Baud-Rate Mode) */
S#define  USART_CR2_ABRMODE_0                 ((uint32_t)0x00200000)            /*!< Bit 0 */
S#define  USART_CR2_ABRMODE_1                 ((uint32_t)0x00400000)            /*!< Bit 1 */
S#define  USART_CR2_RTOEN                     ((uint32_t)0x00800000)            /*!< Receiver Time-Out enable */
S#define  USART_CR2_ADD                       ((uint32_t)0xFF000000)            /*!< Address of the USART node */
S
S/******************  Bit definition for USART_CR3 register  *******************/
S#define  USART_CR3_EIE                       ((uint32_t)0x00000001)            /*!< Error Interrupt Enable */
S#define  USART_CR3_IREN                      ((uint32_t)0x00000002)            /*!< IrDA mode Enable */
S#define  USART_CR3_IRLP                      ((uint32_t)0x00000004)            /*!< IrDA Low-Power */
S#define  USART_CR3_HDSEL                     ((uint32_t)0x00000008)            /*!< Half-Duplex Selection */
S#define  USART_CR3_NACK                      ((uint32_t)0x00000010)            /*!< SmartCard NACK enable */
S#define  USART_CR3_SCEN                      ((uint32_t)0x00000020)            /*!< SmartCard mode enable */
S#define  USART_CR3_DMAR                      ((uint32_t)0x00000040)            /*!< DMA Enable Receiver */
S#define  USART_CR3_DMAT                      ((uint32_t)0x00000080)            /*!< DMA Enable Transmitter */
S#define  USART_CR3_RTSE                      ((uint32_t)0x00000100)            /*!< RTS Enable */
S#define  USART_CR3_CTSE                      ((uint32_t)0x00000200)            /*!< CTS Enable */
S#define  USART_CR3_CTSIE                     ((uint32_t)0x00000400)            /*!< CTS Interrupt Enable */
S#define  USART_CR3_ONEBIT                    ((uint32_t)0x00000800)            /*!< One sample bit method enable */
S#define  USART_CR3_OVRDIS                    ((uint32_t)0x00001000)            /*!< Overrun Disable */
S#define  USART_CR3_DDRE                      ((uint32_t)0x00002000)            /*!< DMA Disable on Reception Error */
S#define  USART_CR3_DEM                       ((uint32_t)0x00004000)            /*!< Driver Enable Mode */
S#define  USART_CR3_DEP                       ((uint32_t)0x00008000)            /*!< Driver Enable Polarity Selection */
S#define  USART_CR3_SCARCNT                   ((uint32_t)0x000E0000)            /*!< SCARCNT[2:0] bits (SmartCard Auto-Retry Count) */
S#define  USART_CR3_SCARCNT_0                 ((uint32_t)0x00020000)            /*!< Bit 0 */
S#define  USART_CR3_SCARCNT_1                 ((uint32_t)0x00040000)            /*!< Bit 1 */
S#define  USART_CR3_SCARCNT_2                 ((uint32_t)0x00080000)            /*!< Bit 2 */
S#define  USART_CR3_WUS                       ((uint32_t)0x00300000)            /*!< WUS[1:0] bits (Wake UP Interrupt Flag Selection) */
S#define  USART_CR3_WUS_0                     ((uint32_t)0x00100000)            /*!< Bit 0 */
S#define  USART_CR3_WUS_1                     ((uint32_t)0x00200000)            /*!< Bit 1 */
S#define  USART_CR3_WUFIE                     ((uint32_t)0x00400000)            /*!< Wake Up Interrupt Enable */
S
S/******************  Bit definition for USART_BRR register  *******************/
S#define  USART_BRR_DIV_FRACTION              ((uint16_t)0x000F)                /*!< Fraction of USARTDIV */
S#define  USART_BRR_DIV_MANTISSA              ((uint16_t)0xFFF0)                /*!< Mantissa of USARTDIV */
S
S/******************  Bit definition for USART_GTPR register  ******************/
S#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)                /*!< PSC[7:0] bits (Prescaler value) */
S#define  USART_GTPR_GT                       ((uint16_t)0xFF00)                /*!< GT[7:0] bits (Guard time value) */
S
S
S/*******************  Bit definition for USART_RTOR register  *****************/
S#define  USART_RTOR_RTO                      ((uint32_t)0x00FFFFFF)            /*!< Receiver Time Out Value */
S#define  USART_RTOR_BLEN                     ((uint32_t)0xFF000000)            /*!< Block Length */
S
S/*******************  Bit definition for USART_RQR register  ******************/
S#define  USART_RQR_ABRRQ                     ((uint16_t)0x0001)                /*!< Auto-Baud Rate Request */
S#define  USART_RQR_SBKRQ                     ((uint16_t)0x0002)                /*!< Send Break Request */
S#define  USART_RQR_MMRQ                      ((uint16_t)0x0004)                /*!< Mute Mode Request */
S#define  USART_RQR_RXFRQ                     ((uint16_t)0x0008)                /*!< Receive Data flush Request */
S#define  USART_RQR_TXFRQ                     ((uint16_t)0x0010)                /*!< Transmit data flush Request */
S
S/*******************  Bit definition for USART_ISR register  ******************/
S#define  USART_ISR_PE                        ((uint32_t)0x00000001)            /*!< Parity Error */
S#define  USART_ISR_FE                        ((uint32_t)0x00000002)            /*!< Framing Error */
S#define  USART_ISR_NE                        ((uint32_t)0x00000004)            /*!< Noise detected Flag */
S#define  USART_ISR_ORE                       ((uint32_t)0x00000008)            /*!< OverRun Error */
S#define  USART_ISR_IDLE                      ((uint32_t)0x00000010)            /*!< IDLE line detected */
S#define  USART_ISR_RXNE                      ((uint32_t)0x00000020)            /*!< Read Data Register Not Empty */
S#define  USART_ISR_TC                        ((uint32_t)0x00000040)            /*!< Transmission Complete */
S#define  USART_ISR_TXE                       ((uint32_t)0x00000080)            /*!< Transmit Data Register Empty */
S#define  USART_ISR_LBD                       ((uint32_t)0x00000100)            /*!< LIN Break Detection Flag */
S#define  USART_ISR_CTSIF                     ((uint32_t)0x00000200)            /*!< CTS interrupt flag */
S#define  USART_ISR_CTS                       ((uint32_t)0x00000400)            /*!< CTS flag */
S#define  USART_ISR_RTOF                      ((uint32_t)0x00000800)            /*!< Receiver Time Out */
S#define  USART_ISR_EOBF                      ((uint32_t)0x00001000)            /*!< End Of Block Flag */
S#define  USART_ISR_ABRE                      ((uint32_t)0x00004000)            /*!< Auto-Baud Rate Error */
S#define  USART_ISR_ABRF                      ((uint32_t)0x00008000)            /*!< Auto-Baud Rate Flag */
S#define  USART_ISR_BUSY                      ((uint32_t)0x00010000)            /*!< Busy Flag */
S#define  USART_ISR_CMF                       ((uint32_t)0x00020000)            /*!< Character Match Flag */
S#define  USART_ISR_SBKF                      ((uint32_t)0x00040000)            /*!< Send Break Flag */
S#define  USART_ISR_RWU                       ((uint32_t)0x00080000)            /*!< Receive Wake Up from mute mode Flag */
S#define  USART_ISR_WUF                       ((uint32_t)0x00100000)            /*!< Wake Up from stop mode Flag */
S#define  USART_ISR_TEACK                     ((uint32_t)0x00200000)            /*!< Transmit Enable Acknowledge Flag */
S#define  USART_ISR_REACK                     ((uint32_t)0x00400000)            /*!< Receive Enable Acknowledge Flag */
S
S/*******************  Bit definition for USART_ICR register  ******************/
S#define  USART_ICR_PECF                      ((uint32_t)0x00000001)            /*!< Parity Error Clear Flag */
S#define  USART_ICR_FECF                      ((uint32_t)0x00000002)            /*!< Framing Error Clear Flag */
S#define  USART_ICR_NCF                       ((uint32_t)0x00000004)            /*!< Noise detected Clear Flag */
S#define  USART_ICR_ORECF                     ((uint32_t)0x00000008)            /*!< OverRun Error Clear Flag */
S#define  USART_ICR_IDLECF                    ((uint32_t)0x00000010)            /*!< IDLE line detected Clear Flag */
S#define  USART_ICR_TCCF                      ((uint32_t)0x00000040)            /*!< Transmission Complete Clear Flag */
S#define  USART_ICR_LBDCF                     ((uint32_t)0x00000100)            /*!< LIN Break Detection Clear Flag */
S#define  USART_ICR_CTSCF                     ((uint32_t)0x00000200)            /*!< CTS Interrupt Clear Flag */
S#define  USART_ICR_RTOCF                     ((uint32_t)0x00000800)            /*!< Receiver Time Out Clear Flag */
S#define  USART_ICR_EOBCF                     ((uint32_t)0x00001000)            /*!< End Of Block Clear Flag */
S#define  USART_ICR_CMCF                      ((uint32_t)0x00020000)            /*!< Character Match Clear Flag */
S#define  USART_ICR_WUCF                      ((uint32_t)0x00100000)            /*!< Wake Up from stop mode Clear Flag */
S
S/*******************  Bit definition for USART_RDR register  ******************/
S#define  USART_RDR_RDR                       ((uint16_t)0x01FF)                /*!< RDR[8:0] bits (Receive Data value) */
S
S/*******************  Bit definition for USART_TDR register  ******************/
S#define  USART_TDR_TDR                       ((uint16_t)0x01FF)                /*!< TDR[8:0] bits (Transmit Data value) */
S
S/******************************************************************************/
S/*                                                                            */
S/*                            Window WATCHDOG                                 */
S/*                                                                            */
S/******************************************************************************/
S/*******************  Bit definition for WWDG_CR register  ********************/
S#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!<T[6:0] bits (7-Bit counter (MSB to LSB)) */
S#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!<Bit 0 */
S#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!<Bit 1 */
S#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!<Bit 2 */
S#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!<Bit 3 */
S#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!<Bit 4 */
S#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!<Bit 5 */
S#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!<Bit 6 */
S
S#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!<Activation bit */
S
S/*******************  Bit definition for WWDG_CFR register  *******************/
S#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!<W[6:0] bits (7-bit window value) */
S#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!<Bit 0 */
S#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!<Bit 1 */
S#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!<Bit 2 */
S#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!<Bit 3 */
S#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!<Bit 4 */
S#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!<Bit 5 */
S#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!<Bit 6 */
S
S#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!<WDGTB[1:0] bits (Timer Base) */
S#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!<Bit 0 */
S#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!<Bit 1 */
S
S#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!<Early Wakeup Interrupt */
S
S/*******************  Bit definition for WWDG_SR register  ********************/
S#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!<Early Wakeup Interrupt Flag */
S
S/**
S  * @}
S  */
S
S /**
S  * @}
S  */
S
S#ifdef USE_STDPERIPH_DRIVER
S  #include "stm32f37x_conf.h"
S#endif /* USE_STDPERIPH_DRIVER */
S
S/** @addtogroup Exported_macro
S  * @{
S  */
S
S#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
S
S#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
S
S#define READ_BIT(REG, BIT)    ((REG) & (BIT))
S
S#define CLEAR_REG(REG)        ((REG) = (0x0))
S
S#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
S
S#define READ_REG(REG)         ((REG))
S
S#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
S
S/**
S  * @}
S  */
S
S#ifdef __cplusplus
S}
S#endif /* __cplusplus */
S
N#endif /* __STM32F37x_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/
L 39 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_adc.h" 2
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup ADC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  ADC Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion is performed in
N                                               Scan (multichannels) or Single (one channel) mode.
N                                               This parameter can be set to ENABLE or DISABLE */
N
N  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion is performed in
N                                               Continuous or Single mode.
N                                               This parameter can be set to ENABLE or DISABLE. */
N
N  uint32_t ADC_ExternalTrigConv;          /*!< Defines the external trigger used to start the analog
N                                               to digital conversion of regular channels. This parameter
N                                               can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion */
N
N  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data alignment is left or right.
N                                               This parameter can be a value of @ref ADC_data_align */
N
N  uint8_t ADC_NbrOfChannel;               /*!< Specifies the number of ADC channels that will be converted
N                                               using the sequencer for regular channel group.
N                                               This parameter must range from 1 to 16. */
N}ADC_InitTypeDef;
N
N/**
N  * @}
N  */
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup ADC_Exported_Constants
N  * @{
N  */ 
N
N#define IS_ADC_ALL_PERIPH(PERIPH) ((PERIPH) == ADC1)
N
N#define IS_ADC_DMA_PERIPH(PERIPH) ((PERIPH) == ADC1)
N
N/** @defgroup ADC_external_trigger_sources_for_regular_channels_conversion 
N  * @{
N  */
N
N#define ADC_ExternalTrigConv_T19_TRGO              ((uint32_t)0x00000000)
N#define ADC_ExternalTrigConv_T19_CC3               ADC_CR2_EXTSEL_0
N#define ADC_ExternalTrigConv_T19_CC4               ADC_CR2_EXTSEL_1
N#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x00060000)
N#define ADC_ExternalTrigConv_T3_TRGO               ADC_CR2_EXTSEL_2
N#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x000A0000)
N#define ADC_ExternalTrigConv_Ext_IT11              ((uint32_t)0x000C0000)
N#define ADC_ExternalTrigConv_None                  ((uint32_t)0x000E0000)
N
N#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T19_TRGO)  || \
N                                   ((REGTRIG) == ADC_ExternalTrigConv_T19_CC3)  || \
N                                   ((REGTRIG) == ADC_ExternalTrigConv_T19_CC4)  || \
N                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2)   || \
N                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO)  || \
N                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4)   || \
N                                   ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11) || \
N                                   ((REGTRIG) == ADC_ExternalTrigConv_None))
X#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T19_TRGO)  ||                                    ((REGTRIG) == ADC_ExternalTrigConv_T19_CC3)  ||                                    ((REGTRIG) == ADC_ExternalTrigConv_T19_CC4)  ||                                    ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2)   ||                                    ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO)  ||                                    ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4)   ||                                    ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11) ||                                    ((REGTRIG) == ADC_ExternalTrigConv_None))
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_data_align 
N  * @{
N  */
N
N#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
N#define ADC_DataAlign_Left                         ADC_CR2_ALIGN
N
N#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
N                                  ((ALIGN) == ADC_DataAlign_Left))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) ||                                   ((ALIGN) == ADC_DataAlign_Left))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_channels 
N  * @{
N  */
N
N#define ADC_Channel_0                               ((uint8_t)0x00)
N#define ADC_Channel_1                               ((uint8_t)0x01)
N#define ADC_Channel_2                               ((uint8_t)0x02)
N#define ADC_Channel_3                               ((uint8_t)0x03)
N#define ADC_Channel_4                               ((uint8_t)0x04)
N#define ADC_Channel_5                               ((uint8_t)0x05)
N#define ADC_Channel_6                               ((uint8_t)0x06)
N#define ADC_Channel_7                               ((uint8_t)0x07)
N#define ADC_Channel_8                               ((uint8_t)0x08)
N#define ADC_Channel_9                               ((uint8_t)0x09)
N#define ADC_Channel_10                              ((uint8_t)0x0A)
N#define ADC_Channel_11                              ((uint8_t)0x0B)
N#define ADC_Channel_12                              ((uint8_t)0x0C)
N#define ADC_Channel_13                              ((uint8_t)0x0D)
N#define ADC_Channel_14                              ((uint8_t)0x0E)
N#define ADC_Channel_15                              ((uint8_t)0x0F)
N#define ADC_Channel_16                              ((uint8_t)0x10)
N#define ADC_Channel_17                              ((uint8_t)0x11)
N#define ADC_Channel_18                              ((uint8_t)0x12)
N
N#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_16)
N#define ADC_Channel_Vrefint                         ((uint8_t)ADC_Channel_17)
N#define ADC_Channel_Vbat                            ((uint8_t)ADC_Channel_18)
N
N#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0)  || \
N                                 ((CHANNEL) == ADC_Channel_1)  || \
N                                 ((CHANNEL) == ADC_Channel_2)  || \
N                                 ((CHANNEL) == ADC_Channel_3)  || \
N                                 ((CHANNEL) == ADC_Channel_4)  || \
N                                 ((CHANNEL) == ADC_Channel_5)  || \
N                                 ((CHANNEL) == ADC_Channel_6)  || \
N                                 ((CHANNEL) == ADC_Channel_7)  || \
N                                 ((CHANNEL) == ADC_Channel_8)  || \
N                                 ((CHANNEL) == ADC_Channel_9)  || \
N                                 ((CHANNEL) == ADC_Channel_10) || \
N                                 ((CHANNEL) == ADC_Channel_11) || \
N                                 ((CHANNEL) == ADC_Channel_12) || \
N                                 ((CHANNEL) == ADC_Channel_13) || \
N                                 ((CHANNEL) == ADC_Channel_14) || \
N                                 ((CHANNEL) == ADC_Channel_15) || \
N                                 ((CHANNEL) == ADC_Channel_16) || \
N                                 ((CHANNEL) == ADC_Channel_17) || \
N                                 ((CHANNEL) == ADC_Channel_18))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0)  ||                                  ((CHANNEL) == ADC_Channel_1)  ||                                  ((CHANNEL) == ADC_Channel_2)  ||                                  ((CHANNEL) == ADC_Channel_3)  ||                                  ((CHANNEL) == ADC_Channel_4)  ||                                  ((CHANNEL) == ADC_Channel_5)  ||                                  ((CHANNEL) == ADC_Channel_6)  ||                                  ((CHANNEL) == ADC_Channel_7)  ||                                  ((CHANNEL) == ADC_Channel_8)  ||                                  ((CHANNEL) == ADC_Channel_9)  ||                                  ((CHANNEL) == ADC_Channel_10) ||                                  ((CHANNEL) == ADC_Channel_11) ||                                  ((CHANNEL) == ADC_Channel_12) ||                                  ((CHANNEL) == ADC_Channel_13) ||                                  ((CHANNEL) == ADC_Channel_14) ||                                  ((CHANNEL) == ADC_Channel_15) ||                                  ((CHANNEL) == ADC_Channel_16) ||                                  ((CHANNEL) == ADC_Channel_17) ||                                  ((CHANNEL) == ADC_Channel_18))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_sampling_time 
N  * @{
N  */
N
N#define ADC_SampleTime_1Cycles5                    ((uint8_t)0x00)
N#define ADC_SampleTime_7Cycles5                    ADC_SMPR2_SMP0_0
N#define ADC_SampleTime_13Cycles5                   ADC_SMPR2_SMP0_1
N#define ADC_SampleTime_28Cycles5                   ((uint8_t)0x03)
N#define ADC_SampleTime_41Cycles5                   ADC_SMPR2_SMP0_2
N#define ADC_SampleTime_55Cycles5                   ((uint8_t)0x05)
N#define ADC_SampleTime_71Cycles5                   ((uint8_t)0x06)
N#define ADC_SampleTime_239Cycles5                  ((uint8_t)0x07)
N
N#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_7Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_13Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_28Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_41Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_55Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_71Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_239Cycles5))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) ||                                   ((TIME) == ADC_SampleTime_7Cycles5) ||                                   ((TIME) == ADC_SampleTime_13Cycles5) ||                                   ((TIME) == ADC_SampleTime_28Cycles5) ||                                   ((TIME) == ADC_SampleTime_41Cycles5) ||                                   ((TIME) == ADC_SampleTime_55Cycles5) ||                                   ((TIME) == ADC_SampleTime_71Cycles5) ||                                   ((TIME) == ADC_SampleTime_239Cycles5))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_external_trigger_sources_for_injected_channels_conversion 
N  * @{
N  */
N
N#define ADC_ExternalTrigInjecConv_T19_CC1           ((uint32_t)0x00000000)
N#define ADC_ExternalTrigInjecConv_T19_CC2           ADC_CR2_JEXTSEL_0
N#define ADC_ExternalTrigInjecConv_T2_TRGO           ADC_CR2_JEXTSEL_1
N#define ADC_ExternalTrigInjecConv_T2_CC1            ((uint32_t)0x00003000)
N#define ADC_ExternalTrigInjecConv_T3_CC4            ADC_CR2_JEXTSEL_2
N#define ADC_ExternalTrigInjecConv_T4_TRGO           ((uint32_t)0x00005000)
N#define ADC_ExternalTrigInjecConv_Ext_IT15          ((uint32_t)0x00006000)
N#define ADC_ExternalTrigInjecConv_None              ((uint32_t)0x00007000)
N
N#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T19_CC1) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T19_CC2) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1)  || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4)  || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15)|| \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_None))
X#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T19_CC1) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T19_CC2) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4)  ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15)||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_None))
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_injected_channel_selection 
N  * @{
N  */
N
N#define ADC_InjectedChannel_1                       ((uint8_t)0x14)
N#define ADC_InjectedChannel_2                       ((uint8_t)0x18)
N#define ADC_InjectedChannel_3                       ((uint8_t)0x1C)
N#define ADC_InjectedChannel_4                       ((uint8_t)0x20)
N#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_4))
X#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) ||                                           ((CHANNEL) == ADC_InjectedChannel_2) ||                                           ((CHANNEL) == ADC_InjectedChannel_3) ||                                           ((CHANNEL) == ADC_InjectedChannel_4))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_analog_watchdog_selection 
N  * @{
N  */
N
N#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
N#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
N#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200)
N#define ADC_AnalogWatchdog_AllRegEnable            ADC_CR1_AWDEN
N#define ADC_AnalogWatchdog_AllInjecEnable          ADC_CR1_JAWDEN
N#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
N#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
N
N#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
X#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_None))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_interrupts_definition 
N  * @{
N  */
N
N#define ADC_IT_EOC                                 ((uint16_t)0x0220)
N#define ADC_IT_AWD                                 ((uint16_t)0x0140)
N#define ADC_IT_JEOC                                ((uint16_t)0x0480)
N
N#define IS_ADC_IT(IT) ((((IT) & (uint16_t)0xF81F) == 0x00) && ((IT) != 0x00))
N
N#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
N                           ((IT) == ADC_IT_JEOC))
X#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) ||                            ((IT) == ADC_IT_JEOC))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_flags_definition 
N  * @{
N  */
N
N#define ADC_FLAG_AWD                               ADC_SR_AWD
N#define ADC_FLAG_EOC                               ADC_SR_EOC
N#define ADC_FLAG_JEOC                              ADC_SR_JEOC
N#define ADC_FLAG_JSTRT                             ADC_SR_JSTRT
N#define ADC_FLAG_STRT                              ADC_SR_STRT
N
N#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint8_t)0xE0) == 0x00) && ((FLAG) != 0x00))
N#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) || \
N                               ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) || \
N                               ((FLAG) == ADC_FLAG_STRT))
X#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) ||                                ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) ||                                ((FLAG) == ADC_FLAG_STRT))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_thresholds 
N  * @{
N  */
N
N#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_injected_offset 
N  * @{
N  */
N
N#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_injected_length 
N  * @{
N  */
N
N#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_injected_rank 
N  * @{
N  */
N
N#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup ADC_regular_length 
N  * @{
N  */
N
N#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
N/**
N  * @}
N  */
N
N/** @defgroup ADC_regular_rank 
N  * @{
N  */
N
N#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
N
N/**
N  * @}
N  */
N
N/** @defgroup ADC_regular_discontinuous_mode_number 
N  * @{
N  */
N
N#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/*  Function used to set the ADC configuration to the default reset state *****/
Nvoid ADC_DeInit(ADC_TypeDef* ADCx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_StartCalibration(ADC_TypeDef* ADCx);
Nvoid ADC_ResetCalibration(ADC_TypeDef* ADCx);
N
N/* Analog Watchdog configuration functions ************************************/
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);
N
N/* Temperature Sensor & Vrefint (Voltage Reference internal) management function */
Nvoid ADC_TempSensorVrefintCmd(FunctionalState NewState);
N
N/* Regular Channels Configuration functions ***********************************/
Nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
Nvoid ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_SoftwareStartConv(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
Nvoid ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nuint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
N
N/* Regular Channels DMA Configuration functions *******************************/
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
N
N/* Injected channels Configuration functions **********************************/
Nvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
Nvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
Nvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t ADC_Offset);
Nvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
Nvoid ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
NFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
Nvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nuint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);
N
N/* Interrupts and flags management functions **********************************/
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);
NFlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_ADC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 35 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_can.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_can.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_can.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the CAN firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_CAN_H
N#define __STM32F37X_CAN_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup CAN
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N#define IS_CAN_ALL_PERIPH(PERIPH) ((PERIPH) == CAN1)
N
N/** 
N  * @brief  CAN init structure definition
N  */
Ntypedef struct
N{
N  uint16_t CAN_Prescaler;   /*!< Specifies the length of a time quantum. 
N                                 It ranges from 1 to 1024. */
N  
N  uint8_t CAN_Mode;         /*!< Specifies the CAN operating mode.
N                                 This parameter can be a value of @ref CAN_operating_mode */
N
N  uint8_t CAN_SJW;          /*!< Specifies the maximum number of time quanta 
N                                 the CAN hardware is allowed to lengthen or 
N                                 shorten a bit to perform resynchronization.
N                                 This parameter can be a value of @ref CAN_synchronisation_jump_width */
N
N  uint8_t CAN_BS1;          /*!< Specifies the number of time quanta in Bit 
N                                 Segment 1. This parameter can be a value of 
N                                 @ref CAN_time_quantum_in_bit_segment_1 */
N
N  uint8_t CAN_BS2;          /*!< Specifies the number of time quanta in Bit Segment 2.
N                                 This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_2 */
N  
N  FunctionalState CAN_TTCM; /*!< Enable or disable the time triggered communication mode.
N                                This parameter can be set either to ENABLE or DISABLE. */
N  
N  FunctionalState CAN_ABOM;  /*!< Enable or disable the automatic bus-off management.
N                                  This parameter can be set either to ENABLE or DISABLE. */
N
N  FunctionalState CAN_AWUM;  /*!< Enable or disable the automatic wake-up mode. 
N                                  This parameter can be set either to ENABLE or DISABLE. */
N
N  FunctionalState CAN_NART;  /*!< Enable or disable the non-automatic retransmission mode.
N                                  This parameter can be set either to ENABLE or DISABLE. */
N
N  FunctionalState CAN_RFLM;  /*!< Enable or disable the Receive FIFO Locked mode.
N                                  This parameter can be set either to ENABLE or DISABLE. */
N
N  FunctionalState CAN_TXFP;  /*!< Enable or disable the transmit FIFO priority.
N                                  This parameter can be set either to ENABLE or DISABLE. */
N} CAN_InitTypeDef;
N
N/** 
N  * @brief  CAN filter init structure definition
N  */
Ntypedef struct
N{
N  uint16_t CAN_FilterIdHigh;         /*!< Specifies the filter identification number (MSBs for a 32-bit
N                                              configuration, first one for a 16-bit configuration).
N                                              This parameter can be a value between 0x0000 and 0xFFFF */
N
N  uint16_t CAN_FilterIdLow;          /*!< Specifies the filter identification number (LSBs for a 32-bit
N                                              configuration, second one for a 16-bit configuration).
N                                              This parameter can be a value between 0x0000 and 0xFFFF */
N
N  uint16_t CAN_FilterMaskIdHigh;     /*!< Specifies the filter mask number or identification number,
N                                              according to the mode (MSBs for a 32-bit configuration,
N                                              first one for a 16-bit configuration).
N                                              This parameter can be a value between 0x0000 and 0xFFFF */
N
N  uint16_t CAN_FilterMaskIdLow;      /*!< Specifies the filter mask number or identification number,
N                                              according to the mode (LSBs for a 32-bit configuration,
N                                              second one for a 16-bit configuration).
N                                              This parameter can be a value between 0x0000 and 0xFFFF */
N
N  uint16_t CAN_FilterFIFOAssignment; /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.
N                                              This parameter can be a value of @ref CAN_filter_FIFO */
N  
N  uint8_t CAN_FilterNumber;          /*!< Specifies the filter which will be initialized. It ranges from 0 to 13. */
N
N  uint8_t CAN_FilterMode;            /*!< Specifies the filter mode to be initialized.
N                                              This parameter can be a value of @ref CAN_filter_mode */
N
N  uint8_t CAN_FilterScale;           /*!< Specifies the filter scale.
N                                              This parameter can be a value of @ref CAN_filter_scale */
N
N  FunctionalState CAN_FilterActivation; /*!< Enable or disable the filter.
N                                              This parameter can be set either to ENABLE or DISABLE. */
N} CAN_FilterInitTypeDef;
N
N/** 
N  * @brief  CAN Tx message structure definition  
N  */
Ntypedef struct
N{
N  uint32_t StdId;  /*!< Specifies the standard identifier.
N                        This parameter can be a value between 0 to 0x7FF. */
N
N  uint32_t ExtId;  /*!< Specifies the extended identifier.
N                        This parameter can be a value between 0 to 0x1FFFFFFF. */
N
N  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
N                        will be transmitted. 
N                        This parameter can be a value of @ref CAN_identifier_type */
N
N  uint8_t RTR;     /*!< Specifies the type of frame for the message that will 
N                        be transmitted.
N                        This parameter can be a value of @ref CAN_remote_transmission_request */
N
N  uint8_t DLC;     /*!< Specifies the length of the frame that will be 
N                        transmitted. This parameter can be a value between 
N                        0 to 8 */
N
N  uint8_t Data[8]; /*!< Contains the data to be transmitted. It ranges from 0 
N                        to 0xFF. */
N} CanTxMsg;
N
N/** 
N  * @brief  CAN Rx message structure definition  
N  */
Ntypedef struct
N{
N  uint32_t StdId;  /*!< Specifies the standard identifier.
N                        This parameter can be a value between 0 to 0x7FF. */
N
N  uint32_t ExtId;  /*!< Specifies the extended identifier.
N                        This parameter can be a value between 0 to 0x1FFFFFFF. */
N
N  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
N                        will be received. 
N                        This parameter can be a value of @ref CAN_identifier_type */
N
N  uint8_t RTR;     /*!< Specifies the type of frame for the received message.
N                        This parameter can be a value of @ref CAN_remote_transmission_request */
N
N  uint8_t DLC;     /*!< Specifies the length of the frame that will be received.
N                        This parameter can be a value between 0 to 8 */
N
N  uint8_t Data[8]; /*!< Contains the data to be received. It ranges from 0 to 
N                        0xFF. */
N
N  uint8_t FMI;     /*!< Specifies the index of the filter the message stored in 
N                        the mailbox passes through. This parameter can be a 
N                        value between 0 to 0xFF */
N} CanRxMsg;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CAN_Exported_Constants
N  * @{
N  */
N
N/** @defgroup CAN_InitStatus 
N  * @{
N  */
N
N#define CAN_InitStatus_Failed              ((uint8_t)0x00) /*!< CAN initialization failed */
N#define CAN_InitStatus_Success             ((uint8_t)0x01) /*!< CAN initialization OK */
N
N
N/* Legacy defines */
N#define CANINITFAILED    CAN_InitStatus_Failed
N#define CANINITOK        CAN_InitStatus_Success
N/**
N  * @}
N  */
N
N/** @defgroup CAN_mode 
N  * @{
N  */
N
N#define CAN_Mode_Normal             ((uint8_t)0x00)  /*!< normal mode */
N#define CAN_Mode_LoopBack           ((uint8_t)0x01)  /*!< loopback mode */
N#define CAN_Mode_Silent             ((uint8_t)0x02)  /*!< silent mode */
N#define CAN_Mode_Silent_LoopBack    ((uint8_t)0x03)  /*!< loopback combined with silent mode */
N
N#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || \
N                           ((MODE) == CAN_Mode_LoopBack)|| \
N                           ((MODE) == CAN_Mode_Silent) || \
N                           ((MODE) == CAN_Mode_Silent_LoopBack))
X#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) ||                            ((MODE) == CAN_Mode_LoopBack)||                            ((MODE) == CAN_Mode_Silent) ||                            ((MODE) == CAN_Mode_Silent_LoopBack))
N/**
N  * @}
N  */
N
N
N /**
N  * @defgroup CAN_operating_mode 
N  * @{
N  */  
N#define CAN_OperatingMode_Initialization  ((uint8_t)0x00) /*!< Initialization mode */
N#define CAN_OperatingMode_Normal          ((uint8_t)0x01) /*!< Normal mode */
N#define CAN_OperatingMode_Sleep           ((uint8_t)0x02) /*!< sleep mode */
N
N
N#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||\
N                                    ((MODE) == CAN_OperatingMode_Normal)|| \
N                                    ((MODE) == CAN_OperatingMode_Sleep))
X#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||                                    ((MODE) == CAN_OperatingMode_Normal)||                                     ((MODE) == CAN_OperatingMode_Sleep))
N/**
N  * @}
N  */
N  
N/**
N  * @defgroup CAN_OperatingMode_status
N  * @{
N  */  
N
N#define CAN_ModeStatus_Failed    ((uint8_t)0x00)                /*!< CAN entering the specific mode failed */
N#define CAN_ModeStatus_Success   ((uint8_t)!CAN_ModeStatus_Failed)   /*!< CAN entering the specific mode Succeed */
N/**
N  * @}
N  */
N
N/** @defgroup CAN_synchronisation_jump_width 
N  * @{
N  */
N#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
N#define CAN_SJW_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
N#define CAN_SJW_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
N#define CAN_SJW_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
N
N#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \
N                         ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
X#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)||                          ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_time_quantum_in_bit_segment_1 
N  * @{
N  */
N#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
N#define CAN_BS1_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
N#define CAN_BS1_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
N#define CAN_BS1_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
N#define CAN_BS1_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
N#define CAN_BS1_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
N#define CAN_BS1_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
N#define CAN_BS1_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
N#define CAN_BS1_9tq                 ((uint8_t)0x08)  /*!< 9 time quantum */
N#define CAN_BS1_10tq                ((uint8_t)0x09)  /*!< 10 time quantum */
N#define CAN_BS1_11tq                ((uint8_t)0x0A)  /*!< 11 time quantum */
N#define CAN_BS1_12tq                ((uint8_t)0x0B)  /*!< 12 time quantum */
N#define CAN_BS1_13tq                ((uint8_t)0x0C)  /*!< 13 time quantum */
N#define CAN_BS1_14tq                ((uint8_t)0x0D)  /*!< 14 time quantum */
N#define CAN_BS1_15tq                ((uint8_t)0x0E)  /*!< 15 time quantum */
N#define CAN_BS1_16tq                ((uint8_t)0x0F)  /*!< 16 time quantum */
N
N#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16tq)
N/**
N  * @}
N  */
N
N/** @defgroup CAN_time_quantum_in_bit_segment_2 
N  * @{
N  */
N#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
N#define CAN_BS2_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
N#define CAN_BS2_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
N#define CAN_BS2_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
N#define CAN_BS2_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
N#define CAN_BS2_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
N#define CAN_BS2_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
N#define CAN_BS2_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
N
N#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8tq)
N/**
N  * @}
N  */
N
N/** @defgroup CAN_clock_prescaler 
N  * @{
N  */
N#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_FilterNumber 
N  * @{
N  */
N#define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 27)
N/**
N  * @}
N  */
N
N/** @defgroup CAN_FilterMode 
N  * @{
N  */
N#define CAN_FilterMode_IdMask       ((uint8_t)0x00)  /*!< identifier/mask mode */
N#define CAN_FilterMode_IdList       ((uint8_t)0x01)  /*!< identifier list mode */
N
N#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \
N                                  ((MODE) == CAN_FilterMode_IdList))
X#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) ||                                   ((MODE) == CAN_FilterMode_IdList))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_FilterScale 
N  * @{
N  */
N#define CAN_FilterScale_16bit       ((uint8_t)0x00) /*!< Two 16-bit filters */
N#define CAN_FilterScale_32bit       ((uint8_t)0x01) /*!< One 32-bit filter */
N
N#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \
N                                    ((SCALE) == CAN_FilterScale_32bit))
X#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) ||                                     ((SCALE) == CAN_FilterScale_32bit))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_FilterFIFO
N  * @{
N  */
N#define CAN_Filter_FIFO0             ((uint8_t)0x00)  /*!< Filter FIFO 0 assignment for filter x */
N#define CAN_Filter_FIFO1             ((uint8_t)0x01)  /*!< Filter FIFO 1 assignment for filter x */
N#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \
N                                  ((FIFO) == CAN_FilterFIFO1))
X#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) ||                                   ((FIFO) == CAN_FilterFIFO1))
N
N/* Legacy defines */
N#define CAN_FilterFIFO0  CAN_Filter_FIFO0
N#define CAN_FilterFIFO1  CAN_Filter_FIFO1
N/**
N  * @}
N  */
N
N/** @defgroup CAN_Start_bank_filter_for_slave_CAN 
N  * @{
N  */
N#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_Tx 
N  * @{
N  */
N#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((uint8_t)0x02))
N#define IS_CAN_STDID(STDID)   ((STDID) <= ((uint32_t)0x7FF))
N#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((uint32_t)0x1FFFFFFF))
N#define IS_CAN_DLC(DLC)       ((DLC) <= ((uint8_t)0x08))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_identifier_type 
N  * @{
N  */
N#define CAN_Id_Standard             ((uint32_t)0x00000000)  /*!< Standard Id */
N#define CAN_Id_Extended             ((uint32_t)0x00000004)  /*!< Extended Id */
N#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) || \
N                               ((IDTYPE) == CAN_Id_Extended))
X#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) ||                                ((IDTYPE) == CAN_Id_Extended))
N/* Legacy defines */
N#define CAN_ID_STD      CAN_Id_Standard           
N#define CAN_ID_EXT      CAN_Id_Extended
N/**
N  * @}
N  */
N
N/** @defgroup CAN_remote_transmission_request 
N  * @{
N  */
N#define CAN_RTR_Data                ((uint32_t)0x00000000)  /*!< Data frame */
N#define CAN_RTR_Remote              ((uint32_t)0x00000002)  /*!< Remote frame */
N#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_Data) || ((RTR) == CAN_RTR_Remote))
N/* Legacy defines */
N#define CAN_RTR_DATA     CAN_RTR_Data         
N#define CAN_RTR_REMOTE   CAN_RTR_Remote
N/**
N  * @}
N  */
N
N/** @defgroup CAN_transmit_constants 
N  * @{
N  */
N#define CAN_TxStatus_Failed         ((uint8_t)0x00)/*!< CAN transmission failed */
N#define CAN_TxStatus_Ok             ((uint8_t)0x01) /*!< CAN transmission succeeded */
N#define CAN_TxStatus_Pending        ((uint8_t)0x02) /*!< CAN transmission pending */
N#define CAN_TxStatus_NoMailBox      ((uint8_t)0x04) /*!< CAN cell did not provide 
N                                                         an empty mailbox */
N/* Legacy defines */	
N#define CANTXFAILED                  CAN_TxStatus_Failed
N#define CANTXOK                      CAN_TxStatus_Ok
N#define CANTXPENDING                 CAN_TxStatus_Pending
N#define CAN_NO_MB                    CAN_TxStatus_NoMailBox
N/**
N  * @}
N  */
N
N/** @defgroup CAN_receive_FIFO_number_constants 
N  * @{
N  */
N#define CAN_FIFO0                 ((uint8_t)0x00) /*!< CAN FIFO 0 used to receive */
N#define CAN_FIFO1                 ((uint8_t)0x01) /*!< CAN FIFO 1 used to receive */
N
N#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
N/**
N  * @}
N  */
N
N/** @defgroup CAN_sleep_constants 
N  * @{
N  */
N#define CAN_Sleep_Failed     ((uint8_t)0x00) /*!< CAN did not enter the sleep mode */
N#define CAN_Sleep_Ok         ((uint8_t)0x01) /*!< CAN entered the sleep mode */
N
N/* Legacy defines */	
N#define CANSLEEPFAILED   CAN_Sleep_Failed
N#define CANSLEEPOK       CAN_Sleep_Ok
N/**
N  * @}
N  */
N
N/** @defgroup CAN_wake_up_constants 
N  * @{
N  */
N#define CAN_WakeUp_Failed        ((uint8_t)0x00) /*!< CAN did not leave the sleep mode */
N#define CAN_WakeUp_Ok            ((uint8_t)0x01) /*!< CAN leaved the sleep mode */
N
N/* Legacy defines */
N#define CANWAKEUPFAILED   CAN_WakeUp_Failed        
N#define CANWAKEUPOK       CAN_WakeUp_Ok        
N/**
N  * @}
N  */
N
N/**
N  * @defgroup CAN_Error_Code_constants
N  * @{
N  */                                                         
N#define CAN_ErrorCode_NoErr           ((uint8_t)0x00) /*!< No Error */ 
N#define CAN_ErrorCode_StuffErr        ((uint8_t)0x10) /*!< Stuff Error */ 
N#define CAN_ErrorCode_FormErr         ((uint8_t)0x20) /*!< Form Error */ 
N#define CAN_ErrorCode_ACKErr          ((uint8_t)0x30) /*!< Acknowledgment Error */ 
N#define CAN_ErrorCode_BitRecessiveErr ((uint8_t)0x40) /*!< Bit Recessive Error */ 
N#define CAN_ErrorCode_BitDominantErr  ((uint8_t)0x50) /*!< Bit Dominant Error */ 
N#define CAN_ErrorCode_CRCErr          ((uint8_t)0x60) /*!< CRC Error  */ 
N#define CAN_ErrorCode_SoftwareSetErr  ((uint8_t)0x70) /*!< Software Set Error */ 
N/**
N  * @}
N  */
N
N/** @defgroup CAN_flags 
N  * @{
N  */
N/* If the flag is 0x3XXXXXXX, it means that it can be used with CAN_GetFlagStatus()
N   and CAN_ClearFlag() functions. */
N/* If the flag is 0x1XXXXXXX, it means that it can only be used with 
N   CAN_GetFlagStatus() function.  */
N
N/* Transmit Flags */
N#define CAN_FLAG_RQCP0             ((uint32_t)0x38000001) /*!< Request MailBox0 Flag */
N#define CAN_FLAG_RQCP1             ((uint32_t)0x38000100) /*!< Request MailBox1 Flag */
N#define CAN_FLAG_RQCP2             ((uint32_t)0x38010000) /*!< Request MailBox2 Flag */
N
N/* Receive Flags */
N#define CAN_FLAG_FMP0              ((uint32_t)0x12000003) /*!< FIFO 0 Message Pending Flag */
N#define CAN_FLAG_FF0               ((uint32_t)0x32000008) /*!< FIFO 0 Full Flag            */
N#define CAN_FLAG_FOV0              ((uint32_t)0x32000010) /*!< FIFO 0 Overrun Flag         */
N#define CAN_FLAG_FMP1              ((uint32_t)0x14000003) /*!< FIFO 1 Message Pending Flag */
N#define CAN_FLAG_FF1               ((uint32_t)0x34000008) /*!< FIFO 1 Full Flag            */
N#define CAN_FLAG_FOV1              ((uint32_t)0x34000010) /*!< FIFO 1 Overrun Flag         */
N
N/* Operating Mode Flags */
N#define CAN_FLAG_WKU               ((uint32_t)0x31000008) /*!< Wake up Flag */
N#define CAN_FLAG_SLAK              ((uint32_t)0x31000012) /*!< Sleep acknowledge Flag */
N/* @note When SLAK interrupt is disabled (SLKIE=0), no polling on SLAKI is possible. 
N         In this case the SLAK bit can be polled.*/
N
N/* Error Flags */
N#define CAN_FLAG_EWG               ((uint32_t)0x10F00001) /*!< Error Warning Flag   */
N#define CAN_FLAG_EPV               ((uint32_t)0x10F00002) /*!< Error Passive Flag   */
N#define CAN_FLAG_BOF               ((uint32_t)0x10F00004) /*!< Bus-Off Flag         */
N#define CAN_FLAG_LEC               ((uint32_t)0x30F00070) /*!< Last error code Flag */
N
N#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   || \
N                               ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   || \
N                               ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  || \
N                               ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  || \
N                               ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   || \
N                               ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) || \
N                               ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) || \
N                               ((FLAG) == CAN_FLAG_SLAK ))
X#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   ||                                ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   ||                                ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  ||                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  ||                                ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   ||                                ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) ||                                ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) ||                                ((FLAG) == CAN_FLAG_SLAK ))
N
N#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) || \
N                                ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) || \
N                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||\
N                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) || \
N                                ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))
X#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) ||                                 ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) ||                                 ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) ||                                 ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))
N/**
N  * @}
N  */
N
N  
N/** @defgroup CAN_interrupts 
N  * @{
N  */ 
N#define CAN_IT_TME                  ((uint32_t)0x00000001) /*!< Transmit mailbox empty Interrupt*/
N
N/* Receive Interrupts */
N#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/
N#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/
N#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/
N#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
N#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
N#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/
N
N/* Operating Mode Interrupts */
N#define CAN_IT_WKU                  ((uint32_t)0x00010000) /*!< Wake-up Interrupt*/
N#define CAN_IT_SLK                  ((uint32_t)0x00020000) /*!< Sleep acknowledge Interrupt*/
N
N/* Error Interrupts */
N#define CAN_IT_EWG                  ((uint32_t)0x00000100) /*!< Error warning Interrupt*/
N#define CAN_IT_EPV                  ((uint32_t)0x00000200) /*!< Error passive Interrupt*/
N#define CAN_IT_BOF                  ((uint32_t)0x00000400) /*!< Bus-off Interrupt*/
N#define CAN_IT_LEC                  ((uint32_t)0x00000800) /*!< Last error code Interrupt*/
N#define CAN_IT_ERR                  ((uint32_t)0x00008000) /*!< Error Interrupt*/
N
N/* Flags named as Interrupts : kept only for FW compatibility */
N#define CAN_IT_RQCP0   CAN_IT_TME
N#define CAN_IT_RQCP1   CAN_IT_TME
N#define CAN_IT_RQCP2   CAN_IT_TME
N
N
N#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||\
N                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||\
N                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||\
N                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||\
N                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||\
N                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||\
N                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))
X#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))
N
N#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||\
N                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||\
N                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||\
N                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||\
N                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||\
N                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))
X#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/  
N
N/*  Function used to set the CAN configuration to the default reset state *****/ 
Nvoid CAN_DeInit(CAN_TypeDef* CANx);
N
N/* Initialization and Configuration functions *********************************/ 
Nuint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct);
Nvoid CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);
Nvoid CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);
Nvoid CAN_SlaveStartBank(uint8_t CAN_BankNumber); 
Nvoid CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState);
Nvoid CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState);
N
N/* CAN Frames Transmission functions ******************************************/
Nuint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage);
Nuint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox);
Nvoid CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox);
N
N/* CAN Frames Reception functions *********************************************/
Nvoid CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage);
Nvoid CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber);
Nuint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber);
N
N/* Operation modes functions **************************************************/
Nuint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode);
Nuint8_t CAN_Sleep(CAN_TypeDef* CANx);
Nuint8_t CAN_WakeUp(CAN_TypeDef* CANx);
N
N/* CAN Bus Error management functions *****************************************/
Nuint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx);
Nuint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx);
Nuint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx);
N
N/* Interrupts and flags management functions **********************************/
Nvoid CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState);
NFlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
Nvoid CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
NITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT);
Nvoid CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_CAN_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 36 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_cec.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_cec.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_cec.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the CEC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F0XX_CEC_H
N#define __STM32F0XX_CEC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup CEC
N  * @{
N  */
N/* Exported types ------------------------------------------------------------*/
N  
N/** 
N  * @brief  CEC Init structure definition  
N  */
Ntypedef struct
N{
N  uint32_t CEC_SignalFreeTime;     /*!< Specifies the CEC Signal Free Time configuration.
N                                   This parameter can be a value of @ref CEC_Signal_Free_Time */
N  uint32_t CEC_RxTolerance;        /*!< Specifies the CEC Reception Tolerance.
N                                   This parameter can be a value of @ref CEC_RxTolerance */
N  uint32_t CEC_StopReception;      /*!< Specifies the CEC Stop Reception.
N                                   This parameter can be a value of @ref CEC_Stop_Reception */
N  uint32_t CEC_BitRisingError;     /*!< Specifies the CEC Bit Rising Error generation.
N                                   This parameter can be a value of @ref CEC_Bit_Rising_Error_Generation */
N  uint32_t CEC_LongBitPeriodError; /*!< Specifies the CEC Long Bit Error generation.
N                                   This parameter can be a value of @ref CEC_Long_Bit_Error_Generation */
N  uint32_t CEC_BRDNoGen;           /*!< Specifies the CEC Broadcast Error generation.
N                                   This parameter can be a value of @ref CEC_BDR_No_Gen */
N  uint32_t CEC_SFTOption;          /*!< Specifies the CEC Signal Free Time option.
N                                   This parameter can be a value of @ref CEC_SFT_Option */
N
N}CEC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CEC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup CEC_Signal_Free_Time
N  * @{
N  */
N#define CEC_SignalFreeTime_Standard     ((uint32_t)0x00000000) /*!< CEC Signal Free Time Standard     */
N#define CEC_SignalFreeTime_1T           ((uint32_t)0x00000001) /*!< CEC  1.5 nominal data bit periods */
N#define CEC_SignalFreeTime_2T           ((uint32_t)0x00000002) /*!< CEC  2.5 nominal data bit periods */
N#define CEC_SignalFreeTime_3T           ((uint32_t)0x00000003) /*!< CEC  3.5 nominal data bit periods */
N#define CEC_SignalFreeTime_4T           ((uint32_t)0x00000004) /*!< CEC  4.5 nominal data bit periods */
N#define CEC_SignalFreeTime_5T           ((uint32_t)0x00000005) /*!< CEC  5.5 nominal data bit periods */
N#define CEC_SignalFreeTime_6T           ((uint32_t)0x00000006) /*!< CEC  6.5 nominal data bit periods */
N#define CEC_SignalFreeTime_7T           ((uint32_t)0x00000007) /*!< CEC  7.5 nominal data bit periods */
N
N#define IS_CEC_SIGNAL_FREE_TIME(TIME) (((TIME) == CEC_SignalFreeTime_Standard) || \
N                                       ((TIME) == CEC_SignalFreeTime_1T)|| \
N                                       ((TIME) == CEC_SignalFreeTime_2T)|| \
N                                       ((TIME) == CEC_SignalFreeTime_3T)|| \
N                                       ((TIME) == CEC_SignalFreeTime_4T)|| \
N                                       ((TIME) == CEC_SignalFreeTime_5T)|| \
N                                       ((TIME) == CEC_SignalFreeTime_6T)|| \
N                                       ((TIME) == CEC_SignalFreeTime_7T))
X#define IS_CEC_SIGNAL_FREE_TIME(TIME) (((TIME) == CEC_SignalFreeTime_Standard) ||                                        ((TIME) == CEC_SignalFreeTime_1T)||                                        ((TIME) == CEC_SignalFreeTime_2T)||                                        ((TIME) == CEC_SignalFreeTime_3T)||                                        ((TIME) == CEC_SignalFreeTime_4T)||                                        ((TIME) == CEC_SignalFreeTime_5T)||                                        ((TIME) == CEC_SignalFreeTime_6T)||                                        ((TIME) == CEC_SignalFreeTime_7T))
N/**
N  * @}
N  */
N
N/** @defgroup CEC_RxTolerance
N  * @{
N  */
N#define CEC_RxTolerance_Standard        ((uint32_t)0x00000000) /*!< Standard Tolerance Margin              */
N#define CEC_RxTolerance_Extended        CEC_CFGR_RXTOL         /*!< Extended Tolerance Margin              */
N
N#define IS_CEC_RX_TOLERANCE(TOLERANCE) (((TOLERANCE) == CEC_RxTolerance_Standard) || \
N                                        ((TOLERANCE) == CEC_RxTolerance_Extended))
X#define IS_CEC_RX_TOLERANCE(TOLERANCE) (((TOLERANCE) == CEC_RxTolerance_Standard) ||                                         ((TOLERANCE) == CEC_RxTolerance_Extended))
N/**
N  * @}
N  */
N
N/** @defgroup CEC_Stop_Reception
N  * @{
N  */
N#define CEC_StopReception_Off           ((uint32_t)0x00000000) /*!< No RX Stop on bit Rising Error (BRE)    */
N#define CEC_StopReception_On            CEC_CFGR_BRESTP        /*!< RX Stop on bit Rising Error (BRE)       */
N
N#define IS_CEC_STOP_RECEPTION(RECEPTION) (((RECEPTION) == CEC_StopReception_On) || \
N                                          ((RECEPTION) == CEC_StopReception_Off))
X#define IS_CEC_STOP_RECEPTION(RECEPTION) (((RECEPTION) == CEC_StopReception_On) ||                                           ((RECEPTION) == CEC_StopReception_Off))
N/**
N  * @}
N  */
N
N/** @defgroup CEC_Bit_Rising_Error_Generation
N  * @{
N  */
N#define CEC_BitRisingError_Off          ((uint32_t)0x00000000)  /*!< Bit Rising Error generation turned Off */
N#define CEC_BitRisingError_On           CEC_CFGR_BREGEN         /*!< Bit Rising Error generation turned On */
N
N#define IS_CEC_BIT_RISING_ERROR(ERROR) (((ERROR) == CEC_BitRisingError_Off) || \
N                                        ((ERROR) == CEC_BitRisingError_On))
X#define IS_CEC_BIT_RISING_ERROR(ERROR) (((ERROR) == CEC_BitRisingError_Off) ||                                         ((ERROR) == CEC_BitRisingError_On))
N/**
N  * @}
N  */
N
N/** @defgroup CEC_Long_Bit_Error_Generation
N  * @{
N  */
N#define CEC_LongBitPeriodError_Off      ((uint32_t)0x00000000)  /*!< Long Bit Period Error generation turned Off */
N#define CEC_LongBitPeriodError_On       CEC_CFGR_LREGEN         /*!< Long Bit Period Error generation turned On */
N
N#define IS_CEC_LONG_BIT_PERIOD_ERROR(ERROR) (((ERROR) == CEC_LongBitPeriodError_Off) || \
N                                             ((ERROR) == CEC_LongBitPeriodError_On))
X#define IS_CEC_LONG_BIT_PERIOD_ERROR(ERROR) (((ERROR) == CEC_LongBitPeriodError_Off) ||                                              ((ERROR) == CEC_LongBitPeriodError_On))
N/**
N  * @}
N  */
N
N/** @defgroup CEC_SFT_Option
N  * @{
N  */
N#define CEC_SFTOption_Off              ((uint32_t)0x00000000)  /*!< SFT option turned Off                      */
N#define CEC_SFTOption_On               CEC_CFGR_SFTOPT         /*!< SFT option turned On                       */
N
N#define IS_CEC_SFT_OPTION(OPTION) (((OPTION) == CEC_SFTOption_Off) || \
N                                   ((OPTION) == CEC_SFTOption_On))
X#define IS_CEC_SFT_OPTION(OPTION) (((OPTION) == CEC_SFTOption_Off) ||                                    ((OPTION) == CEC_SFTOption_On))
N/**
N  * @}
N  */
N
N/** @defgroup CEC_BDR_No_Gen
N  * @{
N  */
N
N#define CEC_BRDNoGen_Off      ((uint32_t)0x00000000)  /*!< Broadcast Bit Rising Error generation turned Off */
N#define CEC_BRDNoGen_On       CEC_CFGR_BRDNOGEN       /*!< Broadcast Bit Rising Error generation turned On  */
N 
N#define IS_CEC_BDR_NO_GEN_ERROR(ERROR) (((ERROR) == CEC_BRDNoGen_Off) || \
N                                        ((ERROR) == CEC_BRDNoGen_On))
X#define IS_CEC_BDR_NO_GEN_ERROR(ERROR) (((ERROR) == CEC_BRDNoGen_Off) ||                                         ((ERROR) == CEC_BRDNoGen_On))
N/**
N  * @}
N  */
N
N/** @defgroup CEC_Own_Address
N  * @{
N  */
N#define IS_CEC_ADDRESS(ADDRESS)         ((ADDRESS) < 0x10)
N
N/**
N  * @}
N  */
N
N/** @defgroup CEC_Interrupt_Configuration_definition
N  * @{
N  */
N#define CEC_IT_TXACKE                   CEC_IER_TXACKEIE
N#define CEC_IT_TXERR                    CEC_IER_TXERRIE
N#define CEC_IT_TXUDR                    CEC_IER_TXUDRIE
N#define CEC_IT_TXEND                    CEC_IER_TXENDIE
N#define CEC_IT_TXBR                     CEC_IER_TXBRIE
N#define CEC_IT_ARBLST                   CEC_IER_ARBLSTIE
N#define CEC_IT_RXACKE                   CEC_IER_RXACKEIE
N#define CEC_IT_LBPE                     CEC_IER_LBPEIE
N#define CEC_IT_SBPE                     CEC_IER_SBPEIE
N#define CEC_IT_BRE                      CEC_IER_BREIEIE
N#define CEC_IT_RXOVR                    CEC_IER_RXOVRIE
N#define CEC_IT_RXEND                    CEC_IER_RXENDIE
N#define CEC_IT_RXBR                     CEC_IER_RXBRIE
N
N#define IS_CEC_IT(IT) ((((IT) & (uint32_t)0xFFFFE000) == 0x00) && ((IT) != 0x00))
N
N#define IS_CEC_GET_IT(IT) (((IT) == CEC_IT_TXACKE) || \
N                           ((IT) == CEC_IT_TXERR)|| \
N                           ((IT) == CEC_IT_TXUDR)|| \
N                           ((IT) == CEC_IT_TXEND)|| \
N                           ((IT) == CEC_IT_TXBR)|| \
N                           ((IT) == CEC_IT_ARBLST)|| \
N                           ((IT) == CEC_IT_RXACKE)|| \
N                           ((IT) == CEC_IT_LBPE)|| \
N                           ((IT) == CEC_IT_SBPE)|| \
N                           ((IT) == CEC_IT_BRE)|| \
N                           ((IT) == CEC_IT_RXOVR)|| \
N                           ((IT) == CEC_IT_RXEND)|| \
N                           ((IT) == CEC_IT_RXBR))
X#define IS_CEC_GET_IT(IT) (((IT) == CEC_IT_TXACKE) ||                            ((IT) == CEC_IT_TXERR)||                            ((IT) == CEC_IT_TXUDR)||                            ((IT) == CEC_IT_TXEND)||                            ((IT) == CEC_IT_TXBR)||                            ((IT) == CEC_IT_ARBLST)||                            ((IT) == CEC_IT_RXACKE)||                            ((IT) == CEC_IT_LBPE)||                            ((IT) == CEC_IT_SBPE)||                            ((IT) == CEC_IT_BRE)||                            ((IT) == CEC_IT_RXOVR)||                            ((IT) == CEC_IT_RXEND)||                            ((IT) == CEC_IT_RXBR))
N/**
N  * @}
N  */
N
N/** @defgroup CEC_ISR_register_flags_definition
N  * @{
N  */
N#define CEC_FLAG_TXACKE                 CEC_ISR_TXACKE
N#define CEC_FLAG_TXERR                  CEC_ISR_TXERR
N#define CEC_FLAG_TXUDR                  CEC_ISR_TXUDR
N#define CEC_FLAG_TXEND                  CEC_ISR_TXEND
N#define CEC_FLAG_TXBR                   CEC_ISR_TXBR
N#define CEC_FLAG_ARBLST                 CEC_ISR_ARBLST
N#define CEC_FLAG_RXACKE                 CEC_ISR_RXACKE
N#define CEC_FLAG_LBPE                   CEC_ISR_LBPE
N#define CEC_FLAG_SBPE                   CEC_ISR_SBPE
N#define CEC_FLAG_BRE                    CEC_ISR_BRE
N#define CEC_FLAG_RXOVR                  CEC_ISR_RXOVR
N#define CEC_FLAG_RXEND                  CEC_ISR_RXEND
N#define CEC_FLAG_RXBR                   CEC_ISR_RXBR
N
N#define IS_CEC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFE000) == 0x00) && ((FLAG) != 0x00))
N
N#define IS_CEC_GET_FLAG(FLAG) (((FLAG) == CEC_FLAG_TXACKE) || \
N                               ((FLAG) == CEC_FLAG_TXERR)|| \
N                               ((FLAG) == CEC_FLAG_TXUDR)|| \
N                               ((FLAG) == CEC_FLAG_TXEND)|| \
N                               ((FLAG) == CEC_FLAG_TXBR)|| \
N                               ((FLAG) == CEC_FLAG_ARBLST)|| \
N                               ((FLAG) == CEC_FLAG_RXACKE)|| \
N                               ((FLAG) == CEC_FLAG_LBPE)|| \
N                               ((FLAG) == CEC_FLAG_SBPE)|| \
N                               ((FLAG) == CEC_FLAG_BRE)|| \
N                               ((FLAG) == CEC_FLAG_RXOVR)|| \
N                               ((FLAG) == CEC_FLAG_RXEND)|| \
N                               ((FLAG) == CEC_FLAG_RXBR))
X#define IS_CEC_GET_FLAG(FLAG) (((FLAG) == CEC_FLAG_TXACKE) ||                                ((FLAG) == CEC_FLAG_TXERR)||                                ((FLAG) == CEC_FLAG_TXUDR)||                                ((FLAG) == CEC_FLAG_TXEND)||                                ((FLAG) == CEC_FLAG_TXBR)||                                ((FLAG) == CEC_FLAG_ARBLST)||                                ((FLAG) == CEC_FLAG_RXACKE)||                                ((FLAG) == CEC_FLAG_LBPE)||                                ((FLAG) == CEC_FLAG_SBPE)||                                ((FLAG) == CEC_FLAG_BRE)||                                ((FLAG) == CEC_FLAG_RXOVR)||                                ((FLAG) == CEC_FLAG_RXEND)||                                ((FLAG) == CEC_FLAG_RXBR))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the CEC configuration to the default reset state *****/
Nvoid CEC_DeInit(void);
N
N/* CEC_Initialization and Configuration functions *****************************/
Nvoid CEC_Init(CEC_InitTypeDef* CEC_InitStruct);
Nvoid CEC_StructInit(CEC_InitTypeDef* CEC_InitStruct);
Nvoid CEC_Cmd(FunctionalState NewState);
Nvoid CEC_ListenModeCmd(FunctionalState NewState);
Nvoid CEC_OwnAddressConfig(uint8_t CEC_OwnAddress);
Nvoid CEC_OwnAddressClear(void);
N
N/* CEC_Data transfers functions ***********************************************/
Nvoid CEC_SendData(uint8_t Data);
Nuint8_t CEC_ReceiveData(void);
Nvoid CEC_StartOfMessage(void);
Nvoid CEC_EndOfMessage(void);
N
N/* CEC_Interrupts and flags management functions ******************************/
Nvoid CEC_ITConfig(uint16_t CEC_IT, FunctionalState NewState);
NFlagStatus CEC_GetFlagStatus(uint16_t CEC_FLAG);
Nvoid CEC_ClearFlag(uint16_t CEC_FLAG);
NITStatus CEC_GetITStatus(uint16_t CEC_IT);
Nvoid CEC_ClearITPendingBit(uint16_t CEC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_CEC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 37 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_crc.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_crc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_crc.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the CRC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_CRC_H
N#define __STM32F37X_CRC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/*!< Includes ----------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup CRC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup CRC_ReverseInputData
N  * @{
N  */
N#define CRC_ReverseInputData_No             ((uint32_t)0x00000000) /*!< No reverse operation of Input Data */
N#define CRC_ReverseInputData_8bits          CRC_CR_REV_IN_0        /*!< Reverse operation of Input Data on 8 bits */
N#define CRC_ReverseInputData_16bits         CRC_CR_REV_IN_1        /*!< Reverse operation of Input Data on 16 bits */
N#define CRC_ReverseInputData_32bits         CRC_CR_REV_IN          /*!< Reverse operation of Input Data on 32 bits */
N
N#define IS_CRC_REVERSE_INPUT_DATA(DATA) (((DATA) == CRC_ReverseInputData_No)     || \
N                                         ((DATA) == CRC_ReverseInputData_8bits)  || \
N                                         ((DATA) == CRC_ReverseInputData_16bits) || \
N                                         ((DATA) == CRC_ReverseInputData_32bits))
X#define IS_CRC_REVERSE_INPUT_DATA(DATA) (((DATA) == CRC_ReverseInputData_No)     ||                                          ((DATA) == CRC_ReverseInputData_8bits)  ||                                          ((DATA) == CRC_ReverseInputData_16bits) ||                                          ((DATA) == CRC_ReverseInputData_32bits))
N
N/**
N  * @}
N  */
N
N/** @defgroup CRC_PolynomialSize
N  * @{
N  */
N#define CRC_PolSize_7                       CRC_CR_POLSIZE        /*!< 7-bit polynomial for CRC calculation */
N#define CRC_PolSize_8                       CRC_CR_POLSIZE_1      /*!< 8-bit polynomial for CRC calculation */
N#define CRC_PolSize_16                      CRC_CR_POLSIZE_0      /*!< 16-bit polynomial for CRC calculation */
N#define CRC_PolSize_32                      ((uint32_t)0x00000000)/*!< 32-bit polynomial for CRC calculation */
N
N#define IS_CRC_POL_SIZE(SIZE) (((SIZE) == CRC_PolSize_7)  || \
N                               ((SIZE) == CRC_PolSize_8)  || \
N                               ((SIZE) == CRC_PolSize_16) || \
N                               ((SIZE) == CRC_PolSize_32))
X#define IS_CRC_POL_SIZE(SIZE) (((SIZE) == CRC_PolSize_7)  ||                                ((SIZE) == CRC_PolSize_8)  ||                                ((SIZE) == CRC_PolSize_16) ||                                ((SIZE) == CRC_PolSize_32))
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/* Configuration of the CRC computation unit **********************************/
Nvoid CRC_DeInit(void);
Nvoid CRC_ResetDR(void);
Nvoid CRC_PolynomialSizeSelect(uint32_t CRC_PolSize);
Nvoid CRC_ReverseInputDataSelect(uint32_t CRC_ReverseInputData);
Nvoid CRC_ReverseOutputDataCmd(FunctionalState NewState);
Nvoid CRC_SetInitRegister(uint32_t CRC_InitValue);
Nvoid CRC_SetPolynomial(uint32_t CRC_Pol);
N
N/* CRC computation ************************************************************/
Nuint32_t CRC_CalcCRC(uint32_t CRC_Data);
Nuint32_t CRC_CalcCRC16bits(uint16_t CRC_Data);
Nuint32_t CRC_CalcCRC8bits(uint8_t CRC_Data);
Nuint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
Nuint32_t CRC_GetCRC(void);
N
N/* Independent register (IDR) access (write/read) *****************************/
Nvoid CRC_SetIDRegister(uint8_t CRC_IDValue);
Nuint8_t CRC_GetIDRegister(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_CRC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 38 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_comp.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_comp.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_comp.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the COMP firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_COMP_H
N#define __STM32F37X_COMP_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup COMP
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  COMP Init structure definition  
N  */
N  
Ntypedef struct
N{
N
N  uint32_t COMP_InvertingInput;     /*!< Selects the inverting input of the comparator.
N                                          This parameter can be a value of @ref COMP_InvertingInput */
N
N  uint32_t COMP_Output;             /*!< Selects the output redirection of the comparator.
N                                          This parameter can be a value of @ref COMP_Output */
N
N  uint32_t COMP_OutputPol;           /*!< Selects the output polarity of the comparator.
N                                          This parameter can be a value of @ref COMP_OutputPolarity */
N
N  uint32_t COMP_Hysteresis;         /*!< Selects the hysteresis voltage of the comparator.
N                                          This parameter can be a value of @ref COMP_Hysteresis */
N
N  uint32_t COMP_Mode;               /*!< Selects the operating mode of the comparator
N                                         and allows to adjust the speed/consumption.
N                                          This parameter can be a value of @ref COMP_Mode */
N
N}COMP_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N   
N/** @defgroup COMP_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup COMP_Selection
N  * @{
N  */
N
N#define COMP_Selection_COMP1                    ((uint32_t)0x00000000) /*!< COMP1 Selection */
N#define COMP_Selection_COMP2                    ((uint32_t)0x00000010) /*!< COMP2 Selection */
N
N#define IS_COMP_ALL_PERIPH(PERIPH) (((PERIPH) == COMP_Selection_COMP1) || \
N                                    ((PERIPH) == COMP_Selection_COMP2))
X#define IS_COMP_ALL_PERIPH(PERIPH) (((PERIPH) == COMP_Selection_COMP1) ||                                     ((PERIPH) == COMP_Selection_COMP2))
N 
N/**
N  * @}
N  */ 
N
N/** @defgroup COMP_InvertingInput
N  * @{
N  */
N
N#define COMP_InvertingInput_1_4VREFINT          ((uint32_t)0x00000000) /*!< 1/4 VREFINT connected to comparator inverting input */
N#define COMP_InvertingInput_1_2VREFINT          COMP_CSR_COMP1INSEL_0  /*!< 1/2 VREFINT connected to comparator inverting input */
N#define COMP_InvertingInput_3_4VREFINT          COMP_CSR_COMP1INSEL_1  /*!< 3/4 VREFINT connected to comparator inverting input */
N#define COMP_InvertingInput_VREFINT             ((uint32_t)0x00000030) /*!< VREFINT connected to comparator inverting input */
N#define COMP_InvertingInput_DAC1OUT1            COMP_CSR_COMP1INSEL_2  /*!< DAC1_OUT1 (PA4) connected to comparator inverting input */
N#define COMP_InvertingInput_DAC1OUT2            ((uint32_t)0x00000050) /*!< DAC1_OUT2 (PA5) connected to comparator inverting input */
N#define COMP_InvertingInput_DAC2OUT1            ((uint32_t)0x00000070) /*!< DAC2_OUT1 (PA6) connected to comparator inverting input */
N#define COMP_InvertingInput_IO                  ((uint32_t)0x00000060) /*!< I/O (PA0 for COMP1 and PA2 for COMP2) connected to comparator inverting input */
N
N#define IS_COMP_INVERTING_INPUT(INPUT) (((INPUT) == COMP_InvertingInput_1_4VREFINT) || \
N                                        ((INPUT) == COMP_InvertingInput_1_2VREFINT) || \
N                                        ((INPUT) == COMP_InvertingInput_3_4VREFINT) || \
N                                        ((INPUT) == COMP_InvertingInput_VREFINT)    || \
N                                        ((INPUT) == COMP_InvertingInput_DAC1OUT1)   || \
N                                        ((INPUT) == COMP_InvertingInput_DAC1OUT2)   || \
N                                        ((INPUT) == COMP_InvertingInput_DAC2OUT1)   || \
N                                        ((INPUT) == COMP_InvertingInput_IO))
X#define IS_COMP_INVERTING_INPUT(INPUT) (((INPUT) == COMP_InvertingInput_1_4VREFINT) ||                                         ((INPUT) == COMP_InvertingInput_1_2VREFINT) ||                                         ((INPUT) == COMP_InvertingInput_3_4VREFINT) ||                                         ((INPUT) == COMP_InvertingInput_VREFINT)    ||                                         ((INPUT) == COMP_InvertingInput_DAC1OUT1)   ||                                         ((INPUT) == COMP_InvertingInput_DAC1OUT2)   ||                                         ((INPUT) == COMP_InvertingInput_DAC2OUT1)   ||                                         ((INPUT) == COMP_InvertingInput_IO))
N/**
N  * @}
N  */ 
N  
N/** @defgroup COMP_Output
N  * @{
N  */
N
N#define COMP_Output_None                  ((uint32_t)0x00000000) /*!< COMP output isn't connected to other peripherals */
N#define COMP_Output_TIM5IC4               ((uint32_t)0x00000600) /*!< COMP output connected to TIM5 Input Capture 4 */
N#define COMP_Output_TIM4IC1               ((uint32_t)0x00000200) /*!< COMP output connected to TIM4 Input Capture 1 */
N#define COMP_Output_TIM5OCREFCLR          COMP_CSR_COMP1OUTSEL   /*!< COMP output connected to TIM5 OCREF Clear */
N#define COMP_Output_TIM4OCREFCLR          ((uint32_t)0x00000300) /*!< COMP output connected to TIM4 OCREF Clear */
N#define COMP_Output_TIM15BKIN             COMP_CSR_COMP1OUTSEL_0 /*!< COMP output connected to TIM15 Break Input (BKIN) */
N#define COMP_Output_TIM16BKIN             COMP_CSR_COMP1OUTSEL_0 /*!< COMP output connected to TIM16 Break Input (BKIN) */
N#define COMP_Output_TIM2IC4               COMP_CSR_COMP1OUTSEL_2 /*!< COMP output connected to TIM2 Input Capture 4 */
N#define COMP_Output_TIM2OCREFCLR          ((uint32_t)0x00000500) /*!< COMP output connected to TIM2 OCREF Clear */
N#define COMP_Output_TIM3IC1               ((uint32_t)0x00000600) /*!< COMP output connected to TIM3 Input Capture 1 */
N#define COMP_Output_TIM3OCREFCLR          COMP_CSR_COMP1OUTSEL   /*!< COMP output connected to TIM3 OCREF Clear */
N
N
N#define IS_COMP_OUTPUT(OUTPUT) (((OUTPUT) == COMP_Output_None)         || \
N                                ((OUTPUT) == COMP_Output_TIM5IC4)      || \
N                                ((OUTPUT) == COMP_Output_TIM4IC1)      || \
N                                ((OUTPUT) == COMP_Output_TIM5OCREFCLR) || \
N                                ((OUTPUT) == COMP_Output_TIM4OCREFCLR) || \
N                                ((OUTPUT) == COMP_Output_TIM15BKIN)    || \
N                                ((OUTPUT) == COMP_Output_TIM16BKIN)    || \
N                                ((OUTPUT) == COMP_Output_TIM2IC4)      || \
N                                ((OUTPUT) == COMP_Output_TIM2OCREFCLR) || \
N                                ((OUTPUT) == COMP_Output_TIM3IC1)      || \
N                                ((OUTPUT) == COMP_Output_TIM3OCREFCLR))
X#define IS_COMP_OUTPUT(OUTPUT) (((OUTPUT) == COMP_Output_None)         ||                                 ((OUTPUT) == COMP_Output_TIM5IC4)      ||                                 ((OUTPUT) == COMP_Output_TIM4IC1)      ||                                 ((OUTPUT) == COMP_Output_TIM5OCREFCLR) ||                                 ((OUTPUT) == COMP_Output_TIM4OCREFCLR) ||                                 ((OUTPUT) == COMP_Output_TIM15BKIN)    ||                                 ((OUTPUT) == COMP_Output_TIM16BKIN)    ||                                 ((OUTPUT) == COMP_Output_TIM2IC4)      ||                                 ((OUTPUT) == COMP_Output_TIM2OCREFCLR) ||                                 ((OUTPUT) == COMP_Output_TIM3IC1)      ||                                 ((OUTPUT) == COMP_Output_TIM3OCREFCLR))
N/**
N  * @}
N  */ 
N
N/** @defgroup COMP_OutputPolarity
N  * @{
N  */
N#define COMP_OutputPol_NonInverted          ((uint32_t)0x00000000)  /*!< COMP output on GPIO isn't inverted */
N#define COMP_OutputPol_Inverted             COMP_CSR_COMP1POL       /*!< COMP output on GPIO is inverted */
N
N#define IS_COMP_OUTPUT_POL(POL) (((POL) == COMP_OutputPol_NonInverted)  || \
N                                 ((POL) == COMP_OutputPol_Inverted))
X#define IS_COMP_OUTPUT_POL(POL) (((POL) == COMP_OutputPol_NonInverted)  ||                                  ((POL) == COMP_OutputPol_Inverted))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup COMP_Hysteresis
N  * @{
N  */
N/* Please refer to the electrical characteristics in the device datasheet for
N   the hysteresis level */
N#define COMP_Hysteresis_No                         0x00000000           /*!< No hysteresis */
N#define COMP_Hysteresis_Low                        COMP_CSR_COMP1HYST_0 /*!< Hysteresis level low */
N#define COMP_Hysteresis_Medium                     COMP_CSR_COMP1HYST_1 /*!< Hysteresis level medium */
N#define COMP_Hysteresis_High                       COMP_CSR_COMP1HYST   /*!< Hysteresis level high */
N
N#define IS_COMP_HYSTERESIS(HYSTERESIS)    (((HYSTERESIS) == COMP_Hysteresis_No) || \
N                                           ((HYSTERESIS) == COMP_Hysteresis_Low) || \
N                                           ((HYSTERESIS) == COMP_Hysteresis_Medium) || \
N                                           ((HYSTERESIS) == COMP_Hysteresis_High))
X#define IS_COMP_HYSTERESIS(HYSTERESIS)    (((HYSTERESIS) == COMP_Hysteresis_No) ||                                            ((HYSTERESIS) == COMP_Hysteresis_Low) ||                                            ((HYSTERESIS) == COMP_Hysteresis_Medium) ||                                            ((HYSTERESIS) == COMP_Hysteresis_High))
N/**
N  * @}
N  */
N
N/** @defgroup COMP_Mode
N  * @{
N  */
N/* Please refer to the electrical characteristics in the device datasheet for
N   the power consumption values */
N#define COMP_Mode_HighSpeed                     0x00000000           /*!< High Speed */
N#define COMP_Mode_MediumSpeed                   COMP_CSR_COMP1MODE_0 /*!< Medium Speed */
N#define COMP_Mode_LowPower                      COMP_CSR_COMP1MODE_1 /*!< Low power mode */
N#define COMP_Mode_UltraLowPower                 COMP_CSR_COMP1MODE   /*!< Ultra-low power mode */
N
N#define IS_COMP_MODE(MODE)    (((MODE) == COMP_Mode_UltraLowPower) || \
N                               ((MODE) == COMP_Mode_LowPower)      || \
N                               ((MODE) == COMP_Mode_MediumSpeed)   || \
N                               ((MODE) == COMP_Mode_HighSpeed))
X#define IS_COMP_MODE(MODE)    (((MODE) == COMP_Mode_UltraLowPower) ||                                ((MODE) == COMP_Mode_LowPower)      ||                                ((MODE) == COMP_Mode_MediumSpeed)   ||                                ((MODE) == COMP_Mode_HighSpeed))
N/**
N  * @}
N  */
N
N/** @defgroup COMP_OutputLevel
N  * @{
N  */ 
N/* When output polarity is not inverted, comparator output is high when
N   the non-inverting input is at a higher voltage than the inverting input */
N#define COMP_OutputLevel_High                   COMP_CSR_COMP1OUT
N/* When output polarity is not inverted, comparator output is low when
N   the non-inverting input is at a lower voltage than the inverting input*/
N#define COMP_OutputLevel_Low                    ((uint32_t)0x00000000)
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the COMP configuration to the default reset state ****/
Nvoid COMP_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid COMP_Init(uint32_t COMP_Selection, COMP_InitTypeDef* COMP_InitStruct);
Nvoid COMP_StructInit(COMP_InitTypeDef* COMP_InitStruct);
Nvoid COMP_Cmd(uint32_t COMP_Selection, FunctionalState NewState);
Nvoid COMP_SwitchCmd(FunctionalState NewState);
Nuint32_t COMP_GetOutputLevel(uint32_t COMP_Selection);
N
N/* Window mode control function ***********************************************/
Nvoid COMP_WindowCmd(FunctionalState NewState);
N
N/* COMP configuration locking function ****************************************/
Nvoid COMP_LockConfig(uint32_t COMP_Selection);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_COMP_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 39 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_dac.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_dac.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_dac.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the DAC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_DAC_H
N#define __STM32F37X_DAC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N 
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DAC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  DAC Init structure definition
N  */
N  
Ntypedef struct
N{
N  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.
N                                                  This parameter can be a value of @ref DAC_trigger_selection */
N
N  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves
N                                                  are generated, or whether no wave is generated.
N                                                  This parameter can be a value of @ref DAC_wave_generation */
N
N  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or
N                                                  the maximum amplitude triangle generation for the DAC channel. 
N                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */
N
N  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
N                                                  This parameter can be a value of @ref DAC_output_buffer */
N}DAC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DAC_Exported_Constants
N  * @{
N  */
N
N#define IS_DAC_ALL_PERIPH(PERIPH) (((PERIPH) == DAC1) || \
N                                   ((PERIPH) == DAC2))
X#define IS_DAC_ALL_PERIPH(PERIPH) (((PERIPH) == DAC1) ||                                    ((PERIPH) == DAC2))
N
N#define IS_DAC_LIST1_PERIPH(PERIPH) (((PERIPH) == DAC1))
N
N/** @defgroup DAC_trigger_selection 
N  * @{
N  */
N  
N#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DACx_DHRxxxx register 
N                                                                       has been loaded, and not by external trigger */
N#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC1/2 channel1/2 */
N#define DAC_Trigger_T3_TRGO                ((uint32_t)0x0000000C) /*!< TIM3 TRGO selected as external conversion trigger for DAC1/2 channel1/2 */
N#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC1/2 channel1/2 */
N#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!< TIM9 TRGO selected as external conversion trigger for DAC1 channel1/2 */
N#define DAC_Trigger_T18_TRGO               ((uint32_t)0x0000001C) /*!< TIM18 TRGO selected as external conversion trigger for DAC2 channel1 */
N#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC1/2 channel1/2 */
N#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC1/2 channel1/2 */
N#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC1/2 channel1/2 */
N#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC1/2 channel1/2 */
N
N#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
N                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T3_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T18_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
N                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
N                                 ((TRIGGER) == DAC_Trigger_Software))
X#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) ||                                  ((TRIGGER) == DAC_Trigger_T6_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T3_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T7_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T5_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T18_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T2_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_T4_TRGO) ||                                  ((TRIGGER) == DAC_Trigger_Ext_IT9) ||                                  ((TRIGGER) == DAC_Trigger_Software))
N                                 
N/**
N  * @}
N  */
N  
N/** @defgroup DAC_wave_generation 
N  * @{
N  */
N
N#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
N#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
N#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
N#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
N                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
N                                    ((WAVE) == DAC_WaveGeneration_Triangle))
X#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) ||                                     ((WAVE) == DAC_WaveGeneration_Noise) ||                                     ((WAVE) == DAC_WaveGeneration_Triangle))
N/**
N  * @}
N  */
N  
N/** @defgroup DAC_lfsrunmask_triangleamplitude
N  * @{
N  */
N
N#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
N#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
N#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
N#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
N#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */
N#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */
N#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */
N#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */
N#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */
N#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */
N#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */
N#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */
N#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */
N#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */
N#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */
N
N#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
N                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
N                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
X#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits1_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits2_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits3_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits4_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits5_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits6_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits7_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits8_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits9_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits10_0) ||                                                       ((VALUE) == DAC_LFSRUnmask_Bits11_0) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1) ||                                                       ((VALUE) == DAC_TriangleAmplitude_3) ||                                                       ((VALUE) == DAC_TriangleAmplitude_7) ||                                                       ((VALUE) == DAC_TriangleAmplitude_15) ||                                                       ((VALUE) == DAC_TriangleAmplitude_31) ||                                                       ((VALUE) == DAC_TriangleAmplitude_63) ||                                                       ((VALUE) == DAC_TriangleAmplitude_127) ||                                                       ((VALUE) == DAC_TriangleAmplitude_255) ||                                                       ((VALUE) == DAC_TriangleAmplitude_511) ||                                                       ((VALUE) == DAC_TriangleAmplitude_1023) ||                                                       ((VALUE) == DAC_TriangleAmplitude_2047) ||                                                       ((VALUE) == DAC_TriangleAmplitude_4095))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_output_buffer 
N  * @{
N  */
N
N#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
N#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
N#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
N                                           ((STATE) == DAC_OutputBuffer_Disable))
X#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) ||                                            ((STATE) == DAC_OutputBuffer_Disable))
N/**
N  * @}
N  */
N  
N/** @defgroup DAC_Channel_selection 
N  * @{
N  */
N
N#define DAC_Channel_1                      ((uint32_t)0x00000000)
N#define DAC_Channel_2                      ((uint32_t)0x00000010)
N#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
N                                 ((CHANNEL) == DAC_Channel_2))
X#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) ||                                  ((CHANNEL) == DAC_Channel_2))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data_alignment 
N  * @{
N  */
N
N#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
N#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
N#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
N#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
N                             ((ALIGN) == DAC_Align_12b_L) || \
N                             ((ALIGN) == DAC_Align_8b_R))
X#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) ||                              ((ALIGN) == DAC_Align_12b_L) ||                              ((ALIGN) == DAC_Align_8b_R))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_wave_generation 
N  * @{
N  */
N
N#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
N#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
N#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
N                           ((WAVE) == DAC_Wave_Triangle))
X#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) ||                            ((WAVE) == DAC_Wave_Triangle))
N/**
N  * @}
N  */
N
N/** @defgroup DAC_data 
N  * @{
N  */
N
N#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0) 
N
N/**
N  * @}
N  */
N
N/** @defgroup DAC_interrupts_definition 
N  * @{
N  */ 
N  
N#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)  
N#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR)) 
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup DAC_flags_definition 
N  * @{
N  */ 
N  
N#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)   
N  
N#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))  
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/*  Function used to set the DAC configuration to the default reset state *****/  
Nvoid DAC_DeInit(DAC_TypeDef* DACx);
N
N/*  DAC channels configuration: trigger, output buffer, data format functions */
Nvoid DAC_Init(DAC_TypeDef* DACx, uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
Nvoid DAC_Cmd(DAC_TypeDef* DACx, uint32_t DAC_Channel, FunctionalState NewState);
Nvoid DAC_SoftwareTriggerCmd(DAC_TypeDef* DACx, uint32_t DAC_Channel, FunctionalState NewState);
Nvoid DAC_DualSoftwareTriggerCmd(DAC_TypeDef* DACx, FunctionalState NewState);
Nvoid DAC_WaveGenerationCmd(DAC_TypeDef* DACx, uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
Nvoid DAC_SetChannel1Data(DAC_TypeDef* DACx, uint32_t DAC_Align, uint16_t Data);
Nvoid DAC_SetChannel2Data(DAC_TypeDef* DACx, uint32_t DAC_Align, uint16_t Data);
Nvoid DAC_SetDualChannelData(DAC_TypeDef* DACx, uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
Nuint16_t DAC_GetDataOutputValue(DAC_TypeDef* DACx, uint32_t DAC_Channel);
N
N/* DMA management functions ***************************************************/
Nvoid DAC_DMACmd(DAC_TypeDef* DACx, uint32_t DAC_Channel, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid DAC_ITConfig(DAC_TypeDef* DACx, uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);
NFlagStatus DAC_GetFlagStatus(DAC_TypeDef* DACx, uint32_t DAC_Channel, uint32_t DAC_FLAG);
Nvoid DAC_ClearFlag(DAC_TypeDef* DACx, uint32_t DAC_Channel, uint32_t DAC_FLAG);
NITStatus DAC_GetITStatus(DAC_TypeDef* DACx, uint32_t DAC_Channel, uint32_t DAC_IT);
Nvoid DAC_ClearITPendingBit(DAC_TypeDef* DACx, uint32_t DAC_Channel, uint32_t DAC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_DAC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 40 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_dbgmcu.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_dbgmcu.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_dbgmcu.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the DBGMCU firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_DBGMCU_H
N#define __STM32F37X_DBGMCU_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DBGMCU
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DBGMCU_Exported_Constants
N  * @{
N  */ 
N#define DBGMCU_SLEEP                          DBGMCU_CR_DBG_SLEEP
N#define DBGMCU_STOP                           DBGMCU_CR_DBG_STOP
N#define DBGMCU_STANDBY                        DBGMCU_CR_DBG_STANDBY
N#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFF8) == 0x00) && ((PERIPH) != 0x00))
N
N#define DBGMCU_TIM2_STOP             DBGMCU_APB1_FZ_DBG_TIM2_STOP
N#define DBGMCU_TIM3_STOP             DBGMCU_APB1_FZ_DBG_TIM3_STOP
N#define DBGMCU_TIM4_STOP             DBGMCU_APB1_FZ_DBG_TIM4_STOP
N#define DBGMCU_TIM5_STOP             DBGMCU_APB1_FZ_DBG_TIM5_STOP
N#define DBGMCU_TIM6_STOP             DBGMCU_APB1_FZ_DBG_TIM6_STOP
N#define DBGMCU_TIM7_STOP             DBGMCU_APB1_FZ_DBG_TIM7_STOP
N#define DBGMCU_TIM12_STOP            DBGMCU_APB1_FZ_DBG_TIM12_STOP
N#define DBGMCU_TIM13_STOP            DBGMCU_APB1_FZ_DBG_TIM13_STOP
N#define DBGMCU_TIM14_STOP            DBGMCU_APB1_FZ_DBG_TIM14_STOP
N#define DBGMCU_TIM18_STOP            DBGMCU_APB1_FZ_DBG_TIM18_STOP
N#define DBGMCU_RTC_STOP              DBGMCU_APB1_FZ_DBG_RTC_STOP
N#define DBGMCU_WWDG_STOP             DBGMCU_APB1_FZ_DBG_WWDG_STOP
N#define DBGMCU_IWDG_STOP             DBGMCU_APB1_FZ_DBG_IWDG_STOP
N#define DBGMCU_I2C1_SMBUS_TIMEOUT    DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT
N#define DBGMCU_I2C2_SMBUS_TIMEOUT    DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT
N#define DBGMCU_CAN1_STOP             DBGMCU_APB1_FZ_DBG_CAN1_STOP
N
N#define IS_DBGMCU_APB1PERIPH(PERIPH) ((((PERIPH) & 0xFD9FE000) == 0x00) && ((PERIPH) != 0x00))
N
N#define DBGMCU_TIM15_STOP            DBGMCU_APB2_FZ_DBG_TIM15_STOP
N#define DBGMCU_TIM16_STOP            DBGMCU_APB2_FZ_DBG_TIM16_STOP
N#define DBGMCU_TIM17_STOP            DBGMCU_APB2_FZ_DBG_TIM17_STOP
N#define DBGMCU_TIM19_STOP            DBGMCU_APB2_FZ_DBG_TIM19_STOP
N#define IS_DBGMCU_APB2PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFC3) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/* Device and Revision ID management functions ********************************/
Nuint32_t DBGMCU_GetREVID(void);
Nuint32_t DBGMCU_GetDEVID(void);
N
N/* Peripherals Configuration functions ****************************************/
Nvoid DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
Nvoid DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
Nvoid DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_DBGMCU_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 41 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_dma.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_dma.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_dma.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the DMA firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_DMA_H
N#define __STM32F37X_DMA_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup DMA
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  DMA Init structures definition
N  */
Ntypedef struct
N{
N  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx.              */
N
N  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx.                  */
N
N  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.
N                                        This parameter can be a value of @ref DMA_data_transfer_direction     */
N
N  uint16_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel. 
N                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
N                                        or DMA_MemoryDataSize members depending in the transfer direction.    */
N
N  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.
N                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */
N
N  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.
N                                        This parameter can be a value of @ref DMA_memory_incremented_mode     */
N
N  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
N                                        This parameter can be a value of @ref DMA_peripheral_data_size        */
N
N  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
N                                        This parameter can be a value of @ref DMA_memory_data_size            */
N
N  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.
N                                        This parameter can be a value of @ref DMA_circular_normal_mode
N                                        @note: The circular buffer mode cannot be used if the memory-to-memory
N                                              data transfer is configured on the selected Channel */
N
N  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.
N                                        This parameter can be a value of @ref DMA_priority_level              */
N
N  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.
N                                        This parameter can be a value of @ref DMA_memory_to_memory            */
N}DMA_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup DMA_Exported_Constants
N  * @{
N  */
N  
N#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \
N                                   ((PERIPH) == DMA1_Channel2) || \
N                                   ((PERIPH) == DMA1_Channel3) || \
N                                   ((PERIPH) == DMA1_Channel4) || \
N                                   ((PERIPH) == DMA1_Channel5) || \
N                                   ((PERIPH) == DMA1_Channel6) || \
N                                   ((PERIPH) == DMA1_Channel7) || \
N                                   ((PERIPH) == DMA2_Channel1) || \
N                                   ((PERIPH) == DMA2_Channel2) || \
N                                   ((PERIPH) == DMA2_Channel3) || \
N                                   ((PERIPH) == DMA2_Channel4) || \
N                                   ((PERIPH) == DMA2_Channel5))
X#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) ||                                    ((PERIPH) == DMA1_Channel2) ||                                    ((PERIPH) == DMA1_Channel3) ||                                    ((PERIPH) == DMA1_Channel4) ||                                    ((PERIPH) == DMA1_Channel5) ||                                    ((PERIPH) == DMA1_Channel6) ||                                    ((PERIPH) == DMA1_Channel7) ||                                    ((PERIPH) == DMA2_Channel1) ||                                    ((PERIPH) == DMA2_Channel2) ||                                    ((PERIPH) == DMA2_Channel3) ||                                    ((PERIPH) == DMA2_Channel4) ||                                    ((PERIPH) == DMA2_Channel5))
N
N/** @defgroup DMA_data_transfer_direction 
N  * @{
N  */
N
N#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)
N#define DMA_DIR_PeripheralDST              DMA_CCR_DIR
N
N#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralSRC) || \
N                         ((DIR) == DMA_DIR_PeripheralDST))
X#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralSRC) ||                          ((DIR) == DMA_DIR_PeripheralDST))
N/**
N  * @}
N  */
N
N
N/** @defgroup DMA_peripheral_incremented_mode 
N  * @{
N  */
N
N#define DMA_PeripheralInc_Disable          ((uint32_t)0x00000000)
N#define DMA_PeripheralInc_Enable           DMA_CCR_PINC
N
N#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Disable) || \
N                                            ((STATE) == DMA_PeripheralInc_Enable))
X#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Disable) ||                                             ((STATE) == DMA_PeripheralInc_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_incremented_mode 
N  * @{
N  */
N
N#define DMA_MemoryInc_Disable              ((uint32_t)0x00000000)
N#define DMA_MemoryInc_Enable               DMA_CCR_MINC
N
N#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Disable) || \
N                                        ((STATE) == DMA_MemoryInc_Enable))
X#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Disable) ||                                         ((STATE) == DMA_MemoryInc_Enable))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_peripheral_data_size 
N  * @{
N  */
N
N#define DMA_PeripheralDataSize_Byte        ((uint32_t)0x00000000)
N#define DMA_PeripheralDataSize_HalfWord    DMA_CCR_PSIZE_0
N#define DMA_PeripheralDataSize_Word        DMA_CCR_PSIZE_1
N
N#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
N                                           ((SIZE) == DMA_PeripheralDataSize_Word))
X#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) ||                                            ((SIZE) == DMA_PeripheralDataSize_HalfWord) ||                                            ((SIZE) == DMA_PeripheralDataSize_Word))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_data_size 
N  * @{
N  */
N
N#define DMA_MemoryDataSize_Byte            ((uint32_t)0x00000000)
N#define DMA_MemoryDataSize_HalfWord        DMA_CCR_MSIZE_0
N#define DMA_MemoryDataSize_Word            DMA_CCR_MSIZE_1
N
N#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \
N                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
N                                       ((SIZE) == DMA_MemoryDataSize_Word))
X#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) ||                                        ((SIZE) == DMA_MemoryDataSize_HalfWord) ||                                        ((SIZE) == DMA_MemoryDataSize_Word))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_circular_normal_mode 
N  * @{
N  */
N
N#define DMA_Mode_Normal                    ((uint32_t)0x00000000)
N#define DMA_Mode_Circular                  DMA_CCR_CIRC
N
N#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Normal) || ((MODE) == DMA_Mode_Circular))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_priority_level 
N  * @{
N  */
N
N#define DMA_Priority_VeryHigh              DMA_CCR_PL
N#define DMA_Priority_High                  DMA_CCR_PL_1
N#define DMA_Priority_Medium                DMA_CCR_PL_0
N#define DMA_Priority_Low                   ((uint32_t)0x00000000)
N
N#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \
N                                   ((PRIORITY) == DMA_Priority_High) || \
N                                   ((PRIORITY) == DMA_Priority_Medium) || \
N                                   ((PRIORITY) == DMA_Priority_Low))
X#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) ||                                    ((PRIORITY) == DMA_Priority_High) ||                                    ((PRIORITY) == DMA_Priority_Medium) ||                                    ((PRIORITY) == DMA_Priority_Low))
N/**
N  * @}
N  */
N
N/** @defgroup DMA_memory_to_memory 
N  * @{
N  */
N
N#define DMA_M2M_Disable                    ((uint32_t)0x00000000)
N#define DMA_M2M_Enable                     DMA_CCR_MEM2MEM
N
N#define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Disable) || ((STATE) == DMA_M2M_Enable))
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_interrupts_definition
N  * @{
N  */
N
N#define DMA_IT_TC                          ((uint32_t)0x00000002)
N#define DMA_IT_HT                          ((uint32_t)0x00000004)
N#define DMA_IT_TE                          ((uint32_t)0x00000008)
N#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFFF1) == 0x00) && ((IT) != 0x00))
N
N#define DMA1_IT_GL1                        ((uint32_t)0x00000001)
N#define DMA1_IT_TC1                        ((uint32_t)0x00000002)
N#define DMA1_IT_HT1                        ((uint32_t)0x00000004)
N#define DMA1_IT_TE1                        ((uint32_t)0x00000008)
N#define DMA1_IT_GL2                        ((uint32_t)0x00000010)
N#define DMA1_IT_TC2                        ((uint32_t)0x00000020)
N#define DMA1_IT_HT2                        ((uint32_t)0x00000040)
N#define DMA1_IT_TE2                        ((uint32_t)0x00000080)
N#define DMA1_IT_GL3                        ((uint32_t)0x00000100)
N#define DMA1_IT_TC3                        ((uint32_t)0x00000200)
N#define DMA1_IT_HT3                        ((uint32_t)0x00000400)
N#define DMA1_IT_TE3                        ((uint32_t)0x00000800)
N#define DMA1_IT_GL4                        ((uint32_t)0x00001000)
N#define DMA1_IT_TC4                        ((uint32_t)0x00002000)
N#define DMA1_IT_HT4                        ((uint32_t)0x00004000)
N#define DMA1_IT_TE4                        ((uint32_t)0x00008000)
N#define DMA1_IT_GL5                        ((uint32_t)0x00010000)
N#define DMA1_IT_TC5                        ((uint32_t)0x00020000)
N#define DMA1_IT_HT5                        ((uint32_t)0x00040000)
N#define DMA1_IT_TE5                        ((uint32_t)0x00080000)
N#define DMA1_IT_GL6                        ((uint32_t)0x00100000)
N#define DMA1_IT_TC6                        ((uint32_t)0x00200000)
N#define DMA1_IT_HT6                        ((uint32_t)0x00400000)
N#define DMA1_IT_TE6                        ((uint32_t)0x00800000)
N#define DMA1_IT_GL7                        ((uint32_t)0x01000000)
N#define DMA1_IT_TC7                        ((uint32_t)0x02000000)
N#define DMA1_IT_HT7                        ((uint32_t)0x04000000)
N#define DMA1_IT_TE7                        ((uint32_t)0x08000000)
N
N#define DMA2_IT_GL1                        ((uint32_t)0x10000001)
N#define DMA2_IT_TC1                        ((uint32_t)0x10000002)
N#define DMA2_IT_HT1                        ((uint32_t)0x10000004)
N#define DMA2_IT_TE1                        ((uint32_t)0x10000008)
N#define DMA2_IT_GL2                        ((uint32_t)0x10000010)
N#define DMA2_IT_TC2                        ((uint32_t)0x10000020)
N#define DMA2_IT_HT2                        ((uint32_t)0x10000040)
N#define DMA2_IT_TE2                        ((uint32_t)0x10000080)
N#define DMA2_IT_GL3                        ((uint32_t)0x10000100)
N#define DMA2_IT_TC3                        ((uint32_t)0x10000200)
N#define DMA2_IT_HT3                        ((uint32_t)0x10000400)
N#define DMA2_IT_TE3                        ((uint32_t)0x10000800)
N#define DMA2_IT_GL4                        ((uint32_t)0x10001000)
N#define DMA2_IT_TC4                        ((uint32_t)0x10002000)
N#define DMA2_IT_HT4                        ((uint32_t)0x10004000)
N#define DMA2_IT_TE4                        ((uint32_t)0x10008000)
N#define DMA2_IT_GL5                        ((uint32_t)0x10010000)
N#define DMA2_IT_TC5                        ((uint32_t)0x10020000)
N#define DMA2_IT_HT5                        ((uint32_t)0x10040000)
N#define DMA2_IT_TE5                        ((uint32_t)0x10080000)
N
N#define IS_DMA_CLEAR_IT(IT) (((((IT) & 0xF0000000) == 0x00) || (((IT) & 0xEFF00000) == 0x00)) && ((IT) != 0x00))
N
N#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \
N                           ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \
N                           ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \
N                           ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) || \
N                           ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) || \
N                           ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) || \
N                           ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) || \
N                           ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) || \
N                           ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) || \
N                           ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) || \
N                           ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) || \
N                           ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) || \
N                           ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) || \
N                           ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) || \
N                           ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) || \
N                           ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) || \
N                           ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) || \
N                           ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) || \
N                           ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) || \
N                           ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) || \
N                           ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) || \
N                           ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) || \
N                           ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \
N                           ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
X#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) ||                            ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) ||                            ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) ||                            ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) ||                            ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) ||                            ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) ||                            ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) ||                            ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) ||                            ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) ||                            ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) ||                            ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) ||                            ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) ||                            ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) ||                            ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) ||                            ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) ||                            ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) ||                            ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) ||                            ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) ||                            ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) ||                            ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) ||                            ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) ||                            ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) ||                            ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) ||                            ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))
N
N/**
N  * @}
N  */
N
N/** @defgroup DMA_flags_definition 
N  * @{
N  */
N  
N#define DMA1_FLAG_GL1                      ((uint32_t)0x00000001)
N#define DMA1_FLAG_TC1                      ((uint32_t)0x00000002)
N#define DMA1_FLAG_HT1                      ((uint32_t)0x00000004)
N#define DMA1_FLAG_TE1                      ((uint32_t)0x00000008)
N#define DMA1_FLAG_GL2                      ((uint32_t)0x00000010)
N#define DMA1_FLAG_TC2                      ((uint32_t)0x00000020)
N#define DMA1_FLAG_HT2                      ((uint32_t)0x00000040)
N#define DMA1_FLAG_TE2                      ((uint32_t)0x00000080)
N#define DMA1_FLAG_GL3                      ((uint32_t)0x00000100)
N#define DMA1_FLAG_TC3                      ((uint32_t)0x00000200)
N#define DMA1_FLAG_HT3                      ((uint32_t)0x00000400)
N#define DMA1_FLAG_TE3                      ((uint32_t)0x00000800)
N#define DMA1_FLAG_GL4                      ((uint32_t)0x00001000)
N#define DMA1_FLAG_TC4                      ((uint32_t)0x00002000)
N#define DMA1_FLAG_HT4                      ((uint32_t)0x00004000)
N#define DMA1_FLAG_TE4                      ((uint32_t)0x00008000)
N#define DMA1_FLAG_GL5                      ((uint32_t)0x00010000)
N#define DMA1_FLAG_TC5                      ((uint32_t)0x00020000)
N#define DMA1_FLAG_HT5                      ((uint32_t)0x00040000)
N#define DMA1_FLAG_TE5                      ((uint32_t)0x00080000)
N#define DMA1_FLAG_GL6                      ((uint32_t)0x00100000)
N#define DMA1_FLAG_TC6                      ((uint32_t)0x00200000)
N#define DMA1_FLAG_HT6                      ((uint32_t)0x00400000)
N#define DMA1_FLAG_TE6                      ((uint32_t)0x00800000)
N#define DMA1_FLAG_GL7                      ((uint32_t)0x01000000)
N#define DMA1_FLAG_TC7                      ((uint32_t)0x02000000)
N#define DMA1_FLAG_HT7                      ((uint32_t)0x04000000)
N#define DMA1_FLAG_TE7                      ((uint32_t)0x08000000)
N
N#define DMA2_FLAG_GL1                      ((uint32_t)0x10000001)
N#define DMA2_FLAG_TC1                      ((uint32_t)0x10000002)
N#define DMA2_FLAG_HT1                      ((uint32_t)0x10000004)
N#define DMA2_FLAG_TE1                      ((uint32_t)0x10000008)
N#define DMA2_FLAG_GL2                      ((uint32_t)0x10000010)
N#define DMA2_FLAG_TC2                      ((uint32_t)0x10000020)
N#define DMA2_FLAG_HT2                      ((uint32_t)0x10000040)
N#define DMA2_FLAG_TE2                      ((uint32_t)0x10000080)
N#define DMA2_FLAG_GL3                      ((uint32_t)0x10000100)
N#define DMA2_FLAG_TC3                      ((uint32_t)0x10000200)
N#define DMA2_FLAG_HT3                      ((uint32_t)0x10000400)
N#define DMA2_FLAG_TE3                      ((uint32_t)0x10000800)
N#define DMA2_FLAG_GL4                      ((uint32_t)0x10001000)
N#define DMA2_FLAG_TC4                      ((uint32_t)0x10002000)
N#define DMA2_FLAG_HT4                      ((uint32_t)0x10004000)
N#define DMA2_FLAG_TE4                      ((uint32_t)0x10008000)
N#define DMA2_FLAG_GL5                      ((uint32_t)0x10010000)
N#define DMA2_FLAG_TC5                      ((uint32_t)0x10020000)
N#define DMA2_FLAG_HT5                      ((uint32_t)0x10040000)
N#define DMA2_FLAG_TE5                      ((uint32_t)0x10080000)
N
N#define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) & 0xF0000000) == 0x00) || (((FLAG) & 0xEFF00000) == 0x00)) && ((FLAG) != 0x00))
N
N#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \
N                               ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \
N                               ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \
N                               ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) || \
N                               ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) || \
N                               ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) || \
N                               ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) || \
N                               ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) || \
N                               ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) || \
N                               ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) || \
N                               ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) || \
N                               ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) || \
N                               ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) || \
N                               ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) || \
N                               ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) || \
N                               ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) || \
N                               ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) || \
N                               ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) || \
N                               ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) || \
N                               ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) || \
N                               ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) || \
N                               ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \
N                               ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \
N                               ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
X#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) ||                                ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) ||                                ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) ||                                ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) ||                                ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) ||                                ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) ||                                ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) ||                                ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) ||                                ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) ||                                ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) ||                                ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) ||                                ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) ||                                ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) ||                                ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) ||                                ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) ||                                ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) ||                                ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) ||                                ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) ||                                ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) ||                                ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) ||                                ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) ||                                ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) ||                                ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) ||                                ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the DMA configuration to the default reset state ******/
Nvoid DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
Nvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);
N
N/* Data Counter functions******************************************************/ 
Nvoid DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);
Nuint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);
N
N/* Interrupts and flags management functions **********************************/
Nvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);
NFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);
Nvoid DMA_ClearFlag(uint32_t DMAy_FLAG);
NITStatus DMA_GetITStatus(uint32_t DMAy_IT);
Nvoid DMA_ClearITPendingBit(uint32_t DMAy_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_DMA_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 42 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_exti.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_exti.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_exti.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the EXTI firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_EXTI_H
N#define __STM32F37X_EXTI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup EXTI
N  * @{
N  */
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  EXTI mode enumeration  
N  */
N
Ntypedef enum
N{
N  EXTI_Mode_Interrupt = 0x00,
N  EXTI_Mode_Event = 0x04
N}EXTIMode_TypeDef;
N
N#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
N
N/** 
N  * @brief  EXTI Trigger enumeration
N  */
N
Ntypedef enum
N{
N  EXTI_Trigger_Rising = 0x08,
N  EXTI_Trigger_Falling = 0x0C,
N  EXTI_Trigger_Rising_Falling = 0x10
N}EXTITrigger_TypeDef;
N
N#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
N                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
N                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
X#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) ||                                   ((TRIGGER) == EXTI_Trigger_Falling) ||                                   ((TRIGGER) == EXTI_Trigger_Rising_Falling))
N/**
N  * @brief  EXTI Init Structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
N                                         This parameter can be any combination of @ref EXTI_Lines */
N
N  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
N                                         This parameter can be a value of @ref EXTIMode_TypeDef */
N
N  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
N                                         This parameter can be a value of @ref EXTIMode_TypeDef */
N
N  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
N                                         This parameter can be set either to ENABLE or DISABLE */
N}EXTI_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup EXTI_Exported_Constants
N  * @{
N  */
N
N/** @defgroup EXTI_Lines 
N  * @{
N  */
N
N#define EXTI_Line0       ((uint32_t)0x00000001)  /*!< External interrupt line 0  */
N#define EXTI_Line1       ((uint32_t)0x00000002)  /*!< External interrupt line 1  */
N#define EXTI_Line2       ((uint32_t)0x00000004)  /*!< External interrupt line 2  */
N#define EXTI_Line3       ((uint32_t)0x00000008)  /*!< External interrupt line 3  */
N#define EXTI_Line4       ((uint32_t)0x00000010)  /*!< External interrupt line 4  */
N#define EXTI_Line5       ((uint32_t)0x00000020)  /*!< External interrupt line 5  */
N#define EXTI_Line6       ((uint32_t)0x00000040)  /*!< External interrupt line 6  */
N#define EXTI_Line7       ((uint32_t)0x00000080)  /*!< External interrupt line 7  */
N#define EXTI_Line8       ((uint32_t)0x00000100)  /*!< External interrupt line 8  */
N#define EXTI_Line9       ((uint32_t)0x00000200)  /*!< External interrupt line 9  */
N#define EXTI_Line10      ((uint32_t)0x00000400)  /*!< External interrupt line 10 */
N#define EXTI_Line11      ((uint32_t)0x00000800)  /*!< External interrupt line 11 */
N#define EXTI_Line12      ((uint32_t)0x00001000)  /*!< External interrupt line 12 */
N#define EXTI_Line13      ((uint32_t)0x00002000)  /*!< External interrupt line 13 */
N#define EXTI_Line14      ((uint32_t)0x00004000)  /*!< External interrupt line 14 */
N#define EXTI_Line15      ((uint32_t)0x00008000)  /*!< External interrupt line 15 */
N#define EXTI_Line16      ((uint32_t)0x00010000)  /*!< External interrupt line 16 
N                                                      Connected to the PVD Output */
N#define EXTI_Line17      ((uint32_t)0x00020000)  /*!< Internal interrupt line 17 
N                                                      Connected to the RTC Alarm 
N                                                      event */
N#define EXTI_Line18      ((uint32_t)0x00040000)  /*!< Internal interrupt line 18 
N                                                      Connected to the USB Device
N                                                      Wakeup from suspend event */
N#define EXTI_Line19      ((uint32_t)0x00080000)  /*!< Internal interrupt line 19
N                                                      Connected to the RTC Tamper
N                                                      and Time Stamp events */
N#define EXTI_Line20      ((uint32_t)0x00100000)  /*!< Internal interrupt line 20
N                                                      Connected to the RTC wakeup
N                                                      event */
N#define EXTI_Line21      ((uint32_t)0x00200000)  /*!< Internal interrupt line 21
N                                                      Connected to the Comparator 1
N                                                      event */
N#define EXTI_Line22      ((uint32_t)0x00400000)  /*!< Internal interrupt line 22
N                                                      Connected to the Comparator 2
N                                                      event */
N#define EXTI_Line23      ((uint32_t)0x00800000)  /*!< Internal interrupt line 23
N                                                      Connected to the I2C1 wakeup
N                                                      event */
N#define EXTI_Line24      ((uint32_t)0x01000000)  /*!< Internal interrupt line 24
N                                                      Connected to the I2C2 wakeup
N                                                      event */
N#define EXTI_Line25      ((uint32_t)0x02000000)  /*!< Internal interrupt line 25
N                                                      Connected to the USART1 wakeup
N                                                      event */
N#define EXTI_Line26      ((uint32_t)0x04000000)  /*!< Internal interrupt line 26
N                                                      Connected to the USART2 wakeup
N                                                      event */
N#define EXTI_Line27      ((uint32_t)0x08000000)  /*!< Internal interrupt line 27
N                                                      Connected to the CEC wakeup
N                                                      event */
N#define EXTI_Line28      ((uint32_t)0x10000000)  /*!< Internal interrupt line 28
N                                                      Connected to the USART3 wakeup
N                                                      event */
N#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0x00) == 0x00) && ((LINE) != (uint16_t)0x00))
N
N#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
N                                ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
N                                ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
N                                ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
N                                ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
N                                ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
N                                ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
N                                ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
N                                ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
N                                ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) || \
N                                ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) || \
N                                ((LINE) == EXTI_Line22))
X#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) ||                                 ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) ||                                 ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) ||                                 ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) ||                                 ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) ||                                 ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) ||                                 ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) ||                                 ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) ||                                 ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) ||                                 ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) ||                                 ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||                                 ((LINE) == EXTI_Line22))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/* Function used to set the EXTI configuration to the default reset state *****/
Nvoid EXTI_DeInit(void);
N
N/* Initialization and Configuration functions *********************************/
Nvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearFlag(uint32_t EXTI_Line);
NITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
Nvoid EXTI_ClearITPendingBit(uint32_t EXTI_Line);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_EXTI_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 43 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_flash.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_flash.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_flash.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the FLASH 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_FLASH_H
N#define __STM32F37X_FLASH_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup FLASH
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/** 
N  * @brief FLASH Status  
N  */ 
Ntypedef enum
N{ 
N  FLASH_BUSY = 1,
N  FLASH_ERROR_WRP,
N  FLASH_ERROR_PROGRAM,
N  FLASH_COMPLETE,
N  FLASH_TIMEOUT
N}FLASH_Status;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup FLASH_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup FLASH_Latency 
N  * @{
N  */ 
N#define FLASH_Latency_0                ((uint8_t)0x0000)    /*!< FLASH Zero Latency cycle */
N#define FLASH_Latency_1                FLASH_ACR_LATENCY_0  /*!< FLASH One Latency cycle */
N#define FLASH_Latency_2                FLASH_ACR_LATENCY_1  /*!< FLASH Two Latency cycles */
N
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
N                                   ((LATENCY) == FLASH_Latency_1) || \
N                                   ((LATENCY) == FLASH_Latency_2))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) ||                                    ((LATENCY) == FLASH_Latency_1) ||                                    ((LATENCY) == FLASH_Latency_2))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Interrupts 
N  * @{
N  */
N   
N#define FLASH_IT_EOP                   FLASH_CR_EOPIE  /*!< End of programming interrupt source */
N#define FLASH_IT_ERR                   FLASH_CR_ERRIE  /*!< Error interrupt source */
N#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFFFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
N/**
N  * @}
N  */
N/** @defgroup FLASH_Address 
N  * @{
N  */
N  
N#define IS_FLASH_PROGRAM_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0803FFFF))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_OB_DATA_ADDRESS 
N  * @{
N  */  
N#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804) || ((ADDRESS) == 0x1FFFF806)) 
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_Write_Protection 
N  * @{
N  */
N  
N
N#define OB_WRP_Pages0to1               ((uint32_t)0x00000001) /* Write protection of page 0 to 1 */
N#define OB_WRP_Pages2to3               ((uint32_t)0x00000002) /* Write protection of page 2 to 3 */
N#define OB_WRP_Pages4to5               ((uint32_t)0x00000004) /* Write protection of page 4 to 5 */
N#define OB_WRP_Pages6to7               ((uint32_t)0x00000008) /* Write protection of page 6 to 7 */
N#define OB_WRP_Pages8to9               ((uint32_t)0x00000010) /* Write protection of page 8 to 9 */
N#define OB_WRP_Pages10to11             ((uint32_t)0x00000020) /* Write protection of page 10 to 11 */
N#define OB_WRP_Pages12to13             ((uint32_t)0x00000040) /* Write protection of page 12 to 13 */
N#define OB_WRP_Pages14to15             ((uint32_t)0x00000080) /* Write protection of page 14 to 15 */
N#define OB_WRP_Pages16to17             ((uint32_t)0x00000100) /* Write protection of page 16 to 17 */
N#define OB_WRP_Pages18to19             ((uint32_t)0x00000200) /* Write protection of page 18 to 19 */
N#define OB_WRP_Pages20to21             ((uint32_t)0x00000400) /* Write protection of page 20 to 21 */
N#define OB_WRP_Pages22to23             ((uint32_t)0x00000800) /* Write protection of page 22 to 23 */
N#define OB_WRP_Pages24to25             ((uint32_t)0x00001000) /* Write protection of page 24 to 25 */
N#define OB_WRP_Pages26to27             ((uint32_t)0x00002000) /* Write protection of page 26 to 27 */
N#define OB_WRP_Pages28to29             ((uint32_t)0x00004000) /* Write protection of page 28 to 29 */
N#define OB_WRP_Pages30to31             ((uint32_t)0x00008000) /* Write protection of page 30 to 31 */
N#define OB_WRP_Pages32to33             ((uint32_t)0x00010000) /* Write protection of page 32 to 33 */
N#define OB_WRP_Pages34to35             ((uint32_t)0x00020000) /* Write protection of page 34 to 35 */
N#define OB_WRP_Pages36to37             ((uint32_t)0x00040000) /* Write protection of page 36 to 37 */
N#define OB_WRP_Pages38to39             ((uint32_t)0x00080000) /* Write protection of page 38 to 39 */
N#define OB_WRP_Pages40to41             ((uint32_t)0x00100000) /* Write protection of page 40 to 41 */
N#define OB_WRP_Pages42to43             ((uint32_t)0x00200000) /* Write protection of page 42 to 43 */
N#define OB_WRP_Pages44to45             ((uint32_t)0x00400000) /* Write protection of page 44 to 45 */
N#define OB_WRP_Pages46to47             ((uint32_t)0x00800000) /* Write protection of page 46 to 47 */
N#define OB_WRP_Pages48to49             ((uint32_t)0x01000000) /* Write protection of page 48 to 49 */
N#define OB_WRP_Pages50to51             ((uint32_t)0x02000000) /* Write protection of page 50 to 51 */
N#define OB_WRP_Pages52to53             ((uint32_t)0x04000000) /* Write protection of page 52 to 53 */
N#define OB_WRP_Pages54to55             ((uint32_t)0x08000000) /* Write protection of page 54 to 55 */
N#define OB_WRP_Pages56to57             ((uint32_t)0x10000000) /* Write protection of page 56 to 57 */
N#define OB_WRP_Pages58to59             ((uint32_t)0x20000000) /* Write protection of page 58 to 59 */
N#define OB_WRP_Pages60to61             ((uint32_t)0x40000000) /* Write protection of page 60 to 61 */
N#define OB_WRP_Pages62to127            ((uint32_t)0x80000000) /* Write protection of page 62 to 127 */
N
N#define OB_WRP_AllPages                ((uint32_t)0xFFFFFFFF) /*!< Write protection of all Sectors */
N
N#define IS_OB_WRP(PAGE) (((PAGE) != 0x0000000))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_Read_Protection 
N  * @{
N  */ 
N
N/** 
N  * @brief  FLASH_Read_Protection_Level  
N  */ 
N#define OB_RDP_Level_0   ((uint8_t)0xAA)
N#define OB_RDP_Level_1   ((uint8_t)0xBB)
N/*#define OB_RDP_Level_2   ((uint8_t)0xCC)*/ /* Warning: When enabling read protection level 2 
N                                                it's no more possible to go back to level 1 or 0 */
N
N#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||\
N                          ((LEVEL) == OB_RDP_Level_1))/*||\
N                          ((LEVEL) == OB_RDP_Level_2))*/
X#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||                          ((LEVEL) == OB_RDP_Level_1)) 
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Option_Bytes_IWatchdog 
N  * @{
N  */
N
N#define OB_IWDG_SW                     ((uint8_t)0x01)  /*!< Software IWDG selected */
N#define OB_IWDG_HW                     ((uint8_t)0x00)  /*!< Hardware IWDG selected */
N#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_nRST_STOP 
N  * @{
N  */
N
N#define OB_STOP_NoRST                  ((uint8_t)0x02) /*!< No reset generated when entering in STOP */
N#define OB_STOP_RST                    ((uint8_t)0x00) /*!< Reset generated when entering in STOP */
N#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_nRST_STDBY 
N  * @{
N  */
N
N#define OB_STDBY_NoRST                 ((uint8_t)0x04) /*!< No reset generated when entering in STANDBY */
N#define OB_STDBY_RST                   ((uint8_t)0x00) /*!< Reset generated when entering in STANDBY */
N#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Option_Bytes_BOOT1
N  * @{
N  */
N
N#define OB_BOOT1_RESET                 ((uint8_t)0x00) /*!< BOOT1 Reset */
N#define OB_BOOT1_SET                   ((uint8_t)0x10) /*!< BOOT1 Set */
N#define IS_OB_BOOT1(BOOT1) (((BOOT1) == OB_BOOT1_RESET) || ((BOOT1) == OB_BOOT1_SET))
N
N/**
N  * @}
N  */  
N
N/** @defgroup FLASH_Option_Bytes_VDDA_Analog_Monitoring
N  * @{
N  */
N
N#define OB_VDDA_ANALOG_ON              ((uint8_t)0x20) /*!< Analog monitoring on VDDA Power source ON */
N#define OB_VDDA_ANALOG_OFF             ((uint8_t)0x00) /*!< Analog monitoring on VDDA Power source OFF */
N
N#define IS_OB_VDDA_ANALOG(ANALOG) (((ANALOG) == OB_VDDA_ANALOG_ON) || ((ANALOG) == OB_VDDA_ANALOG_OFF))
N
N/**
N  * @}
N  */ 
N/** @defgroup FLASH_Option_Bytes_VDD_Analog_Monitoring
N  * @{
N  */
N
N#define OB_VDD_SD12_ON              ((uint8_t)0x80) /*!< Analog monitoring on VDDA Power source ON */
N#define OB_VDD_SD12_OFF             ((uint8_t)0x00) /*!< Analog monitoring on VDDA Power source OFF */
N
N#define IS_OB_VDD_SD12(MODE) (((MODE) == OB_VDD_SD12_ON) || ((MODE) == OB_VDD_SD12_OFF))
N
N/**
N  * @}
N  */     
N
N/** @defgroup FLASH_Option_Bytes_SRAM_Parity_Enable 
N  * @{
N  */
N
N#define OB_SRAM_PARITY_SET              ((uint8_t)0x00) /*!< SRAM parity enable Set */
N#define OB_SRAM_PARITY_RESET            ((uint8_t)0x40) /*!< SRAM parity enable reset */
N
N#define IS_OB_SRAM_PARITY(PARITY) (((PARITY) == OB_SRAM_PARITY_SET) || ((PARITY) == OB_SRAM_PARITY_RESET))
N
N/**
N  * @}
N  */ 
N      
N/** @defgroup FLASH_Flags 
N  * @{
N  */ 
N
N#define FLASH_FLAG_BSY                 FLASH_SR_BSY     /*!< FLASH Busy flag */
N#define FLASH_FLAG_PGERR               FLASH_SR_PGERR   /*!< FLASH Programming error flag */
N#define FLASH_FLAG_WRPERR              FLASH_SR_WRPERR  /*!< FLASH Write protected error flag */
N#define FLASH_FLAG_EOP                 FLASH_SR_EOP     /*!< FLASH End of Programming flag */
N 
N#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFC3) == 0x00000000) && ((FLAG) != 0x00000000))
N
N#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_PGERR) || \
N                                  ((FLAG) == FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_EOP))
X#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_PGERR) ||                                   ((FLAG) == FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_EOP))
N/**
N  * @}
N  */ 
N
N/** @defgroup FLASH_Keys 
N  * @{
N  */ 
N#define RDP_KEY                  ((uint16_t)0x00A5)
N#define FLASH_KEY1               ((uint32_t)0x45670123)
N#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
N#define FLASH_OPTKEY1            FLASH_KEY1
N#define FLASH_OPTKEY2            FLASH_KEY2
N/**
N  * @}
N  */
N  
N/** @defgroup FLASH_Timeout_definition 
N  * @{
N  */ 
N
N#define FLASH_ER_PRG_TIMEOUT         ((uint32_t)0x000B0000) 
N
N/**
N  * @}
N  */
N
N/** @defgroup FLASH_Legacy 
N  * @{
N  */
N#define FLASH_WRProt_Pages0to1	       OB_WRP_Pages0to1
N#define FLASH_WRProt_Pages2to3	       OB_WRP_Pages2to3
N#define FLASH_WRProt_Pages4to5	       OB_WRP_Pages4to5
N#define FLASH_WRProt_Pages6to7	       OB_WRP_Pages6to7
N#define FLASH_WRProt_Pages8to9	       OB_WRP_Pages8to9
N#define FLASH_WRProt_Pages10to11	   OB_WRP_Pages10to11
N#define FLASH_WRProt_Pages12to13	   OB_WRP_Pages12to13
N#define FLASH_WRProt_Pages14to15	   OB_WRP_Pages14to15
N#define FLASH_WRProt_Pages16to17	   OB_WRP_Pages16to17
N#define FLASH_WRProt_Pages18to19	   OB_WRP_Pages18to19
N#define FLASH_WRProt_Pages20to21	   OB_WRP_Pages20to21
N#define FLASH_WRProt_Pages22to23	   OB_WRP_Pages22to23
N#define FLASH_WRProt_Pages24to25	   OB_WRP_Pages24to25
N#define FLASH_WRProt_Pages26to27	   OB_WRP_Pages26to27
N#define FLASH_WRProt_Pages28to29	   OB_WRP_Pages28to29
N#define FLASH_WRProt_Pages30to31	   OB_WRP_Pages30to31
N#define FLASH_WRProt_Pages32to33	   OB_WRP_Pages32to33
N#define FLASH_WRProt_Pages34to35	   OB_WRP_Pages34to35
N#define FLASH_WRProt_Pages36to37	   OB_WRP_Pages36to37
N#define FLASH_WRProt_Pages38to39	   OB_WRP_Pages38to39
N#define FLASH_WRProt_Pages40to41	   OB_WRP_Pages40to41
N#define FLASH_WRProt_Pages42to43	   OB_WRP_Pages42to43
N#define FLASH_WRProt_Pages44to45	   OB_WRP_Pages44to45
N#define FLASH_WRProt_Pages46to47	   OB_WRP_Pages46to47
N#define FLASH_WRProt_Pages48to49	   OB_WRP_Pages48to49
N#define FLASH_WRProt_Pages50to51	   OB_WRP_Pages50to51
N#define FLASH_WRProt_Pages52to53	   OB_WRP_Pages52to53
N#define FLASH_WRProt_Pages54to55	   OB_WRP_Pages54to55
N#define FLASH_WRProt_Pages56to57	   OB_WRP_Pages56to57
N#define FLASH_WRProt_Pages58to59	   OB_WRP_Pages58to59
N#define FLASH_WRProt_Pages60to61	   OB_WRP_Pages60to61
N#define FLASH_WRProt_Pages62to127	   OB_WRP_Pages62to127
N
N#define FLASH_WRProt_AllPages          OB_WRP_AllPages
N/**
N  * @}
N  */ 
N/**
N  * @}
N  */
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/* FLASH Interface configuration functions ************************************/
Nvoid FLASH_SetLatency(uint32_t FLASH_Latency);
Nvoid FLASH_HalfCycleAccessCmd(FunctionalState NewState);
Nvoid FLASH_PrefetchBufferCmd(FunctionalState NewState);
N
N/* FLASH Memory Programming functions *****************************************/
Nvoid FLASH_Unlock(void);
Nvoid FLASH_Lock(void);
NFLASH_Status FLASH_ErasePage(uint32_t Page_Address);
NFLASH_Status FLASH_EraseAllPages(void);
NFLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
NFLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
N
N/* FLASH Option Bytes Programming functions *****************************************/
Nvoid FLASH_OB_Unlock(void);
Nvoid FLASH_OB_Lock(void);
Nvoid FLASH_OB_Launch(void);
NFLASH_Status FLASH_OB_Erase(void);
NFLASH_Status FLASH_OB_ProgramData(uint32_t Address, uint8_t Data);
NFLASH_Status FLASH_OB_EnableWRP(uint32_t OB_WRP);
NFLASH_Status FLASH_OB_RDPConfig(uint8_t OB_RDP);
NFLASH_Status FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
NFLASH_Status FLASH_OB_BOOTConfig(uint8_t OB_BOOT1);
NFLASH_Status FLASH_OB_VDDAConfig(uint8_t OB_VDDA_ANALOG);
NFLASH_Status FLASH_OB_VDD_SD12Config(uint8_t OB_VDD_SD12);
NFLASH_Status FLASH_OB_SRAMParityConfig(uint8_t OB_SRAM_Parity);
NFLASH_Status FLASH_OB_WriteUser(uint8_t OB_USER);
Nuint8_t FLASH_OB_GetUser(void);
Nuint32_t FLASH_OB_GetWRP(void);
NFlagStatus FLASH_OB_GetRDP(void);
N
N/* FLASH Interrupts and flags management functions **********************************/
Nvoid FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
NFlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
Nvoid FLASH_ClearFlag(uint32_t FLASH_FLAG);
NFLASH_Status FLASH_GetStatus(void);
NFLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);
N
N
N/** @defgroup FLASH_Legacy 
N  * @{
N  */
N#define FLASH_EraseOptionBytes               FLASH_OB_Erase
N#define FLASH_EnableWriteProtection	         FLASH_OB_EnableWRP
N#define FLASH_UserOptionByteConfig	         FLASH_OB_UserConfig
N#define FLASH_ProgramOptionByteData          FLASH_OB_ProgramData
N#define FLASH_GetUserOptionByte	             FLASH_OB_GetUser
N#define FLASH_GetWriteProtectionOptionByte   FLASH_OB_GetWRP
N/**
N  * @}
N  */ 
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_FLASH_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 44 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_gpio.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_gpio.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_gpio.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the GPIO 
N  *          firmware library. 
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_GPIO_H
N#define __STM32F37X_GPIO_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup GPIO
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N 
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                    ((PERIPH) == GPIOB) || \
N                                    ((PERIPH) == GPIOC) || \
N                                    ((PERIPH) == GPIOD) || \
N                                    ((PERIPH) == GPIOE) || \
N                                    ((PERIPH) == GPIOF))  
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                     ((PERIPH) == GPIOB) ||                                     ((PERIPH) == GPIOC) ||                                     ((PERIPH) == GPIOD) ||                                     ((PERIPH) == GPIOE) ||                                     ((PERIPH) == GPIOF))  
N
N#define IS_GPIO_LIST_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
N                                     ((PERIPH) == GPIOB) || \
N                                     ((PERIPH) == GPIOD))
X#define IS_GPIO_LIST_PERIPH(PERIPH) (((PERIPH) == GPIOA) ||                                      ((PERIPH) == GPIOB) ||                                      ((PERIPH) == GPIOD))
N/** @defgroup Configuration_Mode_enumeration 
N  * @{
N  */
Ntypedef enum
N{
N  GPIO_Mode_IN   = 0x00, /*!< GPIO Input Mode */
N  GPIO_Mode_OUT  = 0x01, /*!< GPIO Output Mode */
N  GPIO_Mode_AF   = 0x02, /*!< GPIO Alternate function Mode */
N  GPIO_Mode_AN   = 0x03  /*!< GPIO Analog In/Out Mode      */
N}GPIOMode_TypeDef;
N
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)|| ((MODE) == GPIO_Mode_OUT) || \
N                            ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)|| ((MODE) == GPIO_Mode_OUT) ||                             ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))
N/**
N  * @}
N  */
N
N/** @defgroup Output_type_enumeration
N  * @{
N  */
Ntypedef enum
N{
N  GPIO_OType_PP = 0x00,
N  GPIO_OType_OD = 0x01
N}GPIOOType_TypeDef;
N
N#define IS_GPIO_OTYPE(OTYPE) (((OTYPE) == GPIO_OType_PP) || ((OTYPE) == GPIO_OType_OD))
N
N/**
N  * @}
N  */
N
N/** @defgroup Output_Maximum_frequency_enumeration 
N  * @{
N  */
Ntypedef enum
N{
N  GPIO_Speed_Level_1  = 0x01, /*!< Medium Speed */
N  GPIO_Speed_Level_2  = 0x02, /*!< Fast Speed   */
N  GPIO_Speed_Level_3  = 0x03  /*!< High Speed   */
N}GPIOSpeed_TypeDef;
N
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_Level_1) || ((SPEED) == GPIO_Speed_Level_2) || \
N                              ((SPEED) == GPIO_Speed_Level_3))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_Level_1) || ((SPEED) == GPIO_Speed_Level_2) ||                               ((SPEED) == GPIO_Speed_Level_3))
N/**
N  * @}
N  */
N
N/** @defgroup Configuration_Pull-Up_Pull-Down_enumeration 
N  * @{
N  */
Ntypedef enum
N{
N  GPIO_PuPd_NOPULL = 0x00,
N  GPIO_PuPd_UP     = 0x01,
N  GPIO_PuPd_DOWN   = 0x02
N}GPIOPuPd_TypeDef;
N
N#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) || \
N                            ((PUPD) == GPIO_PuPd_DOWN))
X#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) ||                             ((PUPD) == GPIO_PuPd_DOWN))
N/**
N  * @}
N  */
N
N/** @defgroup Bit_SET_and_Bit_RESET_enumeration
N  * @{
N  */
Ntypedef enum
N{
N  Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N
N#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N/**
N  * @}
N  */
N
N/**
N  * @brief  GPIO Init structure definition
N  */
Ntypedef struct
N{
N  uint32_t GPIO_Pin;              /*!< Specifies the GPIO pins to be configured.
N                                       This parameter can be any value of @ref GPIO_pins_define */
N
N  GPIOMode_TypeDef GPIO_Mode;     /*!< Specifies the operating mode for the selected pins.
N                                       This parameter can be a value of @ref GPIOMode_TypeDef   */
N
N  GPIOSpeed_TypeDef GPIO_Speed;   /*!< Specifies the speed for the selected pins.
N                                       This parameter can be a value of @ref GPIOSpeed_TypeDef  */
N
N  GPIOOType_TypeDef GPIO_OType;   /*!< Specifies the operating output type for the selected pins.
N                                       This parameter can be a value of @ref GPIOOType_TypeDef  */
N
N  GPIOPuPd_TypeDef GPIO_PuPd;     /*!< Specifies the operating Pull-up/Pull down for the selected pins.
N                                       This parameter can be a value of @ref GPIOPuPd_TypeDef   */
N}GPIO_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup GPIO_Exported_Constants
N  * @{
N  */
N
N/** @defgroup GPIO_pins_define 
N  * @{
N  */
N#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!< Pin 0 selected    */
N#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected    */
N#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!< Pin 2 selected    */
N#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!< Pin 3 selected    */
N#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!< Pin 4 selected    */
N#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!< Pin 5 selected    */
N#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!< Pin 6 selected    */
N#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!< Pin 7 selected    */
N#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!< Pin 8 selected    */
N#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected    */
N#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected   */
N#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!< Pin 11 selected   */
N#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!< Pin 12 selected   */
N#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!< Pin 13 selected   */
N#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!< Pin 14 selected   */
N#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!< Pin 15 selected   */
N#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!< All pins selected */
N
N#define IS_GPIO_PIN(PIN) ((PIN) != (uint16_t)0x00)
N
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
N                              ((PIN) == GPIO_Pin_1) || \
N                              ((PIN) == GPIO_Pin_2) || \
N                              ((PIN) == GPIO_Pin_3) || \
N                              ((PIN) == GPIO_Pin_4) || \
N                              ((PIN) == GPIO_Pin_5) || \
N                              ((PIN) == GPIO_Pin_6) || \
N                              ((PIN) == GPIO_Pin_7) || \
N                              ((PIN) == GPIO_Pin_8) || \
N                              ((PIN) == GPIO_Pin_9) || \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                               ((PIN) == GPIO_Pin_1) ||                               ((PIN) == GPIO_Pin_2) ||                               ((PIN) == GPIO_Pin_3) ||                               ((PIN) == GPIO_Pin_4) ||                               ((PIN) == GPIO_Pin_5) ||                               ((PIN) == GPIO_Pin_6) ||                               ((PIN) == GPIO_Pin_7) ||                               ((PIN) == GPIO_Pin_8) ||                               ((PIN) == GPIO_Pin_9) ||                               ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Pin_sources 
N  * @{
N  */
N#define GPIO_PinSource0            ((uint8_t)0x00)
N#define GPIO_PinSource1            ((uint8_t)0x01)
N#define GPIO_PinSource2            ((uint8_t)0x02)
N#define GPIO_PinSource3            ((uint8_t)0x03)
N#define GPIO_PinSource4            ((uint8_t)0x04)
N#define GPIO_PinSource5            ((uint8_t)0x05)
N#define GPIO_PinSource6            ((uint8_t)0x06)
N#define GPIO_PinSource7            ((uint8_t)0x07)
N#define GPIO_PinSource8            ((uint8_t)0x08)
N#define GPIO_PinSource9            ((uint8_t)0x09)
N#define GPIO_PinSource10           ((uint8_t)0x0A)
N#define GPIO_PinSource11           ((uint8_t)0x0B)
N#define GPIO_PinSource12           ((uint8_t)0x0C)
N#define GPIO_PinSource13           ((uint8_t)0x0D)
N#define GPIO_PinSource14           ((uint8_t)0x0E)
N#define GPIO_PinSource15           ((uint8_t)0x0F)
N
N#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
N                                       ((PINSOURCE) == GPIO_PinSource1) || \
N                                       ((PINSOURCE) == GPIO_PinSource2) || \
N                                       ((PINSOURCE) == GPIO_PinSource3) || \
N                                       ((PINSOURCE) == GPIO_PinSource4) || \
N                                       ((PINSOURCE) == GPIO_PinSource5) || \
N                                       ((PINSOURCE) == GPIO_PinSource6) || \
N                                       ((PINSOURCE) == GPIO_PinSource7) || \
N                                       ((PINSOURCE) == GPIO_PinSource8) || \
N                                       ((PINSOURCE) == GPIO_PinSource9) || \
N                                       ((PINSOURCE) == GPIO_PinSource10) || \
N                                       ((PINSOURCE) == GPIO_PinSource11) || \
N                                       ((PINSOURCE) == GPIO_PinSource12) || \
N                                       ((PINSOURCE) == GPIO_PinSource13) || \
N                                       ((PINSOURCE) == GPIO_PinSource14) || \
N                                       ((PINSOURCE) == GPIO_PinSource15))
X#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) ||                                        ((PINSOURCE) == GPIO_PinSource1) ||                                        ((PINSOURCE) == GPIO_PinSource2) ||                                        ((PINSOURCE) == GPIO_PinSource3) ||                                        ((PINSOURCE) == GPIO_PinSource4) ||                                        ((PINSOURCE) == GPIO_PinSource5) ||                                        ((PINSOURCE) == GPIO_PinSource6) ||                                        ((PINSOURCE) == GPIO_PinSource7) ||                                        ((PINSOURCE) == GPIO_PinSource8) ||                                        ((PINSOURCE) == GPIO_PinSource9) ||                                        ((PINSOURCE) == GPIO_PinSource10) ||                                        ((PINSOURCE) == GPIO_PinSource11) ||                                        ((PINSOURCE) == GPIO_PinSource12) ||                                        ((PINSOURCE) == GPIO_PinSource13) ||                                        ((PINSOURCE) == GPIO_PinSource14) ||                                        ((PINSOURCE) == GPIO_PinSource15))
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Alternate_function_selection_define 
N  * @{
N  */
N
N/** 
N  * @brief  AF 0 selection
N  */
N#define GPIO_AF_0            ((uint8_t)0x00) /* MCO, JTMS-SWDAT, JTCK-SWCLK, JTDI,
N                                               JTDO, JTRST, TRACECLK, TRACED, TRACEWO */
N/**
N  * @brief  AF 1 selection
N  */
N#define GPIO_AF_1            ((uint8_t)0x01) /* TIM2, TIM15, TIM16, TIM17, OUT */
N
N/**
N  * @brief  AF 2 selection
N  */
N#define GPIO_AF_2            ((uint8_t)0x02) /* TIM3, TIM4, TIM5, TIM13, TIM14, TIM19 */
N
N/**
N  * @brief  AF 3 selection
N  */
N#define GPIO_AF_3            ((uint8_t)0x03) /* Touch */
N
N/**
N  * @brief  AF 4 selection
N  */
N#define GPIO_AF_4            ((uint8_t)0x04) /* I2C1, I2C2 */
N
N/**
N  * @brief  AF 5 selection
N  */
N#define GPIO_AF_5            ((uint8_t)0x05) /* SPI1, SPI2, IR_OUT */
N
N/** 
N  * @brief  AF 6 selection
N  */
N#define GPIO_AF_6            ((uint8_t)0x06) /* SPI1, SPI3, CEC, IR_OUT */
N
N/** 
N  * @brief  AF 7 selection
N  */
N#define GPIO_AF_7            ((uint8_t)0x07) /* USART1, USART2, USART3, CAN, CEC*/
N
N/**
N  * @brief  AF 8 selection
N  */
N#define GPIO_AF_8            ((uint8_t)0x08) /* COMP1_OUT, COMP2_OUT */
N
N/**
N  * @brief  AF 9 selection
N  */
N#define GPIO_AF_9            ((uint8_t)0x09) /* CAN, TIM12, TIM13, TIM14, TIM15 */
N
N/**
N  * @brief  AF 10 selection
N  */
N#define GPIO_AF_10            ((uint8_t)0x0A) /* TIM2, TIM3, TIM4, TIM12, TIM17 */
N
N/**
N  * @brief  AF 11 selection
N  */
N#define GPIO_AF_11            ((uint8_t)0x0B) /* TIM19 */
N
N/**
N  * @brief  AF 14 selection
N  */
N#define GPIO_AF_14            ((uint8_t)0x0E) /* USBDM, USBDP */
N
N/**
N  * @brief  AF 15 selection
N  */
N#define GPIO_AF_15            ((uint8_t)0x0F) /* OUT */
N
N#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_0)||((AF) == GPIO_AF_1)||\
N                          ((AF) == GPIO_AF_2)||((AF) == GPIO_AF_3)||\
N                          ((AF) == GPIO_AF_4)||((AF) == GPIO_AF_5)||\
N                          ((AF) == GPIO_AF_6)||((AF) == GPIO_AF_7)||\
N                          ((AF) == GPIO_AF_8)||((AF) == GPIO_AF_9)||\
N                          ((AF) == GPIO_AF_10)||((AF) == GPIO_AF_11)||\
N                          ((AF) == GPIO_AF_14)||((AF) == GPIO_AF_15))
X#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_0)||((AF) == GPIO_AF_1)||                          ((AF) == GPIO_AF_2)||((AF) == GPIO_AF_3)||                          ((AF) == GPIO_AF_4)||((AF) == GPIO_AF_5)||                          ((AF) == GPIO_AF_6)||((AF) == GPIO_AF_7)||                          ((AF) == GPIO_AF_8)||((AF) == GPIO_AF_9)||                          ((AF) == GPIO_AF_10)||((AF) == GPIO_AF_11)||                          ((AF) == GPIO_AF_14)||((AF) == GPIO_AF_15))
N
N/**
N  * @}
N  */
N
N/** @defgroup GPIO_Speed_Legacy 
N  * @{
N  */
N
N#define GPIO_Speed_10MHz GPIO_Speed_Level_1   /*!< Fast Speed:10MHz   */
N#define GPIO_Speed_2MHz  GPIO_Speed_Level_2   /*!< Medium Speed:2MHz  */
N#define GPIO_Speed_50MHz GPIO_Speed_Level_3   /*!< High Speed:50MHz   */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/* Function used to set the GPIO configuration to the default reset state *****/
Nvoid GPIO_DeInit(GPIO_TypeDef* GPIOx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
N
N/* GPIO Read and Write functions **********************************************/
Nuint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
Nuint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nuint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
Nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
Nvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
Nvoid GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
N
N/* GPIO Alternate functions configuration functions ***************************/
Nvoid GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_GPIO_H */
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 45 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_syscfg.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_syscfg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_syscfg.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the SYSCFG firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/*!< Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_SYSCFG_H
N#define __STM32F37X_SYSCFG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/*!< Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SYSCFG
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SYSCFG_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup SYSCFG_EXTI_Port_Sources 
N  * @{
N  */ 
N#define EXTI_PortSourceGPIOA       ((uint8_t)0x00)
N#define EXTI_PortSourceGPIOB       ((uint8_t)0x01)
N#define EXTI_PortSourceGPIOC       ((uint8_t)0x02)
N#define EXTI_PortSourceGPIOD       ((uint8_t)0x03)
N#define EXTI_PortSourceGPIOE       ((uint8_t)0x04)
N#define EXTI_PortSourceGPIOF       ((uint8_t)0x05)
N
N#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOB) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOC) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOD) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOE) || \
N                                         ((PORTSOURCE) == EXTI_PortSourceGPIOF)) 
X#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOB) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOC) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOD) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOE) ||                                          ((PORTSOURCE) == EXTI_PortSourceGPIOF)) 
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_EXTI_Pin_sources 
N  * @{
N  */ 
N#define EXTI_PinSource0            ((uint8_t)0x00)
N#define EXTI_PinSource1            ((uint8_t)0x01)
N#define EXTI_PinSource2            ((uint8_t)0x02)
N#define EXTI_PinSource3            ((uint8_t)0x03)
N#define EXTI_PinSource4            ((uint8_t)0x04)
N#define EXTI_PinSource5            ((uint8_t)0x05)
N#define EXTI_PinSource6            ((uint8_t)0x06)
N#define EXTI_PinSource7            ((uint8_t)0x07)
N#define EXTI_PinSource8            ((uint8_t)0x08)
N#define EXTI_PinSource9            ((uint8_t)0x09)
N#define EXTI_PinSource10           ((uint8_t)0x0A)
N#define EXTI_PinSource11           ((uint8_t)0x0B)
N#define EXTI_PinSource12           ((uint8_t)0x0C)
N#define EXTI_PinSource13           ((uint8_t)0x0D)
N#define EXTI_PinSource14           ((uint8_t)0x0E)
N#define EXTI_PinSource15           ((uint8_t)0x0F)
N
N#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0) || \
N                                       ((PINSOURCE) == EXTI_PinSource1) || \
N                                       ((PINSOURCE) == EXTI_PinSource2) || \
N                                       ((PINSOURCE) == EXTI_PinSource3) || \
N                                       ((PINSOURCE) == EXTI_PinSource4) || \
N                                       ((PINSOURCE) == EXTI_PinSource5) || \
N                                       ((PINSOURCE) == EXTI_PinSource6) || \
N                                       ((PINSOURCE) == EXTI_PinSource7) || \
N                                       ((PINSOURCE) == EXTI_PinSource8) || \
N                                       ((PINSOURCE) == EXTI_PinSource9) || \
N                                       ((PINSOURCE) == EXTI_PinSource10) || \
N                                       ((PINSOURCE) == EXTI_PinSource11) || \
N                                       ((PINSOURCE) == EXTI_PinSource12) || \
N                                       ((PINSOURCE) == EXTI_PinSource13) || \
N                                       ((PINSOURCE) == EXTI_PinSource14) || \
N                                       ((PINSOURCE) == EXTI_PinSource15))
X#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0) ||                                        ((PINSOURCE) == EXTI_PinSource1) ||                                        ((PINSOURCE) == EXTI_PinSource2) ||                                        ((PINSOURCE) == EXTI_PinSource3) ||                                        ((PINSOURCE) == EXTI_PinSource4) ||                                        ((PINSOURCE) == EXTI_PinSource5) ||                                        ((PINSOURCE) == EXTI_PinSource6) ||                                        ((PINSOURCE) == EXTI_PinSource7) ||                                        ((PINSOURCE) == EXTI_PinSource8) ||                                        ((PINSOURCE) == EXTI_PinSource9) ||                                        ((PINSOURCE) == EXTI_PinSource10) ||                                        ((PINSOURCE) == EXTI_PinSource11) ||                                        ((PINSOURCE) == EXTI_PinSource12) ||                                        ((PINSOURCE) == EXTI_PinSource13) ||                                        ((PINSOURCE) == EXTI_PinSource14) ||                                        ((PINSOURCE) == EXTI_PinSource15))
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_Memory_Remap_Config 
N  * @{
N  */ 
N#define SYSCFG_MemoryRemap_Flash                ((uint8_t)0x00)
N#define SYSCFG_MemoryRemap_SystemMemory         ((uint8_t)0x01)
N#define SYSCFG_MemoryRemap_SRAM                 ((uint8_t)0x03)
N
N
N#define IS_SYSCFG_MEMORY_REMAP(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash) || \
N                                       ((REMAP) == SYSCFG_MemoryRemap_SystemMemory) || \
N                                       ((REMAP) == SYSCFG_MemoryRemap_SRAM))
X#define IS_SYSCFG_MEMORY_REMAP(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash) ||                                        ((REMAP) == SYSCFG_MemoryRemap_SystemMemory) ||                                        ((REMAP) == SYSCFG_MemoryRemap_SRAM))
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_DMA_Remap_Config 
N  * @{
N  */ 
N#define SYSCFG_DMARemap_TIM17              SYSCFG_CFGR1_TIM17_DMA_RMP        /* Remap TIM17 DMA requests from channel1 to channel2 */
N#define SYSCFG_DMARemap_TIM16              SYSCFG_CFGR1_TIM16_DMA_RMP        /* Remap TIM16 DMA requests from channel3 to channel4 */
N#define SYSCFG_DMARemap_TIM6DAC1Ch1        SYSCFG_CFGR1_TIM6DAC1Ch1_DMA_RMP  /* Remap TIM6/DAC1 Ch1 DMA requests from DMA2 channel3 to DMA1 channel3 */
N#define SYSCFG_DMARemap_TIM7DAC1Ch2        SYSCFG_CFGR1_TIM7DAC1Ch2_DMA_RMP  /* Remap TIM7/DAC1 Ch2 DMA requests from DMA2 channel4 to DMA1 channel4 */
N#define SYSCFG_DMARemap_TIM18DAC2Ch1       SYSCFG_CFGR1_TIM18DAC2Ch1_DMA_RMP  /* Remap TIM18/DAC2 Ch1 DMA requests from DMA2 channel5 to DMA1 channel5 */
N  
N#define IS_SYSCFG_DMA_REMAP(REMAP) (((REMAP) == SYSCFG_DMARemap_TIM17)       || \
N                                    ((REMAP) == SYSCFG_DMARemap_TIM16)       || \
N                                    ((REMAP) == SYSCFG_DMARemap_TIM6DAC1Ch1) || \
N                                    ((REMAP) == SYSCFG_DMARemap_TIM7DAC1Ch2) || \
N                                    ((REMAP) == SYSCFG_DMARemap_TIM18DAC2Ch1))
X#define IS_SYSCFG_DMA_REMAP(REMAP) (((REMAP) == SYSCFG_DMARemap_TIM17)       ||                                     ((REMAP) == SYSCFG_DMARemap_TIM16)       ||                                     ((REMAP) == SYSCFG_DMARemap_TIM6DAC1Ch1) ||                                     ((REMAP) == SYSCFG_DMARemap_TIM7DAC1Ch2) ||                                     ((REMAP) == SYSCFG_DMARemap_TIM18DAC2Ch1))
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_I2C_FastModePlus_Config 
N  * @{
N  */ 
N#define SYSCFG_I2CFastModePlus_PB6       SYSCFG_CFGR1_I2C_FMP_PB6  /* Enable Fast Mode Plus on PB6 */
N#define SYSCFG_I2CFastModePlus_PB7       SYSCFG_CFGR1_I2C_FMP_PB7  /* Enable Fast Mode Plus on PB7 */
N#define SYSCFG_I2CFastModePlus_PB8       SYSCFG_CFGR1_I2C_FMP_PB8  /* Enable Fast Mode Plus on PB8 */
N#define SYSCFG_I2CFastModePlus_PB9       SYSCFG_CFGR1_I2C_FMP_PB9  /* Enable Fast Mode Plus on PB9 */
N#define SYSCFG_I2CFastModePlus_I2C1      SYSCFG_CFGR1_I2C_FMP_I2C1 /* Enable Fast Mode Plus on I2C1 pins */
N#define SYSCFG_I2CFastModePlus_I2C2      SYSCFG_CFGR1_I2C_FMP_I2C2 /* Enable Fast Mode Plus on I2C2 pins */
N
N#define IS_SYSCFG_I2C_FMP(PIN) (((PIN) == SYSCFG_I2CFastModePlus_PB6)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_PB7)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_PB8)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_PB9)  || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_I2C1) || \
N                                ((PIN) == SYSCFG_I2CFastModePlus_I2C2))
X#define IS_SYSCFG_I2C_FMP(PIN) (((PIN) == SYSCFG_I2CFastModePlus_PB6)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_PB7)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_PB8)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_PB9)  ||                                 ((PIN) == SYSCFG_I2CFastModePlus_I2C1) ||                                 ((PIN) == SYSCFG_I2CFastModePlus_I2C2))
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_FPU_Interrupt_Config 
N  * @{
N  */ 
N#define SYSCFG_IT_IXC              SYSCFG_CFGR1_FPU_IE_5  /*!< Inexact Interrupt enable (interrupt disabled by default) */
N#define SYSCFG_IT_IDC              SYSCFG_CFGR1_FPU_IE_4  /*!< Input denormal Interrupt enable */
N#define SYSCFG_IT_OFC              SYSCFG_CFGR1_FPU_IE_3  /*!< Overflow Interrupt enable */
N#define SYSCFG_IT_UFC              SYSCFG_CFGR1_FPU_IE_2  /*!< Underflow Interrupt enable */
N#define SYSCFG_IT_DZC              SYSCFG_CFGR1_FPU_IE_1  /*!< Divide-by-zero Interrupt enable */
N#define SYSCFG_IT_IOC              SYSCFG_CFGR1_FPU_IE_0  /*!< Invalid operation Interrupt enable */
N
N#define IS_SYSCFG_IT(IT) ((((IT) & (uint32_t)0x03FFFFFF) == 0) && ((IT) != 0))
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_Lock_Config 
N  * @{
N  */ 
N#define SYSCFG_Break_PVD                     SYSCFG_CFGR2_PVD_LOCK          /*!< Connects the PVD event to the Break Input of TIM15/TIM16/TIM17 */
N#define SYSCFG_Break_SRAMParity              SYSCFG_CFGR2_SRAM_PARITY_LOCK  /*!< Connects the SRAM_PARITY error signal to the Break Input of TIM15/TIM16/TIM17 */
N#define SYSCFG_Break_Lockup                  SYSCFG_CFGR2_LOCKUP_LOCK       /*!< Connects Lockup output of CortexM4 to the break input of TIM15/TIM16/TIM17 */
N
N#define IS_SYSCFG_LOCK_CONFIG(CONFIG) (((CONFIG) == SYSCFG_Break_PVD)        || \
N                                       ((CONFIG) == SYSCFG_Break_SRAMParity) || \
N                                       ((CONFIG) == SYSCFG_Break_Lockup))
X#define IS_SYSCFG_LOCK_CONFIG(CONFIG) (((CONFIG) == SYSCFG_Break_PVD)        ||                                        ((CONFIG) == SYSCFG_Break_SRAMParity) ||                                        ((CONFIG) == SYSCFG_Break_Lockup))
N
N/**
N  * @}
N  */
N
N/** @defgroup SYSCFG_flags_definition 
N  * @{
N  */
N
N#define SYSCFG_FLAG_PE               SYSCFG_CFGR2_SRAM_PE
N
N#define IS_SYSCFG_FLAG(FLAG) (((FLAG) == SYSCFG_FLAG_PE))
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/*  Function used to set the SYSCFG configuration to the default reset state **/
Nvoid SYSCFG_DeInit(void);
N
N/* SYSCFG configuration functions *********************************************/ 
Nvoid SYSCFG_MemoryRemapConfig(uint32_t SYSCFG_MemoryRemap);
Nvoid SYSCFG_DMAChannelRemapConfig(uint32_t SYSCFG_DMARemap, FunctionalState NewState);
Nvoid SYSCFG_I2CFastModePlusConfig(uint32_t SYSCFG_I2CFastModePlus, FunctionalState NewState);
Nvoid SYSCFG_VBATMonitoringCmd(FunctionalState NewState);
Nvoid SYSCFG_ITConfig(uint32_t SYSCFG_IT, FunctionalState NewState);
Nvoid SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex);
Nvoid SYSCFG_BreakConfig(uint32_t SYSCFG_Break);
NFlagStatus SYSCFG_GetFlagStatus(uint32_t SYSCFG_Flag);
Nvoid SYSCFG_ClearFlag(uint32_t SYSCFG_Flag);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_SYSCFG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 46 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_i2c.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_i2c.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_i2c.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the I2C firmware
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_I2C_H
N#define __STM32F37X_I2C_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup I2C
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/**
N  * @brief  I2C Init structure definition
N  */
N
Ntypedef struct
N{
N  uint32_t I2C_Timing;              /*!< Specifies the I2C_TIMINGR_register value.
N                                         This parameter must be set by referring to I2C_Timing_Config_Tool*/
N
N  uint32_t I2C_AnalogFilter;        /*!< Enables or disables analog noise filter.
N                                         This parameter can be a value of @ref I2C_Analog_Filter*/
N
N  uint32_t I2C_DigitalFilter;       /*!< Configures the digital noise filter.
N                                         This parameter can be a number between 0x00 and 0x0F*/
N
N  uint32_t I2C_Mode;                /*!< Specifies the I2C mode.
N                                         This parameter can be a value of @ref I2C_mode*/
N
N  uint32_t I2C_OwnAddress1;         /*!< Specifies the device own address 1.
N                                         This parameter can be a 7-bit or 10-bit address*/
N
N  uint32_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
N                                         This parameter can be a value of @ref I2C_acknowledgement*/
N
N  uint32_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
N                                         This parameter can be a value of @ref I2C_acknowledged_address*/
N}I2C_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N
N/** @defgroup I2C_Exported_Constants
N  * @{
N  */
N
N#define IS_I2C_ALL_PERIPH(PERIPH)       (((PERIPH) == I2C1) || \
N                                         ((PERIPH) == I2C2))
X#define IS_I2C_ALL_PERIPH(PERIPH)       (((PERIPH) == I2C1) ||                                          ((PERIPH) == I2C2))
N
N/** @defgroup I2C_Analog_Filter 
N  * @{
N  */
N
N#define I2C_AnalogFilter_Enable         ((uint32_t)0x00000000)
N#define I2C_AnalogFilter_Disable        I2C_CR1_ANFOFF
N
N#define IS_I2C_ANALOG_FILTER(FILTER)    (((FILTER) == I2C_AnalogFilter_Enable) || \
N                                         ((FILTER) == I2C_AnalogFilter_Disable))
X#define IS_I2C_ANALOG_FILTER(FILTER)    (((FILTER) == I2C_AnalogFilter_Enable) ||                                          ((FILTER) == I2C_AnalogFilter_Disable))
N/**
N  * @}
N  */
N     
N/** @defgroup I2C_Digital_Filter
N  * @{
N  */
N
N#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000F)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_mode 
N  * @{
N  */
N
N#define I2C_Mode_I2C                    ((uint32_t)0x00000000)
N#define I2C_Mode_SMBusDevice            I2C_CR1_SMBDEN
N#define I2C_Mode_SMBusHost              I2C_CR1_SMBHEN
N
N#define IS_I2C_MODE(MODE)               (((MODE) == I2C_Mode_I2C) || \
N                                         ((MODE) == I2C_Mode_SMBusDevice) || \
N                                         ((MODE) == I2C_Mode_SMBusHost))
X#define IS_I2C_MODE(MODE)               (((MODE) == I2C_Mode_I2C) ||                                          ((MODE) == I2C_Mode_SMBusDevice) ||                                          ((MODE) == I2C_Mode_SMBusHost))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_acknowledgement
N  * @{
N  */
N
N#define I2C_Ack_Enable                  ((uint32_t)0x00000000)
N#define I2C_Ack_Disable                 I2C_CR2_NACK
N
N#define IS_I2C_ACK(ACK)                 (((ACK) == I2C_Ack_Enable) || \
N                                         ((ACK) == I2C_Ack_Disable))
X#define IS_I2C_ACK(ACK)                 (((ACK) == I2C_Ack_Enable) ||                                          ((ACK) == I2C_Ack_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_acknowledged_address
N  * @{
N  */
N
N#define I2C_AcknowledgedAddress_7bit    ((uint32_t)0x00000000)
N#define I2C_AcknowledgedAddress_10bit   I2C_OAR1_OA1MODE
N
N#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
N                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
X#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) ||                                              ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
N/**
N  * @}
N  */ 
N
N/** @defgroup I2C_own_address1
N  * @{
N  */
N
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1)   ((ADDRESS1) <= (uint32_t)0x000003FF)
N/**
N  * @}
N  */
N
N/** @defgroup I2C_transfer_direction 
N  * @{
N  */
N
N#define I2C_Direction_Transmitter       ((uint16_t)0x0000)
N#define I2C_Direction_Receiver          ((uint16_t)0x0400)
N
N#define IS_I2C_DIRECTION(DIRECTION)     (((DIRECTION) == I2C_Direction_Transmitter) || \
N                                         ((DIRECTION) == I2C_Direction_Receiver))
X#define IS_I2C_DIRECTION(DIRECTION)     (((DIRECTION) == I2C_Direction_Transmitter) ||                                          ((DIRECTION) == I2C_Direction_Receiver))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_DMA_transfer_requests 
N  * @{
N  */
N
N#define I2C_DMAReq_Tx                   I2C_CR1_TXDMAEN
N#define I2C_DMAReq_Rx                   I2C_CR1_RXDMAEN
N
N#define IS_I2C_DMA_REQ(REQ)             ((((REQ) & (uint32_t)0xFFFF3FFF) == 0x00) && ((REQ) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_slave_address
N  * @{
N  */
N
N#define IS_I2C_SLAVE_ADDRESS(ADDRESS)   ((ADDRESS) <= (uint16_t)0x03FF)
N/**
N  * @}
N  */
N
N
N/** @defgroup I2C_own_address2
N  * @{
N  */
N
N#define IS_I2C_OWN_ADDRESS2(ADDRESS2)   ((ADDRESS2) <= (uint16_t)0x00FF)
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_own_address2_mask
N  * @{
N  */
N
N#define I2C_OA2_NoMask                  ((uint8_t)0x00)
N#define I2C_OA2_Mask01                  ((uint8_t)0x01)                 
N#define I2C_OA2_Mask02                  ((uint8_t)0x02)
N#define I2C_OA2_Mask03                  ((uint8_t)0x03)
N#define I2C_OA2_Mask04                  ((uint8_t)0x04)
N#define I2C_OA2_Mask05                  ((uint8_t)0x05)
N#define I2C_OA2_Mask06                  ((uint8_t)0x06)
N#define I2C_OA2_Mask07                  ((uint8_t)0x07)
N
N#define IS_I2C_OWN_ADDRESS2_MASK(MASK)  (((MASK) == I2C_OA2_NoMask) || \
N                                         ((MASK) == I2C_OA2_Mask01) || \
N                                         ((MASK) == I2C_OA2_Mask02) || \
N                                         ((MASK) == I2C_OA2_Mask03) || \
N                                         ((MASK) == I2C_OA2_Mask04) || \
N                                         ((MASK) == I2C_OA2_Mask05) || \
N                                         ((MASK) == I2C_OA2_Mask06) || \
N                                         ((MASK) == I2C_OA2_Mask07))  
X#define IS_I2C_OWN_ADDRESS2_MASK(MASK)  (((MASK) == I2C_OA2_NoMask) ||                                          ((MASK) == I2C_OA2_Mask01) ||                                          ((MASK) == I2C_OA2_Mask02) ||                                          ((MASK) == I2C_OA2_Mask03) ||                                          ((MASK) == I2C_OA2_Mask04) ||                                          ((MASK) == I2C_OA2_Mask05) ||                                          ((MASK) == I2C_OA2_Mask06) ||                                          ((MASK) == I2C_OA2_Mask07))  
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_timeout
N  * @{
N  */
N
N#define IS_I2C_TIMEOUT(TIMEOUT)   ((TIMEOUT) <= (uint16_t)0x0FFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_registers 
N  * @{
N  */
N
N#define I2C_Register_CR1                ((uint8_t)0x00)
N#define I2C_Register_CR2                ((uint8_t)0x04)
N#define I2C_Register_OAR1               ((uint8_t)0x08)
N#define I2C_Register_OAR2               ((uint8_t)0x0C)
N#define I2C_Register_TIMINGR            ((uint8_t)0x10)
N#define I2C_Register_TIMEOUTR           ((uint8_t)0x14)
N#define I2C_Register_ISR                ((uint8_t)0x18)
N#define I2C_Register_ICR                ((uint8_t)0x1C)
N#define I2C_Register_PECR               ((uint8_t)0x20)
N#define I2C_Register_RXDR               ((uint8_t)0x24)
N#define I2C_Register_TXDR               ((uint8_t)0x28)
N
N#define IS_I2C_REGISTER(REGISTER)       (((REGISTER) == I2C_Register_CR1) || \
N                                         ((REGISTER) == I2C_Register_CR2) || \
N                                         ((REGISTER) == I2C_Register_OAR1) || \
N                                         ((REGISTER) == I2C_Register_OAR2) || \
N                                         ((REGISTER) == I2C_Register_TIMINGR) || \
N                                         ((REGISTER) == I2C_Register_TIMEOUTR) || \
N                                         ((REGISTER) == I2C_Register_ISR) || \
N                                         ((REGISTER) == I2C_Register_ICR) || \
N                                         ((REGISTER) == I2C_Register_PECR) || \
N                                         ((REGISTER) == I2C_Register_RXDR) || \
N                                         ((REGISTER) == I2C_Register_TXDR))
X#define IS_I2C_REGISTER(REGISTER)       (((REGISTER) == I2C_Register_CR1) ||                                          ((REGISTER) == I2C_Register_CR2) ||                                          ((REGISTER) == I2C_Register_OAR1) ||                                          ((REGISTER) == I2C_Register_OAR2) ||                                          ((REGISTER) == I2C_Register_TIMINGR) ||                                          ((REGISTER) == I2C_Register_TIMEOUTR) ||                                          ((REGISTER) == I2C_Register_ISR) ||                                          ((REGISTER) == I2C_Register_ICR) ||                                          ((REGISTER) == I2C_Register_PECR) ||                                          ((REGISTER) == I2C_Register_RXDR) ||                                          ((REGISTER) == I2C_Register_TXDR))
N/**
N  * @}
N  */
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define I2C_IT_ERRI                     I2C_CR1_ERRIE
N#define I2C_IT_TCI                      I2C_CR1_TCIE
N#define I2C_IT_STOPI                    I2C_CR1_STOPIE
N#define I2C_IT_NACKI                    I2C_CR1_NACKIE
N#define I2C_IT_ADDRI                    I2C_CR1_ADDRIE
N#define I2C_IT_RXI                      I2C_CR1_RXIE
N#define I2C_IT_TXI                      I2C_CR1_TXIE
N
N#define IS_I2C_CONFIG_IT(IT)            ((((IT) & (uint32_t)0xFFFFFF01) == 0x00) && ((IT) != 0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_flags_definition 
N  * @{
N  */
N
N#define  I2C_FLAG_TXE                   I2C_ISR_TXE
N#define  I2C_FLAG_TXIS                  I2C_ISR_TXIS
N#define  I2C_FLAG_RXNE                  I2C_ISR_RXNE
N#define  I2C_FLAG_ADDR                  I2C_ISR_ADDR
N#define  I2C_FLAG_NACKF                 I2C_ISR_NACKF
N#define  I2C_FLAG_STOPF                 I2C_ISR_STOPF
N#define  I2C_FLAG_TC                    I2C_ISR_TC
N#define  I2C_FLAG_TCR                   I2C_ISR_TCR
N#define  I2C_FLAG_BERR                  I2C_ISR_BERR
N#define  I2C_FLAG_ARLO                  I2C_ISR_ARLO
N#define  I2C_FLAG_OVR                   I2C_ISR_OVR
N#define  I2C_FLAG_PECERR                I2C_ISR_PECERR
N#define  I2C_FLAG_TIMEOUT               I2C_ISR_TIMEOUT
N#define  I2C_FLAG_ALERT                 I2C_ISR_ALERT
N#define  I2C_FLAG_BUSY                  I2C_ISR_BUSY
N
N#define IS_I2C_CLEAR_FLAG(FLAG)         ((((FLAG) & (uint32_t)0xFFFF4000) == 0x00) && ((FLAG) != 0x00))
N
N#define IS_I2C_GET_FLAG(FLAG)           (((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_TXIS) || \
N                                         ((FLAG) == I2C_FLAG_RXNE) || ((FLAG) == I2C_FLAG_ADDR) || \
N                                         ((FLAG) == I2C_FLAG_NACKF) || ((FLAG) == I2C_FLAG_STOPF) || \
N                                         ((FLAG) == I2C_FLAG_TC) || ((FLAG) == I2C_FLAG_TCR) || \
N                                         ((FLAG) == I2C_FLAG_BERR) || ((FLAG) == I2C_FLAG_ARLO) || \
N                                         ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_PECERR) || \
N                                         ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_ALERT) || \
N                                         ((FLAG) == I2C_FLAG_BUSY))
X#define IS_I2C_GET_FLAG(FLAG)           (((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_TXIS) ||                                          ((FLAG) == I2C_FLAG_RXNE) || ((FLAG) == I2C_FLAG_ADDR) ||                                          ((FLAG) == I2C_FLAG_NACKF) || ((FLAG) == I2C_FLAG_STOPF) ||                                          ((FLAG) == I2C_FLAG_TC) || ((FLAG) == I2C_FLAG_TCR) ||                                          ((FLAG) == I2C_FLAG_BERR) || ((FLAG) == I2C_FLAG_ARLO) ||                                          ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_PECERR) ||                                          ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_ALERT) ||                                          ((FLAG) == I2C_FLAG_BUSY))
N
N/**
N  * @}
N  */
N
N
N/** @defgroup I2C_interrupts_definition 
N  * @{
N  */
N
N#define  I2C_IT_TXIS                    I2C_ISR_TXIS
N#define  I2C_IT_RXNE                    I2C_ISR_RXNE
N#define  I2C_IT_ADDR                    I2C_ISR_ADDR
N#define  I2C_IT_NACKF                   I2C_ISR_NACKF
N#define  I2C_IT_STOPF                   I2C_ISR_STOPF
N#define  I2C_IT_TC                      I2C_ISR_TC
N#define  I2C_IT_TCR                     I2C_ISR_TCR
N#define  I2C_IT_BERR                    I2C_ISR_BERR
N#define  I2C_IT_ARLO                    I2C_ISR_ARLO
N#define  I2C_IT_OVR                     I2C_ISR_OVR
N#define  I2C_IT_PECERR                  I2C_ISR_PECERR
N#define  I2C_IT_TIMEOUT                 I2C_ISR_TIMEOUT
N#define  I2C_IT_ALERT                   I2C_ISR_ALERT
N
N#define IS_I2C_CLEAR_IT(IT)             ((((IT) & (uint32_t)0xFFFFC001) == 0x00) && ((IT) != 0x00))
N                               
N#define IS_I2C_GET_IT(IT)               (((IT) == I2C_IT_TXIS) || ((IT) == I2C_IT_RXNE) || \
N                                         ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_NACKF) || \
N                                         ((IT) == I2C_IT_STOPF) || ((IT) == I2C_IT_TC) || \
N                                         ((IT) == I2C_IT_TCR) || ((IT) == I2C_IT_BERR) || \
N                                         ((IT) == I2C_IT_ARLO) || ((IT) == I2C_IT_OVR) || \
N                                         ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_TIMEOUT) || \
N                                         ((IT) == I2C_IT_ALERT))
X#define IS_I2C_GET_IT(IT)               (((IT) == I2C_IT_TXIS) || ((IT) == I2C_IT_RXNE) ||                                          ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_NACKF) ||                                          ((IT) == I2C_IT_STOPF) || ((IT) == I2C_IT_TC) ||                                          ((IT) == I2C_IT_TCR) || ((IT) == I2C_IT_BERR) ||                                          ((IT) == I2C_IT_ARLO) || ((IT) == I2C_IT_OVR) ||                                          ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_TIMEOUT) ||                                          ((IT) == I2C_IT_ALERT))
N                               
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_ReloadEndMode_definition 
N  * @{
N  */
N
N#define  I2C_Reload_Mode                I2C_CR2_RELOAD
N#define  I2C_AutoEnd_Mode               I2C_CR2_AUTOEND
N#define  I2C_SoftEnd_Mode               ((uint32_t)0x00000000)
N
N                              
N#define IS_RELOAD_END_MODE(MODE)        (((MODE) == I2C_Reload_Mode) || \
N                                         ((MODE) == I2C_AutoEnd_Mode) || \
N                                         ((MODE) == I2C_SoftEnd_Mode))
X#define IS_RELOAD_END_MODE(MODE)        (((MODE) == I2C_Reload_Mode) ||                                          ((MODE) == I2C_AutoEnd_Mode) ||                                          ((MODE) == I2C_SoftEnd_Mode))
N                               
N
N/**
N  * @}
N  */
N
N/** @defgroup I2C_StartStopMode_definition 
N  * @{
N  */
N
N#define  I2C_No_StartStop                 ((uint32_t)0x00000000)
N#define  I2C_Generate_Stop                I2C_CR2_STOP
N#define  I2C_Generate_Start_Read          (uint32_t)(I2C_CR2_START | I2C_CR2_RD_WRN)
N#define  I2C_Generate_Start_Write         I2C_CR2_START
N
N                              
N#define IS_START_STOP_MODE(MODE)        (((MODE) == I2C_Generate_Stop) || \
N                                         ((MODE) == I2C_Generate_Start_Read) || \
N                                         ((MODE) == I2C_Generate_Start_Write) || \
N                                         ((MODE) == I2C_No_StartStop))
X#define IS_START_STOP_MODE(MODE)        (((MODE) == I2C_Generate_Stop) ||                                          ((MODE) == I2C_Generate_Start_Read) ||                                          ((MODE) == I2C_Generate_Start_Write) ||                                          ((MODE) == I2C_No_StartStop))
N                               
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N
N/* Initialization and Configuration functions *********************************/
Nvoid I2C_DeInit(I2C_TypeDef* I2Cx);
Nvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx);
Nvoid I2C_ITConfig(I2C_TypeDef* I2Cx, uint32_t I2C_IT, FunctionalState NewState);
Nvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_StopModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Mask);
Nvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SlaveByteControlCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SlaveAddressConfig(I2C_TypeDef* I2Cx, uint16_t Address);
Nvoid I2C_10BitAddressingModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
N
N/* Communications handling functions ******************************************/
Nvoid I2C_AutoEndCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ReloadCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_NumberOfBytesConfig(I2C_TypeDef* I2Cx, uint8_t Number_Bytes);
Nvoid I2C_MasterRequestConfig(I2C_TypeDef* I2Cx, uint16_t I2C_Direction);
Nvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_10BitAddressHeaderCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nuint8_t I2C_GetAddressMatched(I2C_TypeDef* I2Cx);
Nuint16_t I2C_GetTransferDirection(I2C_TypeDef* I2Cx);
Nvoid I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode);
N
N/*  SMBUS management functions ************************************************/
Nvoid I2C_SMBusAlertCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ExtendedClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_IdleClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_TimeoutAConfig(I2C_TypeDef* I2Cx, uint16_t Timeout);
Nvoid I2C_TimeoutBConfig(I2C_TypeDef* I2Cx, uint16_t Timeout);
Nvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_PECRequestCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nuint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);
N
N/* I2C registers management functions *****************************************/
Nuint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
N
N/* Data transfers management functions ****************************************/
Nvoid I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
Nuint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);
N
N/* DMA transfers management functions *****************************************/
Nvoid I2C_DMACmd(I2C_TypeDef* I2Cx, uint32_t I2C_DMAReq, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
Nvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
NITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
Nvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_I2C_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 47 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_iwdg.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_iwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_iwdg.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the IWDG 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_IWDG_H
N#define __STM32F37X_IWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup IWDG
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup IWDG_Exported_Constants
N  * @{
N  */
N
N/** @defgroup IWDG_WriteAccess
N  * @{
N  */
N
N#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
N#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
N#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
N                                      ((ACCESS) == IWDG_WriteAccess_Disable))
X#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) ||                                       ((ACCESS) == IWDG_WriteAccess_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_prescaler 
N  * @{
N  */
N
N#define IWDG_Prescaler_4            ((uint8_t)0x00)
N#define IWDG_Prescaler_8            ((uint8_t)0x01)
N#define IWDG_Prescaler_16           ((uint8_t)0x02)
N#define IWDG_Prescaler_32           ((uint8_t)0x03)
N#define IWDG_Prescaler_64           ((uint8_t)0x04)
N#define IWDG_Prescaler_128          ((uint8_t)0x05)
N#define IWDG_Prescaler_256          ((uint8_t)0x06)
N#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
N                                      ((PRESCALER) == IWDG_Prescaler_16) || \
N                                      ((PRESCALER) == IWDG_Prescaler_32) || \
N                                      ((PRESCALER) == IWDG_Prescaler_64) || \
N                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
N                                      ((PRESCALER) == IWDG_Prescaler_256))
X#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  ||                                       ((PRESCALER) == IWDG_Prescaler_8)  ||                                       ((PRESCALER) == IWDG_Prescaler_16) ||                                       ((PRESCALER) == IWDG_Prescaler_32) ||                                       ((PRESCALER) == IWDG_Prescaler_64) ||                                       ((PRESCALER) == IWDG_Prescaler_128)||                                       ((PRESCALER) == IWDG_Prescaler_256))
N/**
N  * @}
N  */
N
N/** @defgroup IWDG_Flag 
N  * @{
N  */
N
N#define IWDG_FLAG_PVU               IWDG_SR_PVU
N#define IWDG_FLAG_RVU               IWDG_SR_RVU
N#define IWDG_FLAG_WVU               IWDG_SR_WVU
N#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU)  || \
N                            ((FLAG) == IWDG_FLAG_WVU))
X#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU)  ||                             ((FLAG) == IWDG_FLAG_WVU))
N
N#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
N
N#define IS_IWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0xFFF)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
N/* Prescaler and Counter configuration functions ******************************/
Nvoid IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
Nvoid IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
Nvoid IWDG_SetReload(uint16_t Reload);
Nvoid IWDG_ReloadCounter(void);
Nvoid IWDG_SetWindowValue(uint16_t WindowValue);
N
N/* IWDG activation function ***************************************************/
Nvoid IWDG_Enable(void);
N
N/* Flag management function ***************************************************/
NFlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_IWDG_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 48 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_pwr.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_pwr.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_pwr.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the PWR firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_PWR_H
N#define __STM32F37X_PWR_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup PWR
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup PWR_Exported_Constants
N  * @{
N  */ 
N
N/** @defgroup PWR_PVD_detection_level
N  * @{
N  */ 
N
N#define PWR_PVDLevel_0                  PWR_CR_PLS_LEV0
N#define PWR_PVDLevel_1                  PWR_CR_PLS_LEV1
N#define PWR_PVDLevel_2                  PWR_CR_PLS_LEV2
N#define PWR_PVDLevel_3                  PWR_CR_PLS_LEV3
N#define PWR_PVDLevel_4                  PWR_CR_PLS_LEV4
N#define PWR_PVDLevel_5                  PWR_CR_PLS_LEV5
N#define PWR_PVDLevel_6                  PWR_CR_PLS_LEV6
N#define PWR_PVDLevel_7                  PWR_CR_PLS_LEV7 
N
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)|| \
N                                 ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)|| \
N                                 ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)||                                  ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)||                                  ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)||                                  ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_WakeUp_Pins
N  * @{
N  */
N
N#define PWR_WakeUpPin_1                 PWR_CSR_EWUP1
N#define PWR_WakeUpPin_2                 PWR_CSR_EWUP2
N#define PWR_WakeUpPin_3                 PWR_CSR_EWUP3
N#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUpPin_1) || \
N                                ((PIN) == PWR_WakeUpPin_2) || \
N                                ((PIN) == PWR_WakeUpPin_3))
X#define IS_PWR_WAKEUP_PIN(PIN) (((PIN) == PWR_WakeUpPin_1) ||                                 ((PIN) == PWR_WakeUpPin_2) ||                                 ((PIN) == PWR_WakeUpPin_3))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_SDADC_Analog
N  * @{
N  */
N
N#define PWR_SDADCAnalog_1                 PWR_CR_SDADC1EN
N#define PWR_SDADCAnalog_2                 PWR_CR_SDADC2EN
N#define PWR_SDADCAnalog_3                 PWR_CR_SDADC3EN
N#define IS_PWR_SDADC_ANALOG(SDADC) (((SDADC) == PWR_SDADCAnalog_1) || \
N                                     ((SDADC) == PWR_SDADCAnalog_2) || \
N                                     ((SDADC) == PWR_SDADCAnalog_3))
X#define IS_PWR_SDADC_ANALOG(SDADC) (((SDADC) == PWR_SDADCAnalog_1) ||                                      ((SDADC) == PWR_SDADCAnalog_2) ||                                      ((SDADC) == PWR_SDADCAnalog_3))
N/**
N  * @}
N  */
N 
N/** @defgroup PWR_Regulator_state_is_Sleep_STOP_mode
N  * @{
N  */
N
N#define PWR_Regulator_ON                ((uint32_t)0x00000000)
N#define PWR_Regulator_LowPower          PWR_CR_LPSDSR
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
N                                     ((REGULATOR) == PWR_Regulator_LowPower))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) ||                                      ((REGULATOR) == PWR_Regulator_LowPower))
N/**
N  * @}
N  */
N
N/** @defgroup PWR_SLEEP_mode_entry
N  * @{
N  */
N
N#define PWR_SLEEPEntry_WFI              ((uint8_t)0x01)
N#define PWR_SLEEPEntry_WFE              ((uint8_t)0x02)
N#define IS_PWR_SLEEP_ENTRY(ENTRY) (((ENTRY) == PWR_SLEEPEntry_WFI) || ((ENTRY) == PWR_SLEEPEntry_WFE))
N 
N/**
N  * @}
N  */
N
N/** @defgroup PWR_STOP_mode_entry
N  * @{
N  */
N
N#define PWR_STOPEntry_WFI               ((uint8_t)0x01)
N#define PWR_STOPEntry_WFE               ((uint8_t)0x02)
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
N 
N/**
N  * @}
N  */
N
N/** @defgroup PWR_Flag
N  * @{
N  */
N
N#define PWR_FLAG_WU                     PWR_CSR_WUF
N#define PWR_FLAG_SB                     PWR_CSR_SBF
N#define PWR_FLAG_PVDO                   PWR_CSR_PVDO
N#define PWR_FLAG_VREFINTRDY             PWR_CSR_VREFINTRDYF
N
N#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
N                               ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_VREFINTRDY))
X#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) ||                                ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_VREFINTRDY))
N
N#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the PWR configuration to the default reset state ******/ 
Nvoid PWR_DeInit(void);
N
N/* Backup Domain Access function **********************************************/ 
Nvoid PWR_BackupAccessCmd(FunctionalState NewState);
N
N/* PVD configuration functions ************************************************/ 
Nvoid PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
Nvoid PWR_PVDCmd(FunctionalState NewState);
N
N/* WakeUp pins configuration function  ****************************************/ 
Nvoid PWR_WakeUpPinCmd(uint32_t PWR_WakeUpPin, FunctionalState NewState);
N
N/* SDADC Analog configuration function  ****************************************/ 
Nvoid PWR_SDADCAnalogCmd(uint32_t PWR_SDADCAnalog, FunctionalState NewState);
N
N/* Low Power modes configuration functions ************************************/ 
Nvoid PWR_EnterSleepMode(uint8_t PWR_SLEEPEntry);
Nvoid PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
Nvoid PWR_EnterSTANDBYMode(void);
N
N/* Flags management functions *************************************************/ 
NFlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
Nvoid PWR_ClearFlag(uint32_t PWR_FLAG);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_PWR_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 49 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_rcc.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_rcc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_rcc.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the RCC 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_RCC_H
S#define __STM32F37X_RCC_H
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* Includes ------------------------------------------------------------------*/
S#include "stm32f37x.h"
S
S/** @addtogroup STM32F37x_StdPeriph_Driver
S  * @{
S  */
S
S/** @addtogroup RCC
S  * @{
S  */
S
S/* Exported types ------------------------------------------------------------*/
S
Stypedef struct
S{
S  uint32_t SYSCLK_Frequency;
S  uint32_t HCLK_Frequency;
S  uint32_t PCLK1_Frequency;
S  uint32_t PCLK2_Frequency;
S  uint32_t ADCCLK_Frequency;
S  uint32_t SDADCCLK_Frequency;
S  uint32_t CECCLK_Frequency;
S  uint32_t I2C1CLK_Frequency;
S  uint32_t I2C2CLK_Frequency;
S  uint32_t USART1CLK_Frequency;
S  uint32_t USART2CLK_Frequency;
S  uint32_t USART3CLK_Frequency;
S}RCC_ClocksTypeDef;
S
S/* Exported constants --------------------------------------------------------*/
S
S/** @defgroup RCC_Exported_Constants
S  * @{
S  */
S
S/** @defgroup RCC_HSE_configuration 
S  * @{
S  */
S
S#define RCC_HSE_OFF                      ((uint8_t)0x00)
S#define RCC_HSE_ON                       ((uint8_t)0x01)
S#define RCC_HSE_Bypass                   ((uint8_t)0x05)
S#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
S                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
S
S/**
S  * @}
S  */ 
S 
S/** @defgroup RCC_PLL_Clock_Source 
S  * @{
S  */
S
S#define RCC_PLLSource_HSI_Div2           RCC_CFGR_PLLSRC_HSI_Div2
S#define RCC_PLLSource_PREDIV1            RCC_CFGR_PLLSRC_PREDIV1
S 
S#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
S                                   ((SOURCE) == RCC_PLLSource_PREDIV1))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_PREDIV1))
S/**
S  * @}
S  */ 
S
S/** @defgroup RCC_PLL_Multiplication_Factor 
S  * @{
S  */
S
S#define RCC_PLLMul_2                    RCC_CFGR_PLLMULL2
S#define RCC_PLLMul_3                    RCC_CFGR_PLLMULL3
S#define RCC_PLLMul_4                    RCC_CFGR_PLLMULL4
S#define RCC_PLLMul_5                    RCC_CFGR_PLLMULL5
S#define RCC_PLLMul_6                    RCC_CFGR_PLLMULL6
S#define RCC_PLLMul_7                    RCC_CFGR_PLLMULL7
S#define RCC_PLLMul_8                    RCC_CFGR_PLLMULL8
S#define RCC_PLLMul_9                    RCC_CFGR_PLLMULL9
S#define RCC_PLLMul_10                   RCC_CFGR_PLLMULL10
S#define RCC_PLLMul_11                   RCC_CFGR_PLLMULL11
S#define RCC_PLLMul_12                   RCC_CFGR_PLLMULL12
S#define RCC_PLLMul_13                   RCC_CFGR_PLLMULL13
S#define RCC_PLLMul_14                   RCC_CFGR_PLLMULL14
S#define RCC_PLLMul_15                   RCC_CFGR_PLLMULL15
S#define RCC_PLLMul_16                   RCC_CFGR_PLLMULL16
S#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
S                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
S                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
S                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
S                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
S                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
S                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
S                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_PREDIV1_division_factor
S  * @{
S  */
S#define  RCC_PREDIV1_Div1               RCC_CFGR2_PREDIV1_DIV1
S#define  RCC_PREDIV1_Div2               RCC_CFGR2_PREDIV1_DIV2
S#define  RCC_PREDIV1_Div3               RCC_CFGR2_PREDIV1_DIV3
S#define  RCC_PREDIV1_Div4               RCC_CFGR2_PREDIV1_DIV4
S#define  RCC_PREDIV1_Div5               RCC_CFGR2_PREDIV1_DIV5
S#define  RCC_PREDIV1_Div6               RCC_CFGR2_PREDIV1_DIV6
S#define  RCC_PREDIV1_Div7               RCC_CFGR2_PREDIV1_DIV7
S#define  RCC_PREDIV1_Div8               RCC_CFGR2_PREDIV1_DIV8
S#define  RCC_PREDIV1_Div9               RCC_CFGR2_PREDIV1_DIV9
S#define  RCC_PREDIV1_Div10              RCC_CFGR2_PREDIV1_DIV10
S#define  RCC_PREDIV1_Div11              RCC_CFGR2_PREDIV1_DIV11
S#define  RCC_PREDIV1_Div12              RCC_CFGR2_PREDIV1_DIV12
S#define  RCC_PREDIV1_Div13              RCC_CFGR2_PREDIV1_DIV13
S#define  RCC_PREDIV1_Div14              RCC_CFGR2_PREDIV1_DIV14
S#define  RCC_PREDIV1_Div15              RCC_CFGR2_PREDIV1_DIV15
S#define  RCC_PREDIV1_Div16              RCC_CFGR2_PREDIV1_DIV16
S
S#define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \
S                                 ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \
S                                 ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \
S                                 ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \
S                                 ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \
S                                 ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \
S                                 ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \
S                                 ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
X#define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) ||                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) ||                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) ||                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) ||                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) ||                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) ||                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) ||                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
S/**
S  * @}
S  */
S 
S/** @defgroup RCC_System_Clock_Source 
S  * @{
S  */
S
S#define RCC_SYSCLKSource_HSI             RCC_CFGR_SW_HSI
S#define RCC_SYSCLKSource_HSE             RCC_CFGR_SW_HSE
S#define RCC_SYSCLKSource_PLLCLK          RCC_CFGR_SW_PLL
S#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
S                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
S                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_AHB_Clock_Source
S  * @{
S  */
S
S#define RCC_SYSCLK_Div1                  RCC_CFGR_HPRE_DIV1
S#define RCC_SYSCLK_Div2                  RCC_CFGR_HPRE_DIV2
S#define RCC_SYSCLK_Div4                  RCC_CFGR_HPRE_DIV4
S#define RCC_SYSCLK_Div8                  RCC_CFGR_HPRE_DIV8
S#define RCC_SYSCLK_Div16                 RCC_CFGR_HPRE_DIV16
S#define RCC_SYSCLK_Div64                 RCC_CFGR_HPRE_DIV64
S#define RCC_SYSCLK_Div128                RCC_CFGR_HPRE_DIV128
S#define RCC_SYSCLK_Div256                RCC_CFGR_HPRE_DIV256
S#define RCC_SYSCLK_Div512                RCC_CFGR_HPRE_DIV512
S#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
S                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
S                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
S                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
S                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
S/**
S  * @}
S  */ 
S
S/** @defgroup RCC_APB1_APB2_Clock_Source
S  * @{
S  */
S
S#define RCC_HCLK_Div1                    RCC_CFGR_PPRE1_DIV1
S#define RCC_HCLK_Div2                    RCC_CFGR_PPRE1_DIV2
S#define RCC_HCLK_Div4                    RCC_CFGR_PPRE1_DIV4
S#define RCC_HCLK_Div8                    RCC_CFGR_PPRE1_DIV8
S#define RCC_HCLK_Div16                   RCC_CFGR_PPRE1_DIV16
S#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
S                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
S                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
S/**
S  * @}
S  */
S  
S/** @defgroup RCC_ADC_clock_source 
S  * @{
S  */
S
S#define RCC_PCLK2_Div2                   ((uint32_t)0x00000000)
S#define RCC_PCLK2_Div4                   ((uint32_t)0x00004000)
S#define RCC_PCLK2_Div6                   ((uint32_t)0x00008000)
S#define RCC_PCLK2_Div8                   ((uint32_t)0x0000C000)
S
S#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
S                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) ||                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
S
S/**
S  * @}
S  */
S
S/** @defgroup RCC_SDADC_clock_source 
S  * @{
S  */
S
S#define RCC_SDADCCLK_SYSCLK_Div2                   ((uint32_t)0x80000000)
S#define RCC_SDADCCLK_SYSCLK_Div4                   ((uint32_t)0x88000000)
S#define RCC_SDADCCLK_SYSCLK_Div6                   ((uint32_t)0x90000000)
S#define RCC_SDADCCLK_SYSCLK_Div8                   ((uint32_t)0x98000000)
S#define RCC_SDADCCLK_SYSCLK_Div10                  ((uint32_t)0xA0000000)
S#define RCC_SDADCCLK_SYSCLK_Div12                  ((uint32_t)0xA8000000)
S#define RCC_SDADCCLK_SYSCLK_Div14                  ((uint32_t)0xB0000000)
S#define RCC_SDADCCLK_SYSCLK_Div16                  ((uint32_t)0xB8000000)
S#define RCC_SDADCCLK_SYSCLK_Div20                  ((uint32_t)0xC0000000)
S#define RCC_SDADCCLK_SYSCLK_Div24                  ((uint32_t)0xC8000000)
S#define RCC_SDADCCLK_SYSCLK_Div28                  ((uint32_t)0xD0000000)
S#define RCC_SDADCCLK_SYSCLK_Div32                  ((uint32_t)0xD8000000)
S#define RCC_SDADCCLK_SYSCLK_Div36                  ((uint32_t)0xE0000000)
S#define RCC_SDADCCLK_SYSCLK_Div40                  ((uint32_t)0xE8000000)
S#define RCC_SDADCCLK_SYSCLK_Div44                  ((uint32_t)0xF0000000)
S#define RCC_SDADCCLK_SYSCLK_Div48                  ((uint32_t)0xF8000000)
S
S#define IS_RCC_SDADCCLK(SDADCCLK) (((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div2) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div4) || \
S                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div6) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div8) || \
S                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div10) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div12) || \
S                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div14) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div16) || \
S                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div20) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div24) || \
S                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div28) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div32) || \
S                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div36) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div40) || \
S                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div44) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div48))
X#define IS_RCC_SDADCCLK(SDADCCLK) (((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div2) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div4) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div6) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div8) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div10) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div12) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div14) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div16) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div20) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div24) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div28) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div32) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div36) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div40) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div44) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div48))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_CEC_clock_source 
S  * @{
S  */
S
S#define RCC_CECCLK_HSI_Div244            ((uint32_t)0x00000000)
S#define RCC_CECCLK_LSE                   RCC_CFGR3_CECSW
S
S#define IS_RCC_CECCLK(CECCLK) (((CECCLK) == RCC_CECCLK_HSI_Div244) || ((CECCLK) == RCC_CECCLK_LSE))
S
S/**
S  * @}
S  */
S
S/** @defgroup RCC_I2C_clock_source 
S  * @{
S  */
S
S#define RCC_I2C1CLK_HSI                   ((uint32_t)0x00000000)
S#define RCC_I2C1CLK_SYSCLK                RCC_CFGR3_I2C1SW
S
S#define RCC_I2C2CLK_HSI                   ((uint32_t)0x10000000)
S#define RCC_I2C2CLK_SYSCLK                ((uint32_t)0x10000020)
S
S#define IS_RCC_I2CCLK(I2CCLK) (((I2CCLK) == RCC_I2C1CLK_HSI) || ((I2CCLK) == RCC_I2C1CLK_SYSCLK) || \
S                               ((I2CCLK) == RCC_I2C2CLK_HSI) || ((I2CCLK) == RCC_I2C2CLK_SYSCLK))
X#define IS_RCC_I2CCLK(I2CCLK) (((I2CCLK) == RCC_I2C1CLK_HSI) || ((I2CCLK) == RCC_I2C1CLK_SYSCLK) ||                                ((I2CCLK) == RCC_I2C2CLK_HSI) || ((I2CCLK) == RCC_I2C2CLK_SYSCLK))
S
S/**
S  * @}
S  */
S
S/** @defgroup RCC_USART_clock_source 
S  * @{
S  */
S
S#define RCC_USART1CLK_PCLK                  ((uint32_t)0x10000000)
S#define RCC_USART1CLK_SYSCLK                ((uint32_t)0x10000001)
S#define RCC_USART1CLK_LSE                   ((uint32_t)0x10000002)
S#define RCC_USART1CLK_HSI                   ((uint32_t)0x10000003)
S
S#define RCC_USART2CLK_PCLK                  ((uint32_t)0x20000000)
S#define RCC_USART2CLK_SYSCLK                ((uint32_t)0x20010000)
S#define RCC_USART2CLK_LSE                   ((uint32_t)0x20020000)
S#define RCC_USART2CLK_HSI                   ((uint32_t)0x20030000)
S
S#define RCC_USART3CLK_PCLK                  ((uint32_t)0x30000000)
S#define RCC_USART3CLK_SYSCLK                ((uint32_t)0x30040000)
S#define RCC_USART3CLK_LSE                   ((uint32_t)0x30080000)
S#define RCC_USART3CLK_HSI                   ((uint32_t)0x300C0000)
S
S#define IS_RCC_USARTCLK(USARTCLK) (((USARTCLK) == RCC_USART1CLK_PCLK) || ((USARTCLK) == RCC_USART1CLK_SYSCLK) || \
S                                   ((USARTCLK) == RCC_USART1CLK_LSE) || ((USARTCLK) == RCC_USART1CLK_HSI) ||\
S                                   ((USARTCLK) == RCC_USART2CLK_PCLK) || ((USARTCLK) == RCC_USART2CLK_SYSCLK) || \
S                                   ((USARTCLK) == RCC_USART2CLK_LSE) || ((USARTCLK) == RCC_USART2CLK_HSI) || \
S                                   ((USARTCLK) == RCC_USART3CLK_PCLK) || ((USARTCLK) == RCC_USART3CLK_SYSCLK) || \
S                                   ((USARTCLK) == RCC_USART3CLK_LSE) || ((USARTCLK) == RCC_USART3CLK_HSI))
X#define IS_RCC_USARTCLK(USARTCLK) (((USARTCLK) == RCC_USART1CLK_PCLK) || ((USARTCLK) == RCC_USART1CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART1CLK_LSE) || ((USARTCLK) == RCC_USART1CLK_HSI) ||                                   ((USARTCLK) == RCC_USART2CLK_PCLK) || ((USARTCLK) == RCC_USART2CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART2CLK_LSE) || ((USARTCLK) == RCC_USART2CLK_HSI) ||                                    ((USARTCLK) == RCC_USART3CLK_PCLK) || ((USARTCLK) == RCC_USART3CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART3CLK_LSE) || ((USARTCLK) == RCC_USART3CLK_HSI))
S
S/**
S  * @}
S  */
S       
S/** @defgroup RCC_Interrupt_Source 
S  * @{
S  */
S
S#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
S#define RCC_IT_LSERDY                    ((uint8_t)0x02)
S#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
S#define RCC_IT_HSERDY                    ((uint8_t)0x08)
S#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
S#define RCC_IT_CSS                       ((uint8_t)0x80)
S
S#define IS_RCC_IT(IT) ((((IT) & (uint8_t)0xC0) == 0x00) && ((IT) != 0x00))
S
S#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
S                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
S                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
S                           
S
S#define IS_RCC_CLEAR_IT(IT) ((((IT) & (uint8_t)0x40) == 0x00) && ((IT) != 0x00))
S
S/**
S  * @}
S  */
S  
S/** @defgroup RCC_LSE_Configuration 
S  * @{
S  */
S
S#define RCC_LSE_OFF                      ((uint32_t)0x00000000)
S#define RCC_LSE_ON                       RCC_BDCR_LSEON
S#define RCC_LSE_Bypass                   ((uint32_t)(RCC_BDCR_LSEON | RCC_BDCR_LSEBYP))
S#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
S                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_RTC_Clock_Source
S  * @{
S  */
S
S#define RCC_RTCCLKSource_LSE             RCC_BDCR_RTCSEL_LSE
S#define RCC_RTCCLKSource_LSI             RCC_BDCR_RTCSEL_LSI
S#define RCC_RTCCLKSource_HSE_Div32       RCC_BDCR_RTCSEL_HSE
S
S#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
S                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
S                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div32))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div32))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_LSE_Drive_Configuration 
S  * @{
S  */
S
S#define RCC_LSEDrive_Low                 ((uint32_t)0x00000000)
S#define RCC_LSEDrive_MediumLow           RCC_BDCR_LSEDRV_0
S#define RCC_LSEDrive_MediumHigh          RCC_BDCR_LSEDRV_1
S#define RCC_LSEDrive_High                RCC_BDCR_LSEDRV
S#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDrive_Low) || ((DRIVE) == RCC_LSEDrive_MediumLow) || \
S                                 ((DRIVE) == RCC_LSEDrive_MediumHigh) || ((DRIVE) == RCC_LSEDrive_High))
X#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDrive_Low) || ((DRIVE) == RCC_LSEDrive_MediumLow) ||                                  ((DRIVE) == RCC_LSEDrive_MediumHigh) || ((DRIVE) == RCC_LSEDrive_High))
S/**
S  * @}
S  */
S  
S/** @defgroup RCC_AHB_Peripherals 
S  * @{
S  */
S
S#define RCC_AHBPeriph_GPIOA               RCC_AHBENR_GPIOAEN
S#define RCC_AHBPeriph_GPIOB               RCC_AHBENR_GPIOBEN
S#define RCC_AHBPeriph_GPIOC               RCC_AHBENR_GPIOCEN
S#define RCC_AHBPeriph_GPIOD               RCC_AHBENR_GPIODEN
S#define RCC_AHBPeriph_GPIOE               RCC_AHBENR_GPIOEEN
S#define RCC_AHBPeriph_GPIOF               RCC_AHBENR_GPIOFEN
S#define RCC_AHBPeriph_TS                  RCC_AHBENR_TSEN
S#define RCC_AHBPeriph_CRC                 RCC_AHBENR_CRCEN
S#define RCC_AHBPeriph_FLITF               RCC_AHBENR_FLITFEN
S#define RCC_AHBPeriph_SRAM                RCC_AHBENR_SRAMEN
S#define RCC_AHBPeriph_DMA2                RCC_AHBENR_DMA2EN
S#define RCC_AHBPeriph_DMA1                RCC_AHBENR_DMA1EN
S
S#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFE81FFA8) == 0x00) && ((PERIPH) != 0x00))
S#define IS_RCC_AHB_RST_PERIPH(PERIPH) ((((PERIPH) & 0xFE81FFFF) == 0x00) && ((PERIPH) != 0x00))
S
S/**
S  * @}
S  */
S
S/** @defgroup RCC_APB2_Peripherals 
S  * @{
S  */
S
S#define RCC_APB2Periph_SYSCFG            RCC_APB2ENR_SYSCFGEN
S#define RCC_APB2Periph_ADC1              RCC_APB2ENR_ADC1EN
S#define RCC_APB2Periph_SPI1              RCC_APB2ENR_SPI1EN
S#define RCC_APB2Periph_USART1            RCC_APB2ENR_USART1EN
S#define RCC_APB2Periph_TIM15             RCC_APB2ENR_TIM15EN
S#define RCC_APB2Periph_TIM16             RCC_APB2ENR_TIM16EN
S#define RCC_APB2Periph_TIM17             RCC_APB2ENR_TIM17EN
S#define RCC_APB2Periph_TIM19             RCC_APB2ENR_TIM19EN
S#define RCC_APB2Periph_SDADC1            RCC_APB2ENR_SDADC1EN
S#define RCC_APB2Periph_SDADC2            RCC_APB2ENR_SDADC2EN
S#define RCC_APB2Periph_SDADC3            RCC_APB2ENR_SDADC3EN
S
S#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xF8F08DFE) == 0x00) && ((PERIPH) != 0x00))
S
S/**
S  * @}
S  */ 
S
S/** @defgroup RCC_APB1_Peripherals 
S  * @{
S  */
S#define RCC_APB1Periph_TIM2              RCC_APB1ENR_TIM2EN
S#define RCC_APB1Periph_TIM3              RCC_APB1ENR_TIM3EN
S#define RCC_APB1Periph_TIM4              RCC_APB1ENR_TIM4EN
S#define RCC_APB1Periph_TIM5              RCC_APB1ENR_TIM5EN
S#define RCC_APB1Periph_TIM6              RCC_APB1ENR_TIM6EN
S#define RCC_APB1Periph_TIM7              RCC_APB1ENR_TIM7EN
S#define RCC_APB1Periph_TIM12             RCC_APB1ENR_TIM12EN
S#define RCC_APB1Periph_TIM13             RCC_APB1ENR_TIM13EN
S#define RCC_APB1Periph_TIM14             RCC_APB1ENR_TIM14EN
S#define RCC_APB1Periph_TIM18             RCC_APB1ENR_TIM18EN
S#define RCC_APB1Periph_WWDG              RCC_APB1ENR_WWDGEN
S#define RCC_APB1Periph_SPI2              RCC_APB1ENR_SPI2EN
S#define RCC_APB1Periph_SPI3              RCC_APB1ENR_SPI3EN
S#define RCC_APB1Periph_USART2            RCC_APB1ENR_USART2EN
S#define RCC_APB1Periph_USART3            RCC_APB1ENR_USART3EN
S#define RCC_APB1Periph_I2C1              RCC_APB1ENR_I2C1EN
S#define RCC_APB1Periph_I2C2              RCC_APB1ENR_I2C2EN
S#define RCC_APB1Periph_USB               RCC_APB1ENR_USBEN
S#define RCC_APB1Periph_CAN1              RCC_APB1ENR_CAN1EN
S#define RCC_APB1Periph_DAC2              RCC_APB1ENR_DAC2EN
S#define RCC_APB1Periph_PWR               RCC_APB1ENR_PWREN
S#define RCC_APB1Periph_DAC1              RCC_APB1ENR_DAC1EN
S#define RCC_APB1Periph_CEC               RCC_APB1ENR_CECEN
S
S#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x89193400) == 0x00) && ((PERIPH) != 0x00))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_MCO_Clock_Source
S  * @{
S  */
S
S#define RCC_MCOSource_NoClock            ((uint8_t)0x00)
S#define RCC_MCOSource_LSI                ((uint8_t)0x02)
S#define RCC_MCOSource_LSE                ((uint8_t)0x03)
S#define RCC_MCOSource_SYSCLK             ((uint8_t)0x04)
S#define RCC_MCOSource_HSI                ((uint8_t)0x05)
S#define RCC_MCOSource_HSE                ((uint8_t)0x06)
S#define RCC_MCOSource_PLLCLK_Div2        ((uint8_t)0x07)
S
S#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) ||((SOURCE) == RCC_MCOSource_SYSCLK) ||\
S                                    ((SOURCE) == RCC_MCOSource_HSI)  || ((SOURCE) == RCC_MCOSource_HSE) || \
S                                    ((SOURCE) == RCC_MCOSource_LSI)  || ((SOURCE) == RCC_MCOSource_LSE) || \
S                                    ((SOURCE) == RCC_MCOSource_PLLCLK_Div2))
X#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) ||((SOURCE) == RCC_MCOSource_SYSCLK) ||                                    ((SOURCE) == RCC_MCOSource_HSI)  || ((SOURCE) == RCC_MCOSource_HSE) ||                                     ((SOURCE) == RCC_MCOSource_LSI)  || ((SOURCE) == RCC_MCOSource_LSE) ||                                     ((SOURCE) == RCC_MCOSource_PLLCLK_Div2))
S/**
S  * @}
S  */ 
S
S/** @defgroup RCC_USB_Device_clock_source 
S  * @{
S  */
S
S #define RCC_USBCLKSource_PLLCLK_1Div5   ((uint8_t)0x00)
S #define RCC_USBCLKSource_PLLCLK_Div1    ((uint8_t)0x01)
S
S #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
S                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
X #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) ||                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
S/**
S  * @}
S  */
S
S/** @defgroup RCC_Flag 
S  * @{
S  */
S#define RCC_FLAG_HSIRDY                  ((uint8_t)0x01)
S#define RCC_FLAG_HSERDY                  ((uint8_t)0x11)
S#define RCC_FLAG_PLLRDY                  ((uint8_t)0x19)
S#define RCC_FLAG_LSERDY                  ((uint8_t)0x21)
S#define RCC_FLAG_LSIRDY                  ((uint8_t)0x41)
S#define RCC_FLAG_V18PWRRSTF              ((uint8_t)0x57)
S#define RCC_FLAG_OBLRST                  ((uint8_t)0x59)
S#define RCC_FLAG_PINRST                  ((uint8_t)0x5A)
S#define RCC_FLAG_PORRST                  ((uint8_t)0x5B)
S#define RCC_FLAG_SFTRST                  ((uint8_t)0x5C)
S#define RCC_FLAG_IWDGRST                 ((uint8_t)0x5D)
S#define RCC_FLAG_WWDGRST                 ((uint8_t)0x5E)
S#define RCC_FLAG_LPWRRST                 ((uint8_t)0x5F)
S
S#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
S                           ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
S                           ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_OBLRST) || \
S                           ((FLAG) == RCC_FLAG_PINRST) || ((FLAG) == RCC_FLAG_PORRST) || \
S                           ((FLAG) == RCC_FLAG_SFTRST) || ((FLAG) == RCC_FLAG_IWDGRST)|| \
S                           ((FLAG) == RCC_FLAG_WWDGRST)|| ((FLAG) == RCC_FLAG_LPWRRST)|| \
S                           ((FLAG) == RCC_FLAG_V18PWRRSTF))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_OBLRST) ||                            ((FLAG) == RCC_FLAG_PINRST) || ((FLAG) == RCC_FLAG_PORRST) ||                            ((FLAG) == RCC_FLAG_SFTRST) || ((FLAG) == RCC_FLAG_IWDGRST)||                            ((FLAG) == RCC_FLAG_WWDGRST)|| ((FLAG) == RCC_FLAG_LPWRRST)||                            ((FLAG) == RCC_FLAG_V18PWRRSTF))
S
S#define IS_RCC_HSI_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
S
S/**
S  * @}
S  */
S
S/**
S  * @}
S  */
S
S/* Exported macro ------------------------------------------------------------*/
S/* Exported functions ------------------------------------------------------- */
S
S/* Function used to set the RCC clock configuration to the default reset state */
Svoid RCC_DeInit(void);
S
S/* Internal/external clocks, PLL, CSS and MCO configuration functions *********/
Svoid RCC_HSEConfig(uint8_t RCC_HSE);
SErrorStatus RCC_WaitForHSEStartUp(void);
Svoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
Svoid RCC_HSICmd(FunctionalState NewState);
Svoid RCC_LSEConfig(uint32_t RCC_LSE);
Svoid RCC_LSEDriveConfig(uint32_t RCC_LSEDrive);
Svoid RCC_LSICmd(FunctionalState NewState);
Svoid RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);
Svoid RCC_PLLCmd(FunctionalState NewState);
Svoid RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div);
Svoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Svoid RCC_MCOConfig(uint8_t RCC_MCOSource);
S
S/* System, AHB and APB busses clocks configuration functions ******************/
Svoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
Suint8_t RCC_GetSYSCLKSource(void);
Svoid RCC_HCLKConfig(uint32_t RCC_SYSCLK);
Svoid RCC_PCLK1Config(uint32_t RCC_HCLK);
Svoid RCC_PCLK2Config(uint32_t RCC_HCLK);
Svoid RCC_ADCCLKConfig(uint32_t RCC_PCLK2);
Svoid RCC_SDADCCLKConfig(uint32_t RCC_SDADCCLK);
Svoid RCC_CECCLKConfig(uint32_t RCC_CECCLK);
Svoid RCC_I2CCLKConfig(uint32_t RCC_I2CCLK);
Svoid RCC_USARTCLKConfig(uint32_t RCC_USARTCLK);
Svoid RCC_USBCLKConfig(uint32_t RCC_USBCLKSource);
Svoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
S
S/* Peripheral clocks configuration functions **********************************/
Svoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
Svoid RCC_RTCCLKCmd(FunctionalState NewState);
Svoid RCC_BackupResetCmd(FunctionalState NewState);
S
Svoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Svoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Svoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
S
Svoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Svoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Svoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
S
S/* Interrupts and flags management functions **********************************/
Svoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
SFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
Svoid RCC_ClearFlag(void);
SITStatus RCC_GetITStatus(uint8_t RCC_IT);
Svoid RCC_ClearITPendingBit(uint8_t RCC_IT);
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif /* __STM32F37X_RCC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 50 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_rtc.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_rtc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_rtc.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the RTC 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_RTC_H
N#define __STM32F37X_RTC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RTC
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  RTC Init structures definition  
N  */ 
Ntypedef struct
N{
N  uint32_t RTC_HourFormat;   /*!< Specifies the RTC Hour Format.
N                             This parameter can be a value of @ref RTC_Hour_Formats */
N  
N  uint32_t RTC_AsynchPrediv; /*!< Specifies the RTC Asynchronous Predivider value.
N                             This parameter must be set to a value lower than 0x7F */
N  
N  uint32_t RTC_SynchPrediv;  /*!< Specifies the RTC Synchronous Predivider value.
N                             This parameter must be set to a value lower than 0x1FFF */
N}RTC_InitTypeDef;
N
N/** 
N  * @brief  RTC Time structure definition  
N  */
Ntypedef struct
N{
N  uint8_t RTC_Hours;    /*!< Specifies the RTC Time Hour.
N                        This parameter must be set to a value in the 0-12 range
N                        if the RTC_HourFormat_12 is selected or 0-23 range if
N                        the RTC_HourFormat_24 is selected. */
N
N  uint8_t RTC_Minutes;  /*!< Specifies the RTC Time Minutes.
N                        This parameter must be set to a value in the 0-59 range. */
N  
N  uint8_t RTC_Seconds;  /*!< Specifies the RTC Time Seconds.
N                        This parameter must be set to a value in the 0-59 range. */
N
N  uint8_t RTC_H12;      /*!< Specifies the RTC AM/PM Time.
N                        This parameter can be a value of @ref RTC_AM_PM_Definitions */
N}RTC_TimeTypeDef; 
N
N/** 
N  * @brief  RTC Date structure definition  
N  */
Ntypedef struct
N{
N  uint8_t RTC_WeekDay; /*!< Specifies the RTC Date WeekDay.
N                        This parameter can be a value of @ref RTC_WeekDay_Definitions */
N  
N  uint8_t RTC_Month;   /*!< Specifies the RTC Date Month (in BCD format).
N                        This parameter can be a value of @ref RTC_Month_Date_Definitions */
N
N  uint8_t RTC_Date;     /*!< Specifies the RTC Date.
N                        This parameter must be set to a value in the 1-31 range. */
N  
N  uint8_t RTC_Year;     /*!< Specifies the RTC Date Year.
N                        This parameter must be set to a value in the 0-99 range. */
N}RTC_DateTypeDef;
N
N/** 
N  * @brief  RTC Alarm structure definition  
N  */
Ntypedef struct
N{
N  RTC_TimeTypeDef RTC_AlarmTime;     /*!< Specifies the RTC Alarm Time members. */
N
N  uint32_t RTC_AlarmMask;            /*!< Specifies the RTC Alarm Masks.
N                                     This parameter can be a value of @ref RTC_AlarmMask_Definitions */
N
N  uint32_t RTC_AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
N                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
N  
N  uint8_t RTC_AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
N                                     This parameter must be set to a value in the 1-31 range 
N                                     if the Alarm Date is selected.
N                                     This parameter can be a value of @ref RTC_WeekDay_Definitions 
N                                     if the Alarm WeekDay is selected. */
N}RTC_AlarmTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RTC_Exported_Constants
N  * @{
N  */ 
N
N
N/** @defgroup RTC_Hour_Formats 
N  * @{
N  */ 
N#define RTC_HourFormat_24              ((uint32_t)0x00000000)
N#define RTC_HourFormat_12              ((uint32_t)0x00000040)
N#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) || \
N                                        ((FORMAT) == RTC_HourFormat_24))
X#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) ||                                         ((FORMAT) == RTC_HourFormat_24))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Asynchronous_Predivider 
N  * @{
N  */ 
N#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7F)
N 
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Synchronous_Predivider 
N  * @{
N  */ 
N#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Time_Definitions 
N  * @{
N  */ 
N#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0) && ((HOUR) <= 12))
N#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23)
N#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59)
N#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_AM_PM_Definitions 
N  * @{
N  */ 
N#define RTC_H12_AM                     ((uint8_t)0x00)
N#define RTC_H12_PM                     ((uint8_t)0x40)
N#define IS_RTC_H12(PM) (((PM) == RTC_H12_AM) || ((PM) == RTC_H12_PM))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Year_Date_Definitions 
N  * @{
N  */ 
N#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Month_Date_Definitions 
N  * @{
N  */ 
N  
N/* Coded in BCD format */
N#define RTC_Month_January              ((uint8_t)0x01)
N#define RTC_Month_February             ((uint8_t)0x02)
N#define RTC_Month_March                ((uint8_t)0x03)
N#define RTC_Month_April                ((uint8_t)0x04)
N#define RTC_Month_May                  ((uint8_t)0x05)
N#define RTC_Month_June                 ((uint8_t)0x06)
N#define RTC_Month_July                 ((uint8_t)0x07)
N#define RTC_Month_August               ((uint8_t)0x08)
N#define RTC_Month_September            ((uint8_t)0x09)
N#define RTC_Month_October              ((uint8_t)0x10)
N#define RTC_Month_November             ((uint8_t)0x11)
N#define RTC_Month_December             ((uint8_t)0x12)
N#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1) && ((MONTH) <= 12))
N#define IS_RTC_DATE(DATE)              (((DATE) >= 1) && ((DATE) <= 31))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_WeekDay_Definitions 
N  * @{
N  */ 
N  
N#define	RTC_Weekday_Monday             ((uint8_t)0x01)
N#define	RTC_Weekday_Tuesday            ((uint8_t)0x02)
N#define	RTC_Weekday_Wednesday          ((uint8_t)0x03)
N#define	RTC_Weekday_Thursday           ((uint8_t)0x04)
N#define	RTC_Weekday_Friday             ((uint8_t)0x05)
N#define	RTC_Weekday_Saturday           ((uint8_t)0x06)
N#define	RTC_Weekday_Sunday             ((uint8_t)0x07)
N#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Tuesday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Wednesday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Thursday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Friday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Saturday) || \
N                                 ((WEEKDAY) == RTC_Weekday_Sunday))
X#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) ||                                  ((WEEKDAY) == RTC_Weekday_Tuesday) ||                                  ((WEEKDAY) == RTC_Weekday_Wednesday) ||                                  ((WEEKDAY) == RTC_Weekday_Thursday) ||                                  ((WEEKDAY) == RTC_Weekday_Friday) ||                                  ((WEEKDAY) == RTC_Weekday_Saturday) ||                                  ((WEEKDAY) == RTC_Weekday_Sunday))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Alarm_Definitions 
N  * @{
N  */ 
N#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0) && ((DATE) <= 31))
N#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Tuesday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Wednesday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Thursday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Friday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Saturday) || \
N                                                    ((WEEKDAY) == RTC_Weekday_Sunday))
X#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) ||                                                     ((WEEKDAY) == RTC_Weekday_Tuesday) ||                                                     ((WEEKDAY) == RTC_Weekday_Wednesday) ||                                                     ((WEEKDAY) == RTC_Weekday_Thursday) ||                                                     ((WEEKDAY) == RTC_Weekday_Friday) ||                                                     ((WEEKDAY) == RTC_Weekday_Saturday) ||                                                     ((WEEKDAY) == RTC_Weekday_Sunday))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_AlarmDateWeekDay_Definitions 
N  * @{
N  */ 
N#define RTC_AlarmDateWeekDaySel_Date      ((uint32_t)0x00000000)  
N#define RTC_AlarmDateWeekDaySel_WeekDay   ((uint32_t)0x40000000)  
N
N#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) || \
N                                            ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
X#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) ||                                             ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_AlarmMask_Definitions 
N  * @{
N  */ 
N#define RTC_AlarmMask_None                ((uint32_t)0x00000000)
N#define RTC_AlarmMask_DateWeekDay         ((uint32_t)0x80000000)  
N#define RTC_AlarmMask_Hours               ((uint32_t)0x00800000)
N#define RTC_AlarmMask_Minutes             ((uint32_t)0x00008000)
N#define RTC_AlarmMask_Seconds             ((uint32_t)0x00000080)
N#define RTC_AlarmMask_All                 ((uint32_t)0x80808080)
N#define IS_ALARM_MASK(MASK)  (((MASK) & 0x7F7F7F7F) == (uint32_t)RESET)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarms_Definitions 
N  * @{
N  */ 
N#define RTC_Alarm_A                       ((uint32_t)0x00000100)
N#define RTC_Alarm_B                       ((uint32_t)0x00000200)
N#define IS_RTC_ALARM(ALARM)     (((ALARM) == RTC_Alarm_A) || ((ALARM) == RTC_Alarm_B))
N#define IS_RTC_CMD_ALARM(ALARM) (((ALARM) & (RTC_Alarm_A | RTC_Alarm_B)) != (uint32_t)RESET)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions
N  * @{
N  */ 
N#define RTC_AlarmSubSecondMask_All         ((uint32_t)0x00000000) /*!< All Alarm SS fields are masked. 
N                                                                       There is no comparison on sub seconds 
N                                                                       for Alarm */
N#define RTC_AlarmSubSecondMask_SS14_1      ((uint32_t)0x01000000) /*!< SS[14:1] are don't care in Alarm 
N                                                                       comparison. Only SS[0] is compared. */
N#define RTC_AlarmSubSecondMask_SS14_2      ((uint32_t)0x02000000) /*!< SS[14:2] are don't care in Alarm 
N                                                                       comparison. Only SS[1:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_3      ((uint32_t)0x03000000) /*!< SS[14:3] are don't care in Alarm 
N                                                                       comparison. Only SS[2:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_4      ((uint32_t)0x04000000) /*!< SS[14:4] are don't care in Alarm 
N                                                                       comparison. Only SS[3:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_5      ((uint32_t)0x05000000) /*!< SS[14:5] are don't care in Alarm 
N                                                                       comparison. Only SS[4:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_6      ((uint32_t)0x06000000) /*!< SS[14:6] are don't care in Alarm 
N                                                                       comparison. Only SS[5:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_7      ((uint32_t)0x07000000) /*!< SS[14:7] are don't care in Alarm 
N                                                                       comparison. Only SS[6:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_8      ((uint32_t)0x08000000) /*!< SS[14:8] are don't care in Alarm 
N                                                                       comparison. Only SS[7:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_9      ((uint32_t)0x09000000) /*!< SS[14:9] are don't care in Alarm 
N                                                                       comparison. Only SS[8:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_10     ((uint32_t)0x0A000000) /*!< SS[14:10] are don't care in Alarm 
N                                                                       comparison. Only SS[9:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_11     ((uint32_t)0x0B000000) /*!< SS[14:11] are don't care in Alarm 
N                                                                       comparison. Only SS[10:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_12     ((uint32_t)0x0C000000) /*!< SS[14:12] are don't care in Alarm 
N                                                                       comparison.Only SS[11:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14_13     ((uint32_t)0x0D000000) /*!< SS[14:13] are don't care in Alarm 
N                                                                       comparison. Only SS[12:0] are compared */
N#define RTC_AlarmSubSecondMask_SS14        ((uint32_t)0x0E000000) /*!< SS[14] is don't care in Alarm 
N                                                                       comparison.Only SS[13:0] are compared */
N#define RTC_AlarmSubSecondMask_None        ((uint32_t)0x0F000000) /*!< SS[14:0] are compared and must match 
N                                                                       to activate alarm. */
N#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_1) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_2) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_3) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_4) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_5) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_6) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_7) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_8) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_9) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_10) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_11) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_12) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_13) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_SS14) || \
N                                              ((MASK) == RTC_AlarmSubSecondMask_None))
X#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_1) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_2) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_3) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_4) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_5) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_6) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_7) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_8) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_9) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_10) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_11) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_12) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14_13) ||                                               ((MASK) == RTC_AlarmSubSecondMask_SS14) ||                                               ((MASK) == RTC_AlarmSubSecondMask_None))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Alarm_Sub_Seconds_Value
N  * @{
N  */ 
N
N#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= 0x00007FFF)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Wakeup_Timer_Definitions 
N  * @{
N  */
N#define RTC_WakeUpClock_RTCCLK_Div16        ((uint32_t)0x00000000)
N#define RTC_WakeUpClock_RTCCLK_Div8         ((uint32_t)0x00000001)
N#define RTC_WakeUpClock_RTCCLK_Div4         ((uint32_t)0x00000002)
N#define RTC_WakeUpClock_RTCCLK_Div2         ((uint32_t)0x00000003)
N#define RTC_WakeUpClock_CK_SPRE_16bits      ((uint32_t)0x00000004)
N#define RTC_WakeUpClock_CK_SPRE_17bits      ((uint32_t)0x00000006)
N#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WakeUpClock_RTCCLK_Div16) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div8) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div4) || \
N                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div2) || \
N                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_16bits) || \
N                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_17bits))
X#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WakeUpClock_RTCCLK_Div16) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div8) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div4) ||                                     ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div2) ||                                     ((CLOCK) == RTC_WakeUpClock_CK_SPRE_16bits) ||                                     ((CLOCK) == RTC_WakeUpClock_CK_SPRE_17bits))
N#define IS_RTC_WAKEUP_COUNTER(COUNTER)  ((COUNTER) <= 0xFFFF)
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Time_Stamp_Edges_definitions 
N  * @{
N  */ 
N#define RTC_TimeStampEdge_Rising          ((uint32_t)0x00000000)
N#define RTC_TimeStampEdge_Falling         ((uint32_t)0x00000008)
N#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) || \
N                                     ((EDGE) == RTC_TimeStampEdge_Falling))
X#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) ||                                      ((EDGE) == RTC_TimeStampEdge_Falling))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_selection_Definitions 
N  * @{
N  */ 
N#define RTC_Output_Disable             ((uint32_t)0x00000000)
N#define RTC_Output_AlarmA              ((uint32_t)0x00200000)
N#define RTC_Output_AlarmB              ((uint32_t)0x00400000)
N#define RTC_Output_WakeUp              ((uint32_t)0x00600000)
N 
N#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) || \
N                               ((OUTPUT) == RTC_Output_AlarmA) || \
N                               ((OUTPUT) == RTC_Output_AlarmB) || \
N                               ((OUTPUT) == RTC_Output_WakeUp))
X#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) ||                                ((OUTPUT) == RTC_Output_AlarmA) ||                                ((OUTPUT) == RTC_Output_AlarmB) ||                                ((OUTPUT) == RTC_Output_WakeUp))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Output_Polarity_Definitions 
N  * @{
N  */ 
N#define RTC_OutputPolarity_High           ((uint32_t)0x00000000)
N#define RTC_OutputPolarity_Low            ((uint32_t)0x00100000)
N#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) || \
N                                ((POL) == RTC_OutputPolarity_Low))
X#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) ||                                 ((POL) == RTC_OutputPolarity_Low))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup RTC_Calib_Output_selection_Definitions 
N  * @{
N  */ 
N#define RTC_CalibOutput_512Hz            ((uint32_t)0x00000000) 
N#define RTC_CalibOutput_1Hz              ((uint32_t)0x00080000)
N#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) || \
N                                      ((OUTPUT) == RTC_CalibOutput_1Hz))
X#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) ||                                       ((OUTPUT) == RTC_CalibOutput_1Hz))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_period_Definitions 
N  * @{
N  */ 
N#define RTC_SmoothCalibPeriod_32sec   ((uint32_t)0x00000000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation
N                                                             period is 32s,  else 2exp20 RTCCLK seconds */
N#define RTC_SmoothCalibPeriod_16sec   ((uint32_t)0x00002000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
N                                                             period is 16s, else 2exp19 RTCCLK seconds */
N#define RTC_SmoothCalibPeriod_8sec    ((uint32_t)0x00004000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
N                                                             period is 8s, else 2exp18 RTCCLK seconds */
N#define  IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) || \
N                                             ((PERIOD) == RTC_SmoothCalibPeriod_16sec) || \
N                                             ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
X#define  IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) ||                                              ((PERIOD) == RTC_SmoothCalibPeriod_16sec) ||                                              ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
N                                          
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_Plus_pulses_Definitions 
N  * @{
N  */ 
N#define RTC_SmoothCalibPlusPulses_Set    ((uint32_t)0x00008000) /*!<  The number of RTCCLK pulses added  
N                                                                during a X -second window = Y - CALM[8:0]. 
N                                                                 with Y = 512, 256, 128 when X = 32, 16, 8 */
N#define RTC_SmoothCalibPlusPulses_Reset  ((uint32_t)0x00000000) /*!<  The number of RTCCLK pulses subbstited
N                                                                 during a 32-second window =   CALM[8:0]. */
N#define  IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) || \
N                                         ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
X#define  IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) ||                                          ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Smooth_calib_Minus_pulses_Definitions 
N  * @{
N  */ 
N#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= 0x000001FF)
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_DayLightSaving_Definitions 
N  * @{
N  */ 
N#define RTC_DayLightSaving_SUB1H   ((uint32_t)0x00020000)
N#define RTC_DayLightSaving_ADD1H   ((uint32_t)0x00010000)
N#define IS_RTC_DAYLIGHT_SAVING(SAVING) (((SAVING) == RTC_DayLightSaving_SUB1H) || \
N                                        ((SAVING) == RTC_DayLightSaving_ADD1H))
X#define IS_RTC_DAYLIGHT_SAVING(SAVING) (((SAVING) == RTC_DayLightSaving_SUB1H) ||                                         ((SAVING) == RTC_DayLightSaving_ADD1H))
N
N#define RTC_StoreOperation_Reset        ((uint32_t)0x00000000)
N#define RTC_StoreOperation_Set          ((uint32_t)0x00040000)
N#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) || \
N                                           ((OPERATION) == RTC_StoreOperation_Set))
X#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) ||                                            ((OPERATION) == RTC_StoreOperation_Set))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Trigger_Definitions 
N  * @{
N  */ 
N#define RTC_TamperTrigger_RisingEdge            ((uint32_t)0x00000000)
N#define RTC_TamperTrigger_FallingEdge           ((uint32_t)0x00000001)
N#define RTC_TamperTrigger_LowLevel              ((uint32_t)0x00000000)
N#define RTC_TamperTrigger_HighLevel             ((uint32_t)0x00000001)
N#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_FallingEdge) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_LowLevel) || \
N                                        ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
X#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) ||                                         ((TRIGGER) == RTC_TamperTrigger_FallingEdge) ||                                         ((TRIGGER) == RTC_TamperTrigger_LowLevel) ||                                         ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Filter_Definitions 
N  * @{
N  */ 
N#define RTC_TamperFilter_Disable   ((uint32_t)0x00000000) /*!< Tamper filter is disabled */
N
N#define RTC_TamperFilter_2Sample   ((uint32_t)0x00000800) /*!< Tamper is activated after 2 
N                                                          consecutive samples at the active level */
N#define RTC_TamperFilter_4Sample   ((uint32_t)0x00001000) /*!< Tamper is activated after 4 
N                                                          consecutive samples at the active level */
N#define RTC_TamperFilter_8Sample   ((uint32_t)0x00001800) /*!< Tamper is activated after 8 
N                                                          consecutive samples at the active leve. */
N#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) || \
N                                      ((FILTER) == RTC_TamperFilter_2Sample) || \
N                                      ((FILTER) == RTC_TamperFilter_4Sample) || \
N                                      ((FILTER) == RTC_TamperFilter_8Sample))
X#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) ||                                       ((FILTER) == RTC_TamperFilter_2Sample) ||                                       ((FILTER) == RTC_TamperFilter_4Sample) ||                                       ((FILTER) == RTC_TamperFilter_8Sample))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Tamper_Sampling_Frequencies_Definitions 
N  * @{
N  */ 
N#define RTC_TamperSamplingFreq_RTCCLK_Div32768  ((uint32_t)0x00000000) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 32768 */
N#define RTC_TamperSamplingFreq_RTCCLK_Div16384  ((uint32_t)0x00000100) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 16384 */
N#define RTC_TamperSamplingFreq_RTCCLK_Div8192   ((uint32_t)0x00000200) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 8192  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div4096   ((uint32_t)0x00000300) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 4096  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div2048   ((uint32_t)0x00000400) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 2048  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div1024   ((uint32_t)0x00000500) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 1024  */
N#define RTC_TamperSamplingFreq_RTCCLK_Div512    ((uint32_t)0x00000600) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 512   */
N#define RTC_TamperSamplingFreq_RTCCLK_Div256    ((uint32_t)0x00000700) /*!< Each of the tamper inputs are sampled
N                                                                      with a frequency =  RTCCLK / 256   */
N#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) || \
N                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
X#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) ||                                            ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))
N
N/**
N  * @}
N  */
N
N  /** @defgroup RTC_Tamper_Pin_Precharge_Duration_Definitions 
N  * @{
N  */ 
N#define RTC_TamperPrechargeDuration_1RTCCLK ((uint32_t)0x00000000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 1 RTCCLK cycle */
N#define RTC_TamperPrechargeDuration_2RTCCLK ((uint32_t)0x00002000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 2 RTCCLK cycles */
N#define RTC_TamperPrechargeDuration_4RTCCLK ((uint32_t)0x00004000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 4 RTCCLK cycles */
N#define RTC_TamperPrechargeDuration_8RTCCLK ((uint32_t)0x00006000)  /*!< Tamper pins are pre-charged before 
N                                                                         sampling during 8 RTCCLK cycles */
N
N#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) || \
N                                                    ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
X#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) ||                                                     ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Tamper_Pins_Definitions 
N  * @{
N  */ 
N#define RTC_Tamper_1            RTC_TAFCR_TAMP1E /*!< Tamper detection enable for 
N                                                 input tamper 1 */
N#define RTC_Tamper_2            RTC_TAFCR_TAMP2E /*!< Tamper detection enable for 
N                                                 input tamper 2 */
N#define RTC_Tamper_3            RTC_TAFCR_TAMP3E /*!< Tamper detection enable for 
N                                                 input tamper 3 */
N
N#define IS_RTC_TAMPER(TAMPER) ((((TAMPER) & (uint32_t)0xFFFFFFD6) == 0x00) && ((TAMPER) != (uint32_t)RESET))
N
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Output_Type_ALARM_OUT 
N  * @{
N  */ 
N#define RTC_OutputType_OpenDrain           ((uint32_t)0x00000000)
N#define RTC_OutputType_PushPull            ((uint32_t)0x00040000)
N#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) || \
N                                  ((TYPE) == RTC_OutputType_PushPull))
X#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) ||                                   ((TYPE) == RTC_OutputType_PushPull))
N
N/**
N  * @}
N  */
N
N/** @defgroup RTC_Add_1_Second_Parameter_Definitions
N  * @{
N  */ 
N#define RTC_ShiftAdd1S_Reset      ((uint32_t)0x00000000)
N#define RTC_ShiftAdd1S_Set        ((uint32_t)0x80000000)
N#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) || \
N                                 ((SEL) == RTC_ShiftAdd1S_Set))
X#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) ||                                  ((SEL) == RTC_ShiftAdd1S_Set))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Substract_Fraction_Of_Second_Value
N  * @{
N  */ 
N#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= 0x00007FFF)
N
N/**
N  * @}
N  */
N  
N/** @defgroup RTC_Backup_Registers_Definitions 
N  * @{
N  */
N
N#define RTC_BKP_DR0                       ((uint32_t)0x00000000)
N#define RTC_BKP_DR1                       ((uint32_t)0x00000001)
N#define RTC_BKP_DR2                       ((uint32_t)0x00000002)
N#define RTC_BKP_DR3                       ((uint32_t)0x00000003)
N#define RTC_BKP_DR4                       ((uint32_t)0x00000004)
N#define RTC_BKP_DR5                       ((uint32_t)0x00000005)
N#define RTC_BKP_DR6                       ((uint32_t)0x00000006)
N#define RTC_BKP_DR7                       ((uint32_t)0x00000007)
N#define RTC_BKP_DR8                       ((uint32_t)0x00000008)
N#define RTC_BKP_DR9                       ((uint32_t)0x00000009)
N#define RTC_BKP_DR10                      ((uint32_t)0x0000000A)
N#define RTC_BKP_DR11                      ((uint32_t)0x0000000B)
N#define RTC_BKP_DR12                      ((uint32_t)0x0000000C)
N#define RTC_BKP_DR13                      ((uint32_t)0x0000000D)
N#define RTC_BKP_DR14                      ((uint32_t)0x0000000E)
N#define RTC_BKP_DR15                      ((uint32_t)0x0000000F)
N#define RTC_BKP_DR16                      ((uint32_t)0x00000010)
N#define RTC_BKP_DR17                      ((uint32_t)0x00000011)
N#define RTC_BKP_DR18                      ((uint32_t)0x00000012)
N#define RTC_BKP_DR19                      ((uint32_t)0x00000013)
N#define RTC_BKP_DR20                      ((uint32_t)0x00000014)
N#define RTC_BKP_DR21                      ((uint32_t)0x00000015)
N#define RTC_BKP_DR22                      ((uint32_t)0x00000016)
N#define RTC_BKP_DR23                      ((uint32_t)0x00000017)
N#define RTC_BKP_DR24                      ((uint32_t)0x00000018)
N#define RTC_BKP_DR25                      ((uint32_t)0x00000019)
N#define RTC_BKP_DR26                      ((uint32_t)0x0000001A)
N#define RTC_BKP_DR27                      ((uint32_t)0x0000001B)
N#define RTC_BKP_DR28                      ((uint32_t)0x0000001C)
N#define RTC_BKP_DR29                      ((uint32_t)0x0000001D)
N#define RTC_BKP_DR30                      ((uint32_t)0x0000001E)
N#define RTC_BKP_DR31                      ((uint32_t)0x0000001F)
N#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0) || \
N                                           ((BKP) == RTC_BKP_DR1) || \
N                                           ((BKP) == RTC_BKP_DR2) || \
N                                           ((BKP) == RTC_BKP_DR3) || \
N                                           ((BKP) == RTC_BKP_DR4) || \
N                                           ((BKP) == RTC_BKP_DR5) || \
N                                           ((BKP) == RTC_BKP_DR6) || \
N                                           ((BKP) == RTC_BKP_DR7) || \
N                                           ((BKP) == RTC_BKP_DR8) || \
N                                           ((BKP) == RTC_BKP_DR9) || \
N                                           ((BKP) == RTC_BKP_DR10) || \
N                                           ((BKP) == RTC_BKP_DR11) || \
N                                           ((BKP) == RTC_BKP_DR12) || \
N                                           ((BKP) == RTC_BKP_DR13) || \
N                                           ((BKP) == RTC_BKP_DR14) || \
N                                           ((BKP) == RTC_BKP_DR15) || \
N                                           ((BKP) == RTC_BKP_DR16) || \
N                                           ((BKP) == RTC_BKP_DR17) || \
N                                           ((BKP) == RTC_BKP_DR18) || \
N                                           ((BKP) == RTC_BKP_DR19) || \
N                                           ((BKP) == RTC_BKP_DR20) || \
N                                           ((BKP) == RTC_BKP_DR21) || \
N                                           ((BKP) == RTC_BKP_DR22) || \
N                                           ((BKP) == RTC_BKP_DR23) || \
N                                           ((BKP) == RTC_BKP_DR24) || \
N                                           ((BKP) == RTC_BKP_DR25) || \
N                                           ((BKP) == RTC_BKP_DR26) || \
N                                           ((BKP) == RTC_BKP_DR27) || \
N                                           ((BKP) == RTC_BKP_DR28) || \
N                                           ((BKP) == RTC_BKP_DR29) || \
N                                           ((BKP) == RTC_BKP_DR30) || \
N                                           ((BKP) == RTC_BKP_DR31))
X#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0) ||                                            ((BKP) == RTC_BKP_DR1) ||                                            ((BKP) == RTC_BKP_DR2) ||                                            ((BKP) == RTC_BKP_DR3) ||                                            ((BKP) == RTC_BKP_DR4) ||                                            ((BKP) == RTC_BKP_DR5) ||                                            ((BKP) == RTC_BKP_DR6) ||                                            ((BKP) == RTC_BKP_DR7) ||                                            ((BKP) == RTC_BKP_DR8) ||                                            ((BKP) == RTC_BKP_DR9) ||                                            ((BKP) == RTC_BKP_DR10) ||                                            ((BKP) == RTC_BKP_DR11) ||                                            ((BKP) == RTC_BKP_DR12) ||                                            ((BKP) == RTC_BKP_DR13) ||                                            ((BKP) == RTC_BKP_DR14) ||                                            ((BKP) == RTC_BKP_DR15) ||                                            ((BKP) == RTC_BKP_DR16) ||                                            ((BKP) == RTC_BKP_DR17) ||                                            ((BKP) == RTC_BKP_DR18) ||                                            ((BKP) == RTC_BKP_DR19) ||                                            ((BKP) == RTC_BKP_DR20) ||                                            ((BKP) == RTC_BKP_DR21) ||                                            ((BKP) == RTC_BKP_DR22) ||                                            ((BKP) == RTC_BKP_DR23) ||                                            ((BKP) == RTC_BKP_DR24) ||                                            ((BKP) == RTC_BKP_DR25) ||                                            ((BKP) == RTC_BKP_DR26) ||                                            ((BKP) == RTC_BKP_DR27) ||                                            ((BKP) == RTC_BKP_DR28) ||                                            ((BKP) == RTC_BKP_DR29) ||                                            ((BKP) == RTC_BKP_DR30) ||                                            ((BKP) == RTC_BKP_DR31))
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Input_parameter_format_definitions 
N  * @{
N  */ 
N#define RTC_Format_BIN                    ((uint32_t)0x000000000)
N#define RTC_Format_BCD                    ((uint32_t)0x000000001)
N#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_Format_BIN) || ((FORMAT) == RTC_Format_BCD))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Flags_Definitions 
N  * @{
N  */ 
N#define RTC_FLAG_RECALPF                  ((uint32_t)0x00010000)
N#define RTC_FLAG_TAMP3F                   ((uint32_t)0x00008000)
N#define RTC_FLAG_TAMP2F                   ((uint32_t)0x00004000)
N#define RTC_FLAG_TAMP1F                   ((uint32_t)0x00002000)
N#define RTC_FLAG_TSOVF                    ((uint32_t)0x00001000)
N#define RTC_FLAG_TSF                      ((uint32_t)0x00000800)
N#define RTC_FLAG_WUTF                     ((uint32_t)0x00000400)
N#define RTC_FLAG_ALRBF                    ((uint32_t)0x00000200)
N#define RTC_FLAG_ALRAF                    ((uint32_t)0x00000100)
N#define RTC_FLAG_INITF                    ((uint32_t)0x00000040)
N#define RTC_FLAG_RSF                      ((uint32_t)0x00000020)
N#define RTC_FLAG_INITS                    ((uint32_t)0x00000010)
N#define RTC_FLAG_SHPF                     ((uint32_t)0x00000008)
N#define RTC_FLAG_WUTWF                    ((uint32_t)0x00000004)
N#define RTC_FLAG_ALRBWF                   ((uint32_t)0x00000002)
N#define RTC_FLAG_ALRAWF                   ((uint32_t)0x00000001)
N#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF) || ((FLAG) == RTC_FLAG_TSF) || \
N                               ((FLAG) == RTC_FLAG_WUTF) || ((FLAG) == RTC_FLAG_ALRBF) || \
N                               ((FLAG) == RTC_FLAG_ALRAF) || ((FLAG) == RTC_FLAG_INITF) || \
N                               ((FLAG) == RTC_FLAG_RSF) || ((FLAG) == RTC_FLAG_WUTWF) || \
N                               ((FLAG) == RTC_FLAG_ALRBWF) || ((FLAG) == RTC_FLAG_ALRAWF) || \
N                               ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_TAMP2F) || \
N                                ((FLAG) == RTC_FLAG_TAMP3F) || ((FLAG) == RTC_FLAG_RECALPF) || \
N                                ((FLAG) == RTC_FLAG_SHPF))
X#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF) || ((FLAG) == RTC_FLAG_TSF) ||                                ((FLAG) == RTC_FLAG_WUTF) || ((FLAG) == RTC_FLAG_ALRBF) ||                                ((FLAG) == RTC_FLAG_ALRAF) || ((FLAG) == RTC_FLAG_INITF) ||                                ((FLAG) == RTC_FLAG_RSF) || ((FLAG) == RTC_FLAG_WUTWF) ||                                ((FLAG) == RTC_FLAG_ALRBWF) || ((FLAG) == RTC_FLAG_ALRAWF) ||                                ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_TAMP2F) ||                                 ((FLAG) == RTC_FLAG_TAMP3F) || ((FLAG) == RTC_FLAG_RECALPF) ||                                 ((FLAG) == RTC_FLAG_SHPF))
N#define IS_RTC_CLEAR_FLAG(FLAG) (((FLAG) != (uint32_t)RESET) && (((FLAG) & 0xFFFF00DF) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RTC_Interrupts_Definitions 
N  * @{
N  */ 
N#define RTC_IT_TS                         ((uint32_t)0x00008000)
N#define RTC_IT_WUT                        ((uint32_t)0x00004000)
N#define RTC_IT_ALRB                       ((uint32_t)0x00002000)
N#define RTC_IT_ALRA                       ((uint32_t)0x00001000)
N#define RTC_IT_TAMP                       ((uint32_t)0x00000004) /* Used only to Enable the Tamper Interrupt */
N#define RTC_IT_TAMP1                      ((uint32_t)0x00020000)
N#define RTC_IT_TAMP2                      ((uint32_t)0x00040000)
N#define RTC_IT_TAMP3                      ((uint32_t)0x00080000)
N
N
N#define IS_RTC_CONFIG_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFF0FFB) == (uint32_t)RESET))
N#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS)    || ((IT) == RTC_IT_WUT) || \
N                           ((IT) == RTC_IT_ALRB)  || ((IT) == RTC_IT_ALRA) || \
N                           ((IT) == RTC_IT_TAMP1) || ((IT) == RTC_IT_TAMP2) || \
N                           ((IT) == RTC_IT_TAMP3))
X#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS)    || ((IT) == RTC_IT_WUT) ||                            ((IT) == RTC_IT_ALRB)  || ((IT) == RTC_IT_ALRA) ||                            ((IT) == RTC_IT_TAMP1) || ((IT) == RTC_IT_TAMP2) ||                            ((IT) == RTC_IT_TAMP3))
N#define IS_RTC_CLEAR_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFF10FFF) == (uint32_t)RESET))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/*  Function used to set the RTC configuration to the default reset state *****/ 
NErrorStatus RTC_DeInit(void);
N
N
N/* Initialization and Configuration functions *********************************/ 
NErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct);
Nvoid RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct);
Nvoid RTC_WriteProtectionCmd(FunctionalState NewState);
NErrorStatus RTC_EnterInitMode(void);
Nvoid RTC_ExitInitMode(void);
NErrorStatus RTC_WaitForSynchro(void);
NErrorStatus RTC_RefClockCmd(FunctionalState NewState);
Nvoid RTC_BypassShadowCmd(FunctionalState NewState);
N
N/* Time and Date configuration functions **************************************/ 
NErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
Nvoid RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct);
Nvoid RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
Nuint32_t RTC_GetSubSecond(void);
NErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
Nvoid RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct);
Nvoid RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
N
N/* Alarms (Alarm A and Alarm B) configuration functions  **********************/ 
Nvoid RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
Nvoid RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct);
Nvoid RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
NErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState);
Nvoid RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask);
Nuint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm);
N
N/* WakeUp Timer configuration functions ***************************************/ 
Nvoid RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock);
Nvoid RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter);
Nuint32_t RTC_GetWakeUpCounter(void);
NErrorStatus RTC_WakeUpCmd(FunctionalState NewState);
N
N/* Daylight Saving configuration functions ************************************/ 
Nvoid RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation);
Nuint32_t RTC_GetStoreOperation(void);
N
N/* Output pin Configuration function ******************************************/ 
Nvoid RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity);
N
N/* Coarse Calibration configuration functions *********************************/
Nvoid RTC_CalibOutputCmd(FunctionalState NewState);
Nvoid RTC_CalibOutputConfig(uint32_t RTC_CalibOutput);
NErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod, 
N                                  uint32_t RTC_SmoothCalibPlusPulses,
N                                  uint32_t RTC_SmouthCalibMinusPulsesValue);
N
N/* TimeStamp configuration functions ******************************************/ 
Nvoid RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState);
Nvoid RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
N                                      RTC_DateTypeDef* RTC_StampDateStruct);
Nuint32_t RTC_GetTimeStampSubSecond(void);
N
N/* Tampers configuration functions ********************************************/ 
Nvoid RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger);
Nvoid RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState);
Nvoid RTC_TamperFilterConfig(uint32_t RTC_TamperFilter);
Nvoid RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq);
Nvoid RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration);
Nvoid RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState);
Nvoid RTC_TamperPullUpCmd(FunctionalState NewState);
N
N/* Backup Data Registers configuration functions ******************************/ 
Nvoid RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data);
Nuint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR);
N
N/* Output Type Config configuration functions *********************************/ 
Nvoid RTC_OutputTypeConfig(uint32_t RTC_OutputType);
N
N/* RTC_Shift_control_synchonisation_functions *********************************/
NErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS);
N
N/* Interrupts and flags management functions **********************************/ 
Nvoid RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState);
NFlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG);
Nvoid RTC_ClearFlag(uint32_t RTC_FLAG);
NITStatus RTC_GetITStatus(uint32_t RTC_IT);
Nvoid RTC_ClearITPendingBit(uint32_t RTC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_RTC_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 51 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_sdadc.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_sdadc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_sdadc.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the SDADC firmware 
N  *          library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_SDADC_H
N#define __STM32F37X_SDADC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SDADC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  SDADC Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t SDADC_Channel;                    /*!< Select the regular channel.
N                                                  This parameter can be any value of @ref SDADC_Channel_Selection */
N
N  FunctionalState SDADC_ContinuousConvMode;  /*!< Specifies whether the conversion is performed in
N                                                  Continuous or Single mode.
N                                                  This parameter can be set to ENABLE or DISABLE. */
N
N  FunctionalState SDADC_FastConversionMode;  /*!< Specifies whether the conversion is performed in
N                                                  fast mode.
N                                                  This parameter can be set to ENABLE or DISABLE. */
N
N}SDADC_InitTypeDef;
N
N/** 
N  * @brief  SDADC Analog Inputs Configuration structure definition  
N  */
N
Ntypedef struct
N{
N  uint32_t SDADC_InputMode;      /*!< Specifies the input structure type (single ended, differential...)
N                                      This parameter can be any value of @ref SDADC_InputMode */
N
N  uint32_t SDADC_Gain;           /*!< Specifies the gain setting.
N                                      This parameter can be any value of @ref SDADC_Gain */
N
N  uint32_t SDADC_CommonMode;     /*!< Specifies the common mode setting (VSSA, VDDA, VDDA/2).
N                                      This parameter can be any value of @ref SDADC_CommonMode */
N
N  uint32_t SDADC_Offset;         /*!< Specifies the 12-bit offset value.
N                                      This parameter can be any value lower or equal to 0x00000FFF */
N}SDADC_AINStructTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SDADC_Exported_Constants
N  * @{
N  */
N
N#define IS_SDADC_ALL_PERIPH(PERIPH) (((PERIPH) == SDADC1) || \
N                                     ((PERIPH) == SDADC2) || \
N                                     ((PERIPH) == SDADC3))
X#define IS_SDADC_ALL_PERIPH(PERIPH) (((PERIPH) == SDADC1) ||                                      ((PERIPH) == SDADC2) ||                                      ((PERIPH) == SDADC3))
N
N#define IS_SDADC_SLAVE_PERIPH(PERIPH) (((PERIPH) == SDADC2) || \
N                                       ((PERIPH) == SDADC3))
X#define IS_SDADC_SLAVE_PERIPH(PERIPH) (((PERIPH) == SDADC2) ||                                        ((PERIPH) == SDADC3))
N
N/** @defgroup SDADC_Channel_Selection
N  * @{
N  */
N
N/* SDADC Channels ------------------------------------------------------------*/
N/* The SDADC channels are defined as follow:
N   - in 16-bit LSB the channel mask is set
N   - in 16-bit MSB the channel number is set 
N   e.g. for channel 5 definition:  
N        - the channel mask is 0x00000020 (bit 5 is set) 
N        - the channel number 5 is 0x00050000 
N        --> Consequently, channel 5 definition is 0x00000020 | 0x00050000 = 0x00050020 */
N#define SDADC_Channel_0                              ((uint32_t)0x00000001)
N#define SDADC_Channel_1                              ((uint32_t)0x00010002)
N#define SDADC_Channel_2                              ((uint32_t)0x00020004)
N#define SDADC_Channel_3                              ((uint32_t)0x00030008)
N#define SDADC_Channel_4                              ((uint32_t)0x00040010)
N#define SDADC_Channel_5                              ((uint32_t)0x00050020)
N#define SDADC_Channel_6                              ((uint32_t)0x00060040)
N#define SDADC_Channel_7                              ((uint32_t)0x00070080)
N#define SDADC_Channel_8                              ((uint32_t)0x00080100)
N
N/* Just one channel of the 9 channels can be selected for regular conversion */
N#define IS_SDADC_REGULAR_CHANNEL(CHANNEL) (((CHANNEL) == SDADC_Channel_0)  || \
N                                           ((CHANNEL) == SDADC_Channel_1)  || \
N                                           ((CHANNEL) == SDADC_Channel_2)  || \
N                                           ((CHANNEL) == SDADC_Channel_3)  || \
N                                           ((CHANNEL) == SDADC_Channel_4)  || \
N                                           ((CHANNEL) == SDADC_Channel_5)  || \
N                                           ((CHANNEL) == SDADC_Channel_6)  || \
N                                           ((CHANNEL) == SDADC_Channel_7)  || \
N                                           ((CHANNEL) == SDADC_Channel_8))
X#define IS_SDADC_REGULAR_CHANNEL(CHANNEL) (((CHANNEL) == SDADC_Channel_0)  ||                                            ((CHANNEL) == SDADC_Channel_1)  ||                                            ((CHANNEL) == SDADC_Channel_2)  ||                                            ((CHANNEL) == SDADC_Channel_3)  ||                                            ((CHANNEL) == SDADC_Channel_4)  ||                                            ((CHANNEL) == SDADC_Channel_5)  ||                                            ((CHANNEL) == SDADC_Channel_6)  ||                                            ((CHANNEL) == SDADC_Channel_7)  ||                                            ((CHANNEL) == SDADC_Channel_8))
N
N/* Any or all of the 9 channels can be selected for injected conversion */
N#define IS_SDADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) != 0) && ((CHANNEL) <= 0x000F01FF))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_Conf 
N  * @{
N  */
N  
N#define SDADC_Conf_0                              ((uint32_t)0x00000000) /*!< Configuration 0 selected */
N#define SDADC_Conf_1                              ((uint32_t)0x00000001) /*!< Configuration 1 selected */
N#define SDADC_Conf_2                              ((uint32_t)0x00000002) /*!< Configuration 2 selected */
N
N#define IS_SDADC_CONF(CONF) (((CONF) == SDADC_Conf_0)  || \
N                             ((CONF) == SDADC_Conf_1)  || \
N                             ((CONF) == SDADC_Conf_2))
X#define IS_SDADC_CONF(CONF) (((CONF) == SDADC_Conf_0)  ||                              ((CONF) == SDADC_Conf_1)  ||                              ((CONF) == SDADC_Conf_2))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_InputMode
N  * @{
N  */
N
N#define SDADC_InputMode_Diff                      ((uint32_t)0x00000000) /*!< Conversions are executed in differential mode */
N#define SDADC_InputMode_SEOffset                  SDADC_CONF0R_SE0_0     /*!< Conversions are executed in single ended offset mode */
N#define SDADC_InputMode_SEZeroReference           SDADC_CONF0R_SE0       /*!< Conversions are executed in single ended zero-volt reference mode */
N
N#define IS_SDADC_INPUT_MODE(MODE) (((MODE) == SDADC_InputMode_Diff)     || \
N                                   ((MODE) == SDADC_InputMode_SEOffset) || \
N                                   ((MODE) == SDADC_InputMode_SEZeroReference))
X#define IS_SDADC_INPUT_MODE(MODE) (((MODE) == SDADC_InputMode_Diff)     ||                                    ((MODE) == SDADC_InputMode_SEOffset) ||                                    ((MODE) == SDADC_InputMode_SEZeroReference))
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_Gain 
N  * @{
N  */
N
N#define SDADC_Gain_1                              ((uint32_t)0x00000000)  /*!< Gain equal to 1 */
N#define SDADC_Gain_2                              SDADC_CONF0R_GAIN0_0    /*!< Gain equal to 2 */
N#define SDADC_Gain_4                              SDADC_CONF0R_GAIN0_1    /*!< Gain equal to 4 */
N#define SDADC_Gain_8                              ((uint32_t)0x00300000)  /*!< Gain equal to 8 */
N#define SDADC_Gain_16                             SDADC_CONF0R_GAIN0_2    /*!< Gain equal to 16 */
N#define SDADC_Gain_32                             ((uint32_t)0x00500000)  /*!< Gain equal to 32 */
N#define SDADC_Gain_1_2                            SDADC_CONF0R_GAIN0      /*!< Gain equal to 1/2 */
N
N#define IS_SDADC_GAIN(GAIN) (((GAIN) == SDADC_Gain_1)  || \
N                             ((GAIN) == SDADC_Gain_2)  || \
N                             ((GAIN) == SDADC_Gain_4)  || \
N                             ((GAIN) == SDADC_Gain_8)  || \
N                             ((GAIN) == SDADC_Gain_16)  || \
N                             ((GAIN) == SDADC_Gain_32)  || \
N                             ((GAIN) == SDADC_Gain_1_2))
X#define IS_SDADC_GAIN(GAIN) (((GAIN) == SDADC_Gain_1)  ||                              ((GAIN) == SDADC_Gain_2)  ||                              ((GAIN) == SDADC_Gain_4)  ||                              ((GAIN) == SDADC_Gain_8)  ||                              ((GAIN) == SDADC_Gain_16)  ||                              ((GAIN) == SDADC_Gain_32)  ||                              ((GAIN) == SDADC_Gain_1_2))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_CommonMode
N  * @{
N  */
N
N#define SDADC_CommonMode_VSSA                      ((uint32_t)0x00000000) /*!< Select SDADC VSSA as common mode */
N#define SDADC_CommonMode_VDDA_2                    SDADC_CONF0R_COMMON0_0 /*!< Select SDADC VDDA/2 as common mode */
N#define SDADC_CommonMode_VDDA                      SDADC_CONF0R_COMMON0_1 /*!< Select SDADC VDDA as common mode */
N
N#define IS_SDADC_COMMON_MODE(MODE) (((MODE) == SDADC_CommonMode_VSSA)   || \
N                                    ((MODE) == SDADC_CommonMode_VDDA_2) || \
N                                    ((MODE) == SDADC_CommonMode_VDDA))
X#define IS_SDADC_COMMON_MODE(MODE) (((MODE) == SDADC_CommonMode_VSSA)   ||                                     ((MODE) == SDADC_CommonMode_VDDA_2) ||                                     ((MODE) == SDADC_CommonMode_VDDA))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_Offset
N  * @{
N  */
N
N#define IS_SDADC_OFFSET_VALUE(VALUE) ((VALUE) <= 0x00000FFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_ExternalTrigger_sources
N  * @{
N  */
N#define SDADC_ExternalTrigInjecConv_T13_CC1               ((uint32_t)0x00000000) /*!< Trigger source for SDADC1 */
N#define SDADC_ExternalTrigInjecConv_T14_CC1               ((uint32_t)0x00000100) /*!< Trigger source for SDADC1 */
N#define SDADC_ExternalTrigInjecConv_T16_CC1               ((uint32_t)0x00000000) /*!< Trigger source for SDADC3 */
N#define SDADC_ExternalTrigInjecConv_T17_CC1               ((uint32_t)0x00000000) /*!< Trigger source for SDADC2 */
N#define SDADC_ExternalTrigInjecConv_T12_CC1               ((uint32_t)0x00000100) /*!< Trigger source for SDADC2 */
N#define SDADC_ExternalTrigInjecConv_T12_CC2               ((uint32_t)0x00000100) /*!< Trigger source for SDADC3 */
N#define SDADC_ExternalTrigInjecConv_T15_CC2               ((uint32_t)0x00000200) /*!< Trigger source for SDADC1 */
N#define SDADC_ExternalTrigInjecConv_T2_CC3                ((uint32_t)0x00000200) /*!< Trigger source for SDADC2 */
N#define SDADC_ExternalTrigInjecConv_T2_CC4                ((uint32_t)0x00000200) /*!< Trigger source for SDADC3 */
N#define SDADC_ExternalTrigInjecConv_T3_CC1                ((uint32_t)0x00000300) /*!< Trigger source for SDADC1 */
N#define SDADC_ExternalTrigInjecConv_T3_CC2                ((uint32_t)0x00000300) /*!< Trigger source for SDADC2 */
N#define SDADC_ExternalTrigInjecConv_T3_CC3                ((uint32_t)0x00000300) /*!< Trigger source for SDADC3 */
N#define SDADC_ExternalTrigInjecConv_T4_CC1                ((uint32_t)0x00000400) /*!< Trigger source for SDADC1 */
N#define SDADC_ExternalTrigInjecConv_T4_CC2                ((uint32_t)0x00000400) /*!< Trigger source for SDADC2 */
N#define SDADC_ExternalTrigInjecConv_T4_CC3                ((uint32_t)0x00000400) /*!< Trigger source for SDADC3 */
N#define SDADC_ExternalTrigInjecConv_T19_CC2               ((uint32_t)0x00000500) /*!< Trigger source for SDADC1 */
N#define SDADC_ExternalTrigInjecConv_T19_CC3               ((uint32_t)0x00000500) /*!< Trigger source for SDADC2 */
N#define SDADC_ExternalTrigInjecConv_T19_CC4               ((uint32_t)0x00000500) /*!< Trigger source for SDADC3 */
N#define SDADC_ExternalTrigInjecConv_Ext_IT11              ((uint32_t)0x00000700) /*!< Trigger source for SDADC1, SDADC2 and SDADC3 */
N#define SDADC_ExternalTrigInjecConv_Ext_IT15              ((uint32_t)0x00000600) /*!< Trigger source for SDADC1, SDADC2 and SDADC3 */
N
N#define IS_SDADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == SDADC_ExternalTrigInjecConv_T13_CC1) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T14_CC1) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T16_CC1) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T17_CC1) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T12_CC1) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T12_CC2)  || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T15_CC2)  || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T2_CC3)  || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T2_CC4)  || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T3_CC1)  || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T3_CC2)  || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T3_CC3) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T4_CC1) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T4_CC2) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T4_CC3) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T19_CC2) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T19_CC3) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_T19_CC4) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_Ext_IT11) || \
N                                          ((INJTRIG) == SDADC_ExternalTrigInjecConv_Ext_IT15))
X#define IS_SDADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == SDADC_ExternalTrigInjecConv_T13_CC1) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T14_CC1) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T16_CC1) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T17_CC1) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T12_CC1) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T12_CC2)  ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T15_CC2)  ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T2_CC3)  ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T2_CC4)  ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T3_CC1)  ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T3_CC2)  ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T3_CC3) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T4_CC1) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T4_CC2) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T4_CC3) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T19_CC2) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T19_CC3) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_T19_CC4) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_Ext_IT11) ||                                           ((INJTRIG) == SDADC_ExternalTrigInjecConv_Ext_IT15))
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_external_trigger_edge_for_injected_channels_conversion 
N  * @{
N  */ 
N#define SDADC_ExternalTrigInjecConvEdge_None               ((uint32_t) 0x00000000)
N#define SDADC_ExternalTrigInjecConvEdge_Rising             SDADC_CR2_JEXTEN_0
N#define SDADC_ExternalTrigInjecConvEdge_Falling            SDADC_CR2_JEXTEN_1
N#define SDADC_ExternalTrigInjecConvEdge_RisingFalling      SDADC_CR2_JEXTEN
N
N#define IS_SDADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == SDADC_ExternalTrigInjecConvEdge_None)    || \
N                                            ((EDGE) == SDADC_ExternalTrigInjecConvEdge_Rising)  || \
N                                            ((EDGE) == SDADC_ExternalTrigInjecConvEdge_Falling) || \
N                                            ((EDGE) == SDADC_ExternalTrigInjecConvEdge_RisingFalling))
X#define IS_SDADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == SDADC_ExternalTrigInjecConvEdge_None)    ||                                             ((EDGE) == SDADC_ExternalTrigInjecConvEdge_Rising)  ||                                             ((EDGE) == SDADC_ExternalTrigInjecConvEdge_Falling) ||                                             ((EDGE) == SDADC_ExternalTrigInjecConvEdge_RisingFalling))
N/**
N  * @}
N  */ 
N
N/** @defgroup SDADC_DMATransfer_modes 
N  * @{
N  */ 
N#define SDADC_DMATransfer_Regular                SDADC_CR1_RDMAEN          /*!< DMA requests enabled for regular conversions */
N#define SDADC_DMATransfer_Injected               SDADC_CR1_JDMAEN          /*!< DMA requests enabled for injected conversions */
N
N#define IS_SDADC_DMA_TRANSFER(TRANSFER)  (((TRANSFER) == SDADC_DMATransfer_Regular)  || \
N                                          ((TRANSFER) == SDADC_DMATransfer_Injected))
X#define IS_SDADC_DMA_TRANSFER(TRANSFER)  (((TRANSFER) == SDADC_DMATransfer_Regular)  ||                                           ((TRANSFER) == SDADC_DMATransfer_Injected))
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_CalibrationSequence 
N  * @{
N  */ 
N#define SDADC_CalibrationSequence_1                   ((uint32_t)0x00000000) /*!< One calibration sequence to calculate offset of conf0 (OFFSET0[11:0]) */
N#define SDADC_CalibrationSequence_2                   SDADC_CR2_CALIBCNT_0   /*!< Two calibration sequences to calculate offset of conf0 and conf1 (OFFSET0[11:0] and OFFSET1[11:0]) */
N#define SDADC_CalibrationSequence_3                   SDADC_CR2_CALIBCNT_1   /*!< Three calibration sequences to calculate offset of conf0, conf1 and conf2 (OFFSET0[11:0], OFFSET1[11:0], and OFFSET2[11:0]) */
N
N#define IS_SDADC_CALIB_SEQUENCE(SEQUENCE)  (((SEQUENCE) == SDADC_CalibrationSequence_1)  || \
N                                            ((SEQUENCE) == SDADC_CalibrationSequence_2)  || \
N                                            ((SEQUENCE) == SDADC_CalibrationSequence_3))
X#define IS_SDADC_CALIB_SEQUENCE(SEQUENCE)  (((SEQUENCE) == SDADC_CalibrationSequence_1)  ||                                             ((SEQUENCE) == SDADC_CalibrationSequence_2)  ||                                             ((SEQUENCE) == SDADC_CalibrationSequence_3))
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_VREF
N  * @{
N  */
N
N#define SDADC_VREF_Ext                            ((uint32_t)0x00000000) /*!< The reference voltage is forced externally using VREF pin */
N#define SDADC_VREF_VREFINT1                       SDADC_CR1_REFV_0       /*!< The reference voltage is forced internally to 1.22V VREFINT */
N#define SDADC_VREF_VREFINT2                       SDADC_CR1_REFV_1       /*!< The reference voltage is forced internally to 1.8V VREFINT */
N#define SDADC_VREF_VDDA                           SDADC_CR1_REFV         /*!< The reference voltage is forced internally to VDDA */
N
N#define IS_SDADC_VREF(VREF) (((VREF) == SDADC_VREF_Ext)      || \
N                             ((VREF) == SDADC_VREF_VREFINT1) || \
N                             ((VREF) == SDADC_VREF_VREFINT2) || \
N                             ((VREF) == SDADC_VREF_VDDA))
X#define IS_SDADC_VREF(VREF) (((VREF) == SDADC_VREF_Ext)      ||                              ((VREF) == SDADC_VREF_VREFINT1) ||                              ((VREF) == SDADC_VREF_VREFINT2) ||                              ((VREF) == SDADC_VREF_VDDA))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_interrupts_definition
N  * @{
N  */
N
N#define SDADC_IT_EOCAL                               ((uint32_t)0x00000001) /*!< End of calibration flag */
N#define SDADC_IT_JEOC                                ((uint32_t)0x00000002) /*!< End of injected conversion flag */
N#define SDADC_IT_JOVR                                ((uint32_t)0x00000004) /*!< Injected conversion overrun flag */
N#define SDADC_IT_REOC                                ((uint32_t)0x00000008) /*!< End of regular conversion flag */
N#define SDADC_IT_ROVR                                ((uint32_t)0x00000010) /*!< Regular conversion overrun flag */
N
N#define IS_SDADC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFE0) == 0x00000000) && ((IT) != 0x00000000))
N
N#define IS_SDADC_GET_IT(IT) (((IT) == SDADC_IT_EOCAL) || ((IT) == SDADC_IT_JEOC) || \
N                             ((IT) == SDADC_IT_JOVR)  || ((IT) == SDADC_IT_REOC) || \
N                             ((IT) == SDADC_IT_ROVR))
X#define IS_SDADC_GET_IT(IT) (((IT) == SDADC_IT_EOCAL) || ((IT) == SDADC_IT_JEOC) ||                              ((IT) == SDADC_IT_JOVR)  || ((IT) == SDADC_IT_REOC) ||                              ((IT) == SDADC_IT_ROVR))
N
N#define IS_SDADC_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFFFFFFEA) == 0x00000000) && ((IT) != 0x00000000))
N
N/**
N  * @}
N  */
N
N/** @defgroup SDADC_flags_definition
N  * @{
N  */
N
N#define SDADC_FLAG_EOCAL                             ((uint32_t)0x00000001) /*!< End of calibration flag */
N#define SDADC_FLAG_JEOC                              ((uint32_t)0x00000002) /*!< End of injected conversion flag */
N#define SDADC_FLAG_JOVR                              ((uint32_t)0x00000004) /*!< Injected conversion overrun flag */
N#define SDADC_FLAG_REOC                              ((uint32_t)0x00000008) /*!< End of regular conversion flag */
N#define SDADC_FLAG_ROVR                              ((uint32_t)0x00000010) /*!< Regular conversion overrun flag */
N#define SDADC_FLAG_CALIBIP                           ((uint32_t)0x00001000) /*!< Calibration in progress status */
N#define SDADC_FLAG_JCIP                              ((uint32_t)0x00002000) /*!< Injected conversion in progress status */
N#define SDADC_FLAG_RCIP                              ((uint32_t)0x00004000) /*!< Regular conversion in progress status */
N#define SDADC_FLAG_STABIP                            ((uint32_t)0x00008000) /*!< Stabilization in progress status */
N#define SDADC_FLAG_INITRDY                           ((uint32_t)0x80000000) /*!< Initialization mode is ready */
N
N#define IS_SDADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFE0) == 0x00000000) && ((FLAG) != 0x00000000))
N
N#define IS_SDADC_GET_FLAG(FLAG) (((FLAG) == SDADC_FLAG_EOCAL) || ((FLAG) == SDADC_FLAG_JEOC)   || \
N                                 ((FLAG) == SDADC_FLAG_JOVR)  || ((FLAG)== SDADC_FLAG_REOC)    || \
N                                 ((FLAG) == SDADC_FLAG_ROVR)  || ((FLAG)== SDADC_FLAG_CALIBIP) || \
N                                 ((FLAG) == SDADC_FLAG_JCIP)  || ((FLAG)== SDADC_FLAG_RCIP)    || \
N                                 ((FLAG) == SDADC_FLAG_STABIP)  || ((FLAG)== SDADC_FLAG_INITRDY))
X#define IS_SDADC_GET_FLAG(FLAG) (((FLAG) == SDADC_FLAG_EOCAL) || ((FLAG) == SDADC_FLAG_JEOC)   ||                                  ((FLAG) == SDADC_FLAG_JOVR)  || ((FLAG)== SDADC_FLAG_REOC)    ||                                  ((FLAG) == SDADC_FLAG_ROVR)  || ((FLAG)== SDADC_FLAG_CALIBIP) ||                                  ((FLAG) == SDADC_FLAG_JCIP)  || ((FLAG)== SDADC_FLAG_RCIP)    ||                                  ((FLAG) == SDADC_FLAG_STABIP)  || ((FLAG)== SDADC_FLAG_INITRDY))
N
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */ 
N
N/* Function used to set the SDADC configuration to the default reset state ****/
Nvoid SDADC_DeInit(SDADC_TypeDef* SDADCx);
N
N/* Initialization and Configuration functions *********************************/
Nvoid SDADC_Init(SDADC_TypeDef* SDADCx, SDADC_InitTypeDef* SDADC_InitStruct);
Nvoid SDADC_StructInit(SDADC_InitTypeDef* SDADC_InitStruct);
Nvoid SDADC_AINInit(SDADC_TypeDef* SDADCx, uint32_t SDADC_Conf, SDADC_AINStructTypeDef* SDADC_AINStruct);
Nvoid SDADC_AINStructInit(SDADC_AINStructTypeDef* SDADC_AINStruct);
Nvoid SDADC_ChannelConfig(SDADC_TypeDef* SDADCx, uint32_t SDADC_Channel, uint32_t SDADC_Conf);
Nvoid SDADC_Cmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nvoid SDADC_InitModeCmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nvoid SDADC_FastConversionCmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nvoid SDADC_VREFSelect(uint32_t SDADC_VREF);
Nvoid SDADC_CalibrationSequenceConfig(SDADC_TypeDef* SDADCx, uint32_t SDADC_CalibrationSequence);
Nvoid SDADC_StartCalibration(SDADC_TypeDef* SDADCx);
N
N/* Regular Channels Configuration functions ***********************************/
Nvoid SDADC_ChannelSelect(SDADC_TypeDef* SDADCx, uint32_t SDADC_Channel);
Nvoid SDADC_ContinuousModeCmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nvoid SDADC_SoftwareStartConv(SDADC_TypeDef* SDADCx);
Nint16_t SDADC_GetConversionValue(SDADC_TypeDef* SDADCx);
Nvoid SDADC_RegularSynchroSDADC1(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nuint32_t SDADC_GetConversionSDADC12Value(void);
Nuint32_t SDADC_GetConversionSDADC13Value(void);
N
N/* Injected channels Configuration functions **********************************/
Nvoid SDADC_SoftwareStartInjectedConv(SDADC_TypeDef* SDADCx);
Nvoid SDADC_InjectedChannelSelect(SDADC_TypeDef* SDADCx, uint32_t SDADC_Channel);
Nvoid SDADC_DelayStartInjectedConvCmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nvoid SDADC_InjectedContinuousModeCmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nvoid SDADC_ExternalTrigInjectedConvConfig(SDADC_TypeDef* SDADCx, uint32_t SDADC_ExternalTrigInjecConv);
Nvoid SDADC_ExternalTrigInjectedConvEdgeConfig(SDADC_TypeDef* SDADCx, uint32_t SDADC_ExternalTrigInjecConvEdge);
Nuint32_t SDADC_GetInjectedChannel(SDADC_TypeDef* SDADCx);
Nint16_t SDADC_GetInjectedConversionValue(SDADC_TypeDef* SDADCx, uint32_t* SDADC_Channel);
Nvoid SDADC_InjectedSynchroSDADC1(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nuint32_t SDADC_GetInjectedConversionSDADC12Value(void);
Nuint32_t SDADC_GetInjectedConversionSDADC13Value(void);
N
N/* Power saving functions *****************************************************/
Nvoid SDADC_PowerDownCmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nvoid SDADC_StandbyCmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
Nvoid SDADC_SlowClockCmd(SDADC_TypeDef* SDADCx, FunctionalState NewState);
N
N/* Regular/Injected Channels DMA Configuration functions **********************/
Nvoid SDADC_DMAConfig(SDADC_TypeDef* SDADCx, uint32_t SDADC_DMATransfer, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid SDADC_ITConfig(SDADC_TypeDef* SDADCx, uint32_t SDADC_IT, FunctionalState NewState);
NFlagStatus SDADC_GetFlagStatus(SDADC_TypeDef* SDADCx, uint32_t SDADC_FLAG);
Nvoid SDADC_ClearFlag(SDADC_TypeDef* SDADCx, uint32_t SDADC_FLAG);
NITStatus SDADC_GetITStatus(SDADC_TypeDef* SDADCx, uint32_t SDADC_IT);
Nvoid SDADC_ClearITPendingBit(SDADC_TypeDef* SDADCx, uint32_t SDADC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_SDADC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 52 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_spi.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_spi.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_spi.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the SPI 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_SPI_H
N#define __STM32F37X_SPI_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup SPI
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  SPI Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
N                                         This parameter can be a value of @ref SPI_data_direction */
N
N  uint16_t SPI_Mode;                /*!< Specifies the SPI mode (Master/Slave).
N                                         This parameter can be a value of @ref SPI_mode */
N  
N  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
N                                         This parameter can be a value of @ref SPI_data_size */
N
N  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
N                                         This parameter can be a value of @ref SPI_Clock_Polarity */
N
N  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
N                                         This parameter can be a value of @ref SPI_Clock_Phase */
N
N  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
N                                         hardware (NSS pin) or by software using the SSI bit.
N                                         This parameter can be a value of @ref SPI_Slave_Select_management */
N 
N  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
N                                         used to configure the transmit and receive SCK clock.
N                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler
N                                         @note The communication clock is derived from the master
N                                               clock. The slave clock does not need to be set. */
N
N  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
N                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */
N
N  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
N}SPI_InitTypeDef;
N
N
N/** 
N  * @brief  I2S Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.
N                                  This parameter can be a value of @ref SPI_I2S_Mode */
N
N  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.
N                                  This parameter can be a value of @ref SPI_I2S_Standard */
N
N  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.
N                                  This parameter can be a value of @ref SPI_I2S_Data_Format */
N
N  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.
N                                  This parameter can be a value of @ref SPI_I2S_MCLK_Output */
N
N  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.
N                                  This parameter can be a value of @ref SPI_I2S_Audio_Frequency */
N
N  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.
N                                  This parameter can be a value of @ref SPI_I2S_Clock_Polarity */
N}I2S_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup SPI_Exported_Constants
N  * @{
N  */
N
N#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
N                                   ((PERIPH) == SPI2) || \
N                                   ((PERIPH) == SPI3))
X#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) ||                                    ((PERIPH) == SPI2) ||                                    ((PERIPH) == SPI3))
N
N/** @defgroup SPI_data_direction 
N  * @{
N  */
N  
N#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
N#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
N#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
N#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
N#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
N                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
N                                     ((MODE) == SPI_Direction_1Line_Rx) || \
N                                     ((MODE) == SPI_Direction_1Line_Tx))
X#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) ||                                      ((MODE) == SPI_Direction_2Lines_RxOnly) ||                                      ((MODE) == SPI_Direction_1Line_Rx) ||                                      ((MODE) == SPI_Direction_1Line_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_mode 
N  * @{
N  */
N
N#define SPI_Mode_Master                 ((uint16_t)0x0104)
N#define SPI_Mode_Slave                  ((uint16_t)0x0000)
N#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
N                           ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) ||                            ((MODE) == SPI_Mode_Slave))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_data_size
N  * @{
N  */
N
N#define SPI_DataSize_4b                 ((uint16_t)0x0300)
N#define SPI_DataSize_5b                 ((uint16_t)0x0400)
N#define SPI_DataSize_6b                 ((uint16_t)0x0500)
N#define SPI_DataSize_7b                 ((uint16_t)0x0600)
N#define SPI_DataSize_8b                 ((uint16_t)0x0700)
N#define SPI_DataSize_9b                 ((uint16_t)0x0800)
N#define SPI_DataSize_10b                ((uint16_t)0x0900)
N#define SPI_DataSize_11b                ((uint16_t)0x0A00)
N#define SPI_DataSize_12b                ((uint16_t)0x0B00)
N#define SPI_DataSize_13b                ((uint16_t)0x0C00)
N#define SPI_DataSize_14b                ((uint16_t)0x0D00)
N#define SPI_DataSize_15b                ((uint16_t)0x0E00)
N#define SPI_DataSize_16b                ((uint16_t)0x0F00)
N#define IS_SPI_DATA_SIZE(SIZE) (((SIZE) == SPI_DataSize_4b) || \
N                                ((SIZE) == SPI_DataSize_5b) || \
N                                ((SIZE) == SPI_DataSize_6b) || \
N                                ((SIZE) == SPI_DataSize_7b) || \
N                                ((SIZE) == SPI_DataSize_8b) || \
N                                ((SIZE) == SPI_DataSize_9b) || \
N                                ((SIZE) == SPI_DataSize_10b) || \
N                                ((SIZE) == SPI_DataSize_11b) || \
N                                ((SIZE) == SPI_DataSize_12b) || \
N                                ((SIZE) == SPI_DataSize_13b) || \
N                                ((SIZE) == SPI_DataSize_14b) || \
N                                ((SIZE) == SPI_DataSize_15b) || \
N                                ((SIZE) == SPI_DataSize_16b))
X#define IS_SPI_DATA_SIZE(SIZE) (((SIZE) == SPI_DataSize_4b) ||                                 ((SIZE) == SPI_DataSize_5b) ||                                 ((SIZE) == SPI_DataSize_6b) ||                                 ((SIZE) == SPI_DataSize_7b) ||                                 ((SIZE) == SPI_DataSize_8b) ||                                 ((SIZE) == SPI_DataSize_9b) ||                                 ((SIZE) == SPI_DataSize_10b) ||                                 ((SIZE) == SPI_DataSize_11b) ||                                 ((SIZE) == SPI_DataSize_12b) ||                                 ((SIZE) == SPI_DataSize_13b) ||                                 ((SIZE) == SPI_DataSize_14b) ||                                 ((SIZE) == SPI_DataSize_15b) ||                                 ((SIZE) == SPI_DataSize_16b))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_length
N  * @{
N  */
N
N#define SPI_CRCLength_8b                ((uint16_t)0x0000)
N#define SPI_CRCLength_16b               SPI_CR1_CRCL
N#define IS_SPI_CRC_LENGTH(LENGTH) (((LENGTH) == SPI_CRCLength_8b) || \
N                                   ((LENGTH) == SPI_CRCLength_16b))
X#define IS_SPI_CRC_LENGTH(LENGTH) (((LENGTH) == SPI_CRCLength_8b) ||                                    ((LENGTH) == SPI_CRCLength_16b))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Polarity 
N  * @{
N  */
N
N#define SPI_CPOL_Low                    ((uint16_t)0x0000)
N#define SPI_CPOL_High                   SPI_CR1_CPOL
N#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
N                           ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) ||                            ((CPOL) == SPI_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Clock_Phase 
N  * @{
N  */
N
N#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
N#define SPI_CPHA_2Edge                  SPI_CR1_CPHA
N#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
N                           ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) ||                            ((CPHA) == SPI_CPHA_2Edge))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_Slave_Select_management 
N  * @{
N  */
N
N#define SPI_NSS_Soft                    SPI_CR1_SSM
N#define SPI_NSS_Hard                    ((uint16_t)0x0000)
N#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
N                         ((NSS) == SPI_NSS_Hard))
X#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) ||                          ((NSS) == SPI_NSS_Hard))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_BaudRate_Prescaler 
N  * @{
N  */
N
N#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
N#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
N#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
N#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
N#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
N#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
N#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
N#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
N#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
X#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_4) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_8) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_16) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_32) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_64) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_128) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_256))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_MSB_LSB_transmission 
N  * @{
N  */
N
N#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
N#define SPI_FirstBit_LSB                SPI_CR1_LSBFIRST
N#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
N                               ((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) ||                                ((BIT) == SPI_FirstBit_LSB))
N/**
N  * @}
N  */
N  
N/** @defgroup SPI_I2S_Mode 
N  * @{
N  */
N
N#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
N#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
N#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
N#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
N#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
N                           ((MODE) == I2S_Mode_SlaveRx) || \
N                           ((MODE) == I2S_Mode_MasterTx)|| \
N                           ((MODE) == I2S_Mode_MasterRx))
X#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) ||                            ((MODE) == I2S_Mode_SlaveRx) ||                            ((MODE) == I2S_Mode_MasterTx)||                            ((MODE) == I2S_Mode_MasterRx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Standard 
N  * @{
N  */
N
N#define I2S_Standard_Phillips           ((uint16_t)0x0000)
N#define I2S_Standard_MSB                ((uint16_t)0x0010)
N#define I2S_Standard_LSB                ((uint16_t)0x0020)
N#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
N#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
N#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
N                                   ((STANDARD) == I2S_Standard_MSB) || \
N                                   ((STANDARD) == I2S_Standard_LSB) || \
N                                   ((STANDARD) == I2S_Standard_PCMShort) || \
N                                   ((STANDARD) == I2S_Standard_PCMLong))
X#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) ||                                    ((STANDARD) == I2S_Standard_MSB) ||                                    ((STANDARD) == I2S_Standard_LSB) ||                                    ((STANDARD) == I2S_Standard_PCMShort) ||                                    ((STANDARD) == I2S_Standard_PCMLong))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Data_Format 
N  * @{
N  */
N
N#define I2S_DataFormat_16b              ((uint16_t)0x0000)
N#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
N#define I2S_DataFormat_24b              ((uint16_t)0x0003)
N#define I2S_DataFormat_32b              ((uint16_t)0x0005)
N#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
N                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
N                                    ((FORMAT) == I2S_DataFormat_24b) || \
N                                    ((FORMAT) == I2S_DataFormat_32b))
X#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) ||                                     ((FORMAT) == I2S_DataFormat_16bextended) ||                                     ((FORMAT) == I2S_DataFormat_24b) ||                                     ((FORMAT) == I2S_DataFormat_32b))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_MCLK_Output 
N  * @{
N  */
N
N#define I2S_MCLKOutput_Enable           SPI_I2SPR_MCKOE
N#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
N#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
N                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
X#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) ||                                     ((OUTPUT) == I2S_MCLKOutput_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Audio_Frequency 
N  * @{
N  */
N
N#define I2S_AudioFreq_192k               ((uint32_t)192000)
N#define I2S_AudioFreq_96k                ((uint32_t)96000)
N#define I2S_AudioFreq_48k                ((uint32_t)48000)
N#define I2S_AudioFreq_44k                ((uint32_t)44100)
N#define I2S_AudioFreq_32k                ((uint32_t)32000)
N#define I2S_AudioFreq_22k                ((uint32_t)22050)
N#define I2S_AudioFreq_16k                ((uint32_t)16000)
N#define I2S_AudioFreq_11k                ((uint32_t)11025)
N#define I2S_AudioFreq_8k                 ((uint32_t)8000)
N#define I2S_AudioFreq_Default            ((uint32_t)2)
N
N#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
N                                 ((FREQ) <= I2S_AudioFreq_192k)) || \
N                                 ((FREQ) == I2S_AudioFreq_Default))
X#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) &&                                  ((FREQ) <= I2S_AudioFreq_192k)) ||                                  ((FREQ) == I2S_AudioFreq_Default))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_Clock_Polarity 
N  * @{
N  */
N
N#define I2S_CPOL_Low                    ((uint16_t)0x0000)
N#define I2S_CPOL_High                   SPI_I2SCFGR_CKPOL
N#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
N                           ((CPOL) == I2S_CPOL_High))
X#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) ||                            ((CPOL) == I2S_CPOL_High))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_FIFO_reception_threshold 
N  * @{
N  */
N
N#define SPI_RxFIFOThreshold_HF          ((uint16_t)0x0000)
N#define SPI_RxFIFOThreshold_QF          SPI_CR2_FRXTH
N#define IS_SPI_RX_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == SPI_RxFIFOThreshold_HF) || \
N                                             ((THRESHOLD) == SPI_RxFIFOThreshold_QF))
X#define IS_SPI_RX_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == SPI_RxFIFOThreshold_HF) ||                                              ((THRESHOLD) == SPI_RxFIFOThreshold_QF))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_DMA_transfer_requests 
N  * @{
N  */
N
N#define SPI_I2S_DMAReq_Tx               SPI_CR2_TXDMAEN
N#define SPI_I2S_DMAReq_Rx               SPI_CR2_RXDMAEN
N#define IS_SPI_I2S_DMA_REQ(REQ) ((((REQ) & (uint16_t)0xFFFC) == 0x00) && ((REQ) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_last_DMA_transfers
N  * @{
N  */
N
N#define SPI_LastDMATransfer_TxEvenRxEven   ((uint16_t)0x0000)
N#define SPI_LastDMATransfer_TxOddRxEven    ((uint16_t)0x4000)
N#define SPI_LastDMATransfer_TxEvenRxOdd    ((uint16_t)0x2000)
N#define SPI_LastDMATransfer_TxOddRxOdd     ((uint16_t)0x6000)
N#define IS_SPI_LAST_DMA_TRANSFER(TRANSFER) (((TRANSFER) == SPI_LastDMATransfer_TxEvenRxEven) || \
N                                            ((TRANSFER) == SPI_LastDMATransfer_TxOddRxEven) || \
N                                            ((TRANSFER) == SPI_LastDMATransfer_TxEvenRxOdd) || \
N                                            ((TRANSFER) == SPI_LastDMATransfer_TxOddRxOdd))
X#define IS_SPI_LAST_DMA_TRANSFER(TRANSFER) (((TRANSFER) == SPI_LastDMATransfer_TxEvenRxEven) ||                                             ((TRANSFER) == SPI_LastDMATransfer_TxOddRxEven) ||                                             ((TRANSFER) == SPI_LastDMATransfer_TxEvenRxOdd) ||                                             ((TRANSFER) == SPI_LastDMATransfer_TxOddRxOdd))
N/**
N  * @}
N  */
N/** @defgroup SPI_NSS_internal_software_management 
N  * @{
N  */
N
N#define SPI_NSSInternalSoft_Set         SPI_CR1_SSI
N#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
N#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
N                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
X#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) ||                                        ((INTERNAL) == SPI_NSSInternalSoft_Reset))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_Transmit_Receive 
N  * @{
N  */
N
N#define SPI_CRC_Tx                      ((uint8_t)0x00)
N#define SPI_CRC_Rx                      ((uint8_t)0x01)
N#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_direction_transmit_receive 
N  * @{
N  */
N
N#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
N#define SPI_Direction_Tx                ((uint16_t)0x4000)
N#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
N                                     ((DIRECTION) == SPI_Direction_Tx))
X#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) ||                                      ((DIRECTION) == SPI_Direction_Tx))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_I2S_interrupts_definition 
N  * @{
N  */
N
N#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
N#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
N#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
N
N#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
N                                  ((IT) == SPI_I2S_IT_RXNE) || \
N                                  ((IT) == SPI_I2S_IT_ERR))
X#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) ||                                   ((IT) == SPI_I2S_IT_RXNE) ||                                   ((IT) == SPI_I2S_IT_ERR))
N
N#define I2S_IT_UDR                      ((uint8_t)0x53)
N#define SPI_IT_MODF                     ((uint8_t)0x55)
N#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
N#define SPI_I2S_IT_FRE                  ((uint8_t)0x58)
N
N#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
N                               ((IT) == SPI_I2S_IT_OVR) || ((IT) == SPI_IT_MODF) || \
N                               ((IT) == SPI_I2S_IT_FRE)|| ((IT) == I2S_IT_UDR))
X#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) ||                                ((IT) == SPI_I2S_IT_OVR) || ((IT) == SPI_IT_MODF) ||                                ((IT) == SPI_I2S_IT_FRE)|| ((IT) == I2S_IT_UDR))
N/**
N  * @}
N  */
N
N
N/** @defgroup SPI_transmission_fifo_status_level 
N  * @{
N  */ 
N
N#define SPI_TransmissionFIFOStatus_Empty           ((uint16_t)0x0000)
N#define SPI_TransmissionFIFOStatus_1QuarterFull    ((uint16_t)0x0800) 
N#define SPI_TransmissionFIFOStatus_HalfFull        ((uint16_t)0x1000) 
N#define SPI_TransmissionFIFOStatus_Full            ((uint16_t)0x1800)
N
N/**
N  * @}
N  */ 
N
N/** @defgroup SPI_reception_fifo_status_level 
N  * @{
N  */ 
N#define SPI_ReceptionFIFOStatus_Empty           ((uint16_t)0x0000)
N#define SPI_ReceptionFIFOStatus_1QuarterFull    ((uint16_t)0x0200) 
N#define SPI_ReceptionFIFOStatus_HalfFull        ((uint16_t)0x0400) 
N#define SPI_ReceptionFIFOStatus_Full            ((uint16_t)0x0600)
N
N/**
N  * @}
N  */ 
N
N
N/** @defgroup SPI_I2S_flags_definition 
N  * @{
N  */
N
N#define SPI_I2S_FLAG_RXNE               SPI_SR_RXNE
N#define SPI_I2S_FLAG_TXE                SPI_SR_TXE
N#define I2S_FLAG_CHSIDE                 SPI_SR_CHSIDE
N#define I2S_FLAG_UDR                    SPI_SR_UDR
N#define SPI_FLAG_CRCERR                 SPI_SR_CRCERR
N#define SPI_FLAG_MODF                   SPI_SR_MODF
N#define SPI_I2S_FLAG_OVR                SPI_SR_OVR
N#define SPI_I2S_FLAG_BSY                SPI_SR_BSY
N#define SPI_I2S_FLAG_FRE                SPI_SR_FRE
N
N
N
N#define IS_SPI_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
N#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
N                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
N                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)|| \
N                                   ((FLAG) == SPI_I2S_FLAG_FRE)|| ((FLAG) == I2S_FLAG_CHSIDE)|| \
N                                   ((FLAG) == I2S_FLAG_UDR))
X#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) ||                                    ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) ||                                    ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)||                                    ((FLAG) == SPI_I2S_FLAG_FRE)|| ((FLAG) == I2S_FLAG_CHSIDE)||                                    ((FLAG) == I2S_FLAG_UDR))
N/**
N  * @}
N  */
N
N/** @defgroup SPI_CRC_polynomial 
N  * @{
N  */
N
N#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Initialization and Configuration functions *********************************/
Nvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx);
Nvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
Nvoid SPI_RxFIFOThresholdConfig(SPI_TypeDef* SPIx, uint16_t SPI_RxFIFOThreshold);
Nvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
Nvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
Nvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
N
N/* Data transfers functions ***************************************************/
Nvoid SPI_SendData8(SPI_TypeDef* SPIx, uint8_t Data);
Nvoid SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data);
Nuint8_t SPI_ReceiveData8(SPI_TypeDef* SPIx);
Nuint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx);
N
N/* Hardware CRC Calculation functions *****************************************/
Nvoid SPI_CRCLengthConfig(SPI_TypeDef* SPIx, uint16_t SPI_CRCLength);
Nvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_TransmitCRC(SPI_TypeDef* SPIx);
Nuint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
Nuint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
N
N/* DMA transfers management functions *****************************************/
Nvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
Nvoid SPI_LastDMATransferCmd(SPI_TypeDef* SPIx, uint16_t SPI_LastDMATransfer);
N
N/* Interrupts and flags management functions **********************************/
Nvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
Nuint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx);
Nuint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx);
NFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
Nvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
NITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_SPI_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 53 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_tim.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_tim.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_tim.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the TIM 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_TIM_H
N#define __STM32F37X_TIM_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup TIM
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  TIM Time Base Init structure definition
N  * @note   This structure is used with all TIMx except for TIM6, TIM7 and TIM18.    
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.
N                                       This parameter can be a number between 0x0000 and 0xFFFF */
N
N  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.
N                                       This parameter can be a value of @ref TIM_Counter_Mode */
N
N  uint32_t TIM_Period;            /*!< Specifies the period value to be loaded into the active
N                                       Auto-Reload Register at the next update event.
N                                       This parameter must be a number between 0x0000 and 0xFFFF
N                                       ( or 0xFFFFFFFF for TIM2 and TIM5) */ 
N
N  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.
N                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */
N
N  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter
N                                       reaches zero, an update event is generated and counting restarts
N                                       from the RCR value (N).
N                                       This means in PWM mode that (N+1) corresponds to:
N                                          - the number of PWM periods in edge-aligned mode
N                                          - the number of half PWM period in center-aligned mode
N                                       This parameter must be a number between 0x00 and 0xFF. 
N                                       @note This parameter is valid only for TIM15, TIM16 and TIM17 . */
N
N} TIM_TimeBaseInitTypeDef;       
N
N/** 
N  * @brief  TIM Output Compare Init structure definition  
N  */
N
Ntypedef struct
N{
N  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.
N                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */
N
N  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_state */
N
N  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_state
N                                   @note This parameter is valid only for TIM15, TIM16 and TIM17. */
N
N  uint32_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register. 
N                                   This parameter can be a number between 0x0000 and 0xFFFF ( or 0xFFFFFFFF 
N                                   for TIM2) */
N
N  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */
N
N  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity
N                                   @note This parameter is valid only for TIM15, TIM16 and TIM17. */
N
N  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State
N                                   @note This parameter is valid only for TIM15, TIM16 and TIM17. */
N
N  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.
N                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State
N                                   @note This parameter is valid only for TIM15, TIM16 and TIM17. */
N
N} TIM_OCInitTypeDef;
N
N/** 
N  * @brief  TIM Input Capture Init structure definition  
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.
N                                  This parameter can be a value of @ref TIM_Channel */
N
N  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */
N
N  uint16_t TIM_ICSelection;  /*!< Specifies the input.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */
N
N  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.
N                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */
N
N  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.
N                                  This parameter can be a number between 0x0 and 0xF */
N} TIM_ICInitTypeDef;
N
N/** 
N  * @brief  TIM_BDTR structure definition 
N  * @note   This structure is used only with TIM15, TIM16 and TIM17.    
N  */
N
Ntypedef struct
N{
N
N  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.
N                                      This parameter can be a value of @ref TIM_OSSR_Off_State_Selection_for_Run_mode_state */
N
N  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.
N                                      This parameter can be a value of @ref TIM_OSSI_Off_State_Selection_for_Idle_mode_state */
N
N  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.
N                                      This parameter can be a value of @ref TIM_Lock_level */ 
N
N  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the
N                                      switching-on of the outputs.
N                                      This parameter can be a number between 0x00 and 0xFF  */
N
N  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not. 
N                                      This parameter can be a value of @ref TIM_Break_Input_enable_disable */
N
N  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.
N                                      This parameter can be a value of @ref TIM_Break_Polarity */
N
N  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not. 
N                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */
N
N} TIM_BDTRInitTypeDef;
N
N/** @defgroup TIM_Exported_constants 
N  * @{
N  */
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                   ((PERIPH) == TIM3) || \
N                                   ((PERIPH) == TIM4) || \
N                                   ((PERIPH) == TIM5) || \
N                                   ((PERIPH) == TIM6) || \
N                                   ((PERIPH) == TIM7) || \
N                                   ((PERIPH) == TIM12)|| \
N                                   ((PERIPH) == TIM13)|| \
N                                   ((PERIPH) == TIM14)|| \
N                                   ((PERIPH) == TIM15)|| \
N                                   ((PERIPH) == TIM16)|| \
N                                   ((PERIPH) == TIM17)|| \
N                                   ((PERIPH) == TIM18)|| \
N                                   ((PERIPH) == TIM19))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                    ((PERIPH) == TIM3) ||                                    ((PERIPH) == TIM4) ||                                    ((PERIPH) == TIM5) ||                                    ((PERIPH) == TIM6) ||                                    ((PERIPH) == TIM7) ||                                    ((PERIPH) == TIM12)||                                    ((PERIPH) == TIM13)||                                    ((PERIPH) == TIM14)||                                    ((PERIPH) == TIM15)||                                    ((PERIPH) == TIM16)||                                    ((PERIPH) == TIM17)||                                    ((PERIPH) == TIM18)||                                    ((PERIPH) == TIM19))
N
N/* LIST1: TIM 14 */
N#define IS_TIM_LIST1_PERIPH(PERIPH) ((PERIPH) == TIM14)
N
N/* LIST2: TIM 15 16 and 17 */
N#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17)) 
X#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17)) 
N
N/* LIST3: TIM 2, 3, 4, 5 and 19 */
N#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM19)) 
X#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM19)) 
N
N/* LIST4: TIM 2, 3, 4, 5, 15, 16, 17 and 19*/
N#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM15)|| \
N                                     ((PERIPH) == TIM16)|| \
N                                     ((PERIPH) == TIM17) || \
N                                     ((PERIPH) == TIM19))
X#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM15)||                                      ((PERIPH) == TIM16)||                                      ((PERIPH) == TIM17) ||                                      ((PERIPH) == TIM19))
N
N/* LIST5: TIM 2, 3, 4, 5, 15 and 19 */
N#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM2) || \
N                                     ((PERIPH) == TIM3) || \
N                                     ((PERIPH) == TIM4) || \
N                                     ((PERIPH) == TIM5) || \
N                                     ((PERIPH) == TIM15) || \
N                                     ((PERIPH) == TIM19)) 
X#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM2) ||                                      ((PERIPH) == TIM3) ||                                      ((PERIPH) == TIM4) ||                                      ((PERIPH) == TIM5) ||                                      ((PERIPH) == TIM15) ||                                      ((PERIPH) == TIM19)) 
N
N/* LIST6: TIM 2, 3, 4, 5, 12, 15 and 19 */
N#define IS_TIM_LIST6_PERIPH(PERIPH)  (((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM4) || \
N                                      ((PERIPH) == TIM5) || \
N                                      ((PERIPH) == TIM12)|| \
N                                      ((PERIPH) == TIM15)|| \
N                                      ((PERIPH) == TIM19))
X#define IS_TIM_LIST6_PERIPH(PERIPH)  (((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM4) ||                                       ((PERIPH) == TIM5) ||                                       ((PERIPH) == TIM12)||                                       ((PERIPH) == TIM15)||                                       ((PERIPH) == TIM19))
N
N/* LIST7: TIM 2, 3, 4, 5, 6, 7, 12, 15, 18 and 19 */
N#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM4) || \
N                                      ((PERIPH) == TIM5) || \
N                                      ((PERIPH) == TIM6) || \
N                                      ((PERIPH) == TIM7) || \
N                                      ((PERIPH) == TIM12)|| \
N                                      ((PERIPH) == TIM15)|| \
N                                      ((PERIPH) == TIM18)|| \
N                                      ((PERIPH) == TIM19))
X#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM4) ||                                       ((PERIPH) == TIM5) ||                                       ((PERIPH) == TIM6) ||                                       ((PERIPH) == TIM7) ||                                       ((PERIPH) == TIM12)||                                       ((PERIPH) == TIM15)||                                       ((PERIPH) == TIM18)||                                       ((PERIPH) == TIM19))
N
N/* LIST8: TIM 2, 3, 4, 5, 12, 13, 14, 15, 16, 17 and 19 */
N#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM4) || \
N                                      ((PERIPH) == TIM5) || \
N                                      ((PERIPH) == TIM12)|| \
N                                      ((PERIPH) == TIM13)|| \
N                                      ((PERIPH) == TIM14)|| \
N                                      ((PERIPH) == TIM15)|| \
N                                      ((PERIPH) == TIM16)|| \
N                                      ((PERIPH) == TIM17)|| \
N                                      ((PERIPH) == TIM19))
X#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM4) ||                                       ((PERIPH) == TIM5) ||                                       ((PERIPH) == TIM12)||                                       ((PERIPH) == TIM13)||                                       ((PERIPH) == TIM14)||                                       ((PERIPH) == TIM15)||                                       ((PERIPH) == TIM16)||                                       ((PERIPH) == TIM17)||                                       ((PERIPH) == TIM19))
N
N/* LIST9: TIM 2, 3, 4, 5, 6, 7, 15, 16, 17, 18 and 19 */
N#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM2) || \
N                                      ((PERIPH) == TIM3) || \
N                                      ((PERIPH) == TIM4) || \
N                                      ((PERIPH) == TIM5) || \
N                                      ((PERIPH) == TIM6) || \
N                                      ((PERIPH) == TIM7) || \
N                                      ((PERIPH) == TIM15)|| \
N                                      ((PERIPH) == TIM16)|| \
N                                      ((PERIPH) == TIM17)|| \
N                                      ((PERIPH) == TIM18)|| \
N                                      ((PERIPH) == TIM19))
X#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM2) ||                                       ((PERIPH) == TIM3) ||                                       ((PERIPH) == TIM4) ||                                       ((PERIPH) == TIM5) ||                                       ((PERIPH) == TIM6) ||                                       ((PERIPH) == TIM7) ||                                       ((PERIPH) == TIM15)||                                       ((PERIPH) == TIM16)||                                       ((PERIPH) == TIM17)||                                       ((PERIPH) == TIM18)||                                       ((PERIPH) == TIM19))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_and_PWM_modes 
N  * @{
N  */
N
N#define TIM_OCMode_Timing                  ((uint16_t)0x0000)
N#define TIM_OCMode_Active                  ((uint16_t)0x0010)
N#define TIM_OCMode_Inactive                ((uint16_t)0x0020)
N#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)
N#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)
N#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_One_Pulse_Mode 
N  * @{
N  */
N
N#define TIM_OPMode_Single                  ((uint16_t)0x0008)
N#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Channel 
N  * @{
N  */
N
N#define TIM_Channel_1                      ((uint16_t)0x0000)
N#define TIM_Channel_2                      ((uint16_t)0x0004)
N#define TIM_Channel_3                      ((uint16_t)0x0008)
N#define TIM_Channel_4                      ((uint16_t)0x000C)
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                               ((CHANNEL) == TIM_Channel_2) || \
N                                               ((CHANNEL) == TIM_Channel_3))
X#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                                ((CHANNEL) == TIM_Channel_2) ||                                                ((CHANNEL) == TIM_Channel_3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Clock_Division_CKD 
N  * @{
N  */
N
N#define TIM_CKD_DIV1                       ((uint16_t)0x0000)
N#define TIM_CKD_DIV2                       ((uint16_t)0x0100)
N#define TIM_CKD_DIV4                       ((uint16_t)0x0200)
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Counter_Mode 
N  * @{
N  */
N
N#define TIM_CounterMode_Up                 ((uint16_t)0x0000)
N#define TIM_CounterMode_Down               ((uint16_t)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Polarity 
N  * @{
N  */
N
N#define TIM_OCPolarity_High                ((uint16_t)0x0000)
N#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_N_Polarity 
N  * @{
N  */
N  
N#define TIM_OCNPolarity_High               ((uint16_t)0x0000)
N#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)
N#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
N                                       ((POLARITY) == TIM_OCNPolarity_Low))
X#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) ||                                        ((POLARITY) == TIM_OCNPolarity_Low))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Output_Compare_state
N  * @{
N  */
N
N#define TIM_OutputState_Disable            ((uint16_t)0x0000)
N#define TIM_OutputState_Enable             ((uint16_t)0x0001)
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_state 
N  * @{
N  */
N
N#define TIM_OutputNState_Disable           ((uint16_t)0x0000)
N#define TIM_OutputNState_Enable            ((uint16_t)0x0004)
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
N                                     ((STATE) == TIM_OutputNState_Enable))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) ||                                      ((STATE) == TIM_OutputNState_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_state 
N  * @{
N  */
N
N#define TIM_CCx_Enable                      ((uint16_t)0x0001)
N#define TIM_CCx_Disable                     ((uint16_t)0x0000)
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Capture_Compare_N_state 
N  * @{
N  */
N
N#define TIM_CCxN_Enable                     ((uint16_t)0x0004)
N#define TIM_CCxN_Disable                    ((uint16_t)0x0000)
N#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
N                           ((CCXN) == TIM_CCxN_Disable))
X#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) ||                            ((CCXN) == TIM_CCxN_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Break_Input_enable_disable 
N  * @{
N  */
N
N#define TIM_Break_Enable                   ((uint16_t)0x1000)
N#define TIM_Break_Disable                  ((uint16_t)0x0000)
N#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
N                                   ((STATE) == TIM_Break_Disable))
X#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) ||                                    ((STATE) == TIM_Break_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Break_Polarity 
N  * @{
N  */
N
N#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)
N#define TIM_BreakPolarity_High             ((uint16_t)0x2000)
N#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
N                                         ((POLARITY) == TIM_BreakPolarity_High))
X#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) ||                                          ((POLARITY) == TIM_BreakPolarity_High))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_AOE_Bit_Set_Reset 
N  * @{
N  */
N
N#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)
N#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
N                                              ((STATE) == TIM_AutomaticOutput_Disable))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) ||                                               ((STATE) == TIM_AutomaticOutput_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Lock_level 
N  * @{
N  */
N
N#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)
N#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)
N#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)
N#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)
N#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
N                                  ((LEVEL) == TIM_LOCKLevel_1) || \
N                                  ((LEVEL) == TIM_LOCKLevel_2) || \
N                                  ((LEVEL) == TIM_LOCKLevel_3))
X#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) ||                                   ((LEVEL) == TIM_LOCKLevel_1) ||                                   ((LEVEL) == TIM_LOCKLevel_2) ||                                   ((LEVEL) == TIM_LOCKLevel_3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_OSSI_Off_State_Selection_for_Idle_mode_state 
N  * @{
N  */
N
N#define TIM_OSSIState_Enable               ((uint16_t)0x0400)
N#define TIM_OSSIState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
N                                  ((STATE) == TIM_OSSIState_Disable))
X#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) ||                                   ((STATE) == TIM_OSSIState_Disable))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OSSR_Off_State_Selection_for_Run_mode_state 
N  * @{
N  */
N
N#define TIM_OSSRState_Enable               ((uint16_t)0x0800)
N#define TIM_OSSRState_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
N                                  ((STATE) == TIM_OSSRState_Disable))
X#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) ||                                   ((STATE) == TIM_OSSRState_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Idle_State 
N  * @{
N  */
N
N#define TIM_OCIdleState_Set                ((uint16_t)0x0100)
N#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)
N#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
N                                    ((STATE) == TIM_OCIdleState_Reset))
X#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) ||                                     ((STATE) == TIM_OCIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_N_Idle_State 
N  * @{
N  */
N
N#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)
N#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)
N#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
N                                     ((STATE) == TIM_OCNIdleState_Reset))
X#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) ||                                      ((STATE) == TIM_OCNIdleState_Reset))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Polarity 
N  * @{
N  */
N
N#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)
N#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)
N#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)
N#define IS_TIM_IC_POLARITY(POLARITY)      (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                           ((POLARITY) == TIM_ICPolarity_Falling))
X#define IS_TIM_IC_POLARITY(POLARITY)      (((POLARITY) == TIM_ICPolarity_Rising) ||                                            ((POLARITY) == TIM_ICPolarity_Falling))
N#define IS_TIM_IC_POLARITY_LITE(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                           ((POLARITY) == TIM_ICPolarity_Falling)|| \
N                                           ((POLARITY) == TIM_ICPolarity_BothEdge))                                      
X#define IS_TIM_IC_POLARITY_LITE(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                            ((POLARITY) == TIM_ICPolarity_Falling)||                                            ((POLARITY) == TIM_ICPolarity_BothEdge))                                      
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Selection 
N  * @{
N  */
N
N#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be 
N                                                                   connected to IC1, IC2, IC3 or IC4, respectively */
N#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be
N                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */
N#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Prescaler 
N  * @{
N  */
N
N#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */
N#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */
N#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */
N#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_interrupt_sources 
N  * @{
N  */
N
N#define TIM_IT_Update                      ((uint16_t)0x0001)
N#define TIM_IT_CC1                         ((uint16_t)0x0002)
N#define TIM_IT_CC2                         ((uint16_t)0x0004)
N#define TIM_IT_CC3                         ((uint16_t)0x0008)
N#define TIM_IT_CC4                         ((uint16_t)0x0010)
N#define TIM_IT_COM                         ((uint16_t)0x0020)
N#define TIM_IT_Trigger                     ((uint16_t)0x0040)
N#define TIM_IT_Break                       ((uint16_t)0x0080)
N#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_COM) || \
N                           ((IT) == TIM_IT_Trigger) || \
N                           ((IT) == TIM_IT_Break))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_COM) ||                            ((IT) == TIM_IT_Trigger) ||                            ((IT) == TIM_IT_Break))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Base_address 
N  * @{
N  */
N
N#define TIM_DMABase_CR1                    ((uint16_t)0x0000)
N#define TIM_DMABase_CR2                    ((uint16_t)0x0001)
N#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)
N#define TIM_DMABase_DIER                   ((uint16_t)0x0003)
N#define TIM_DMABase_SR                     ((uint16_t)0x0004)
N#define TIM_DMABase_EGR                    ((uint16_t)0x0005)
N#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)
N#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)
N#define TIM_DMABase_CCER                   ((uint16_t)0x0008)
N#define TIM_DMABase_CNT                    ((uint16_t)0x0009)
N#define TIM_DMABase_PSC                    ((uint16_t)0x000A)
N#define TIM_DMABase_ARR                    ((uint16_t)0x000B)
N#define TIM_DMABase_RCR                    ((uint16_t)0x000C)
N#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)
N#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)
N#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)
N#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)
N#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)
N#define TIM_DMABase_DCR                    ((uint16_t)0x0012)
N#define TIM_DMABase_OR                     ((uint16_t)0x0013)
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_RCR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_BDTR) || \
N                               ((BASE) == TIM_DMABase_OR) || \
N                               ((BASE) == TIM_DMABase_DCR))
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_RCR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_BDTR) ||                                ((BASE) == TIM_DMABase_OR) ||                                ((BASE) == TIM_DMABase_DCR))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_Burst_Length 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)
N#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)
N#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)
N#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)
N#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)
N#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)
N#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)
N#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)
N#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)
N#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)
N#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)
N#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)
N#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)
N#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)
N#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)
N#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)
N#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)
N#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) ||                                    ((LENGTH) == TIM_DMABurstLength_2Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_3Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_4Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_5Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_6Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_7Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_8Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_9Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_10Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_11Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_12Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_13Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_14Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_15Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_16Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_17Transfers) ||                                    ((LENGTH) == TIM_DMABurstLength_18Transfers))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_DMA_sources 
N  * @{
N  */
N
N#define TIM_DMA_Update                     ((uint16_t)0x0100)
N#define TIM_DMA_CC1                        ((uint16_t)0x0200)
N#define TIM_DMA_CC2                        ((uint16_t)0x0400)
N#define TIM_DMA_CC3                        ((uint16_t)0x0800)
N#define TIM_DMA_CC4                        ((uint16_t)0x1000)
N#define TIM_DMA_COM                        ((uint16_t)0x2000)
N#define TIM_DMA_Trigger                    ((uint16_t)0x4000)
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Prescaler 
N  * @{
N  */
N
N#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Internal_Trigger_Selection 
N  * @{
N  */
N
N#define TIM_TS_ITR0                        ((uint16_t)0x0000)
N#define TIM_TS_ITR1                        ((uint16_t)0x0010)
N#define TIM_TS_ITR2                        ((uint16_t)0x0020)
N#define TIM_TS_ITR3                        ((uint16_t)0x0030)
N#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)
N#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)
N#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)
N#define TIM_TS_ETRF                        ((uint16_t)0x0070)
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_TIx_External_Clock_Source 
N  * @{
N  */
N
N#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)
N#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
X#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Polarity 
N  * @{
N  */ 
N#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Prescaler_Reload_Mode 
N  * @{
N  */
N
N#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Forced_Action 
N  * @{
N  */
N
N#define TIM_ForcedAction_Active            ((uint16_t)0x0050)
N#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Encoder_Mode 
N  * @{
N  */
N
N#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)
N#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)
N#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N/**
N  * @}
N  */ 
N
N
N/** @defgroup TIM_Event_Source 
N  * @{
N  */
N
N#define TIM_EventSource_Update             ((uint16_t)0x0001)
N#define TIM_EventSource_CC1                ((uint16_t)0x0002)
N#define TIM_EventSource_CC2                ((uint16_t)0x0004)
N#define TIM_EventSource_CC3                ((uint16_t)0x0008)
N#define TIM_EventSource_CC4                ((uint16_t)0x0010)
N#define TIM_EventSource_COM                ((uint16_t)0x0020)
N#define TIM_EventSource_Trigger            ((uint16_t)0x0040)
N#define TIM_EventSource_Break              ((uint16_t)0x0080)
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Update_Source 
N  * @{
N  */
N
N#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow
N                                                                   or the setting of UG bit, or an update generation
N                                                                   through the slave mode controller. */
N#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Preload_State 
N  * @{
N  */
N
N#define TIM_OCPreload_Enable               ((uint16_t)0x0008)
N#define TIM_OCPreload_Disable              ((uint16_t)0x0000)
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Fast_State 
N  * @{
N  */
N
N#define TIM_OCFast_Enable                  ((uint16_t)0x0004)
N#define TIM_OCFast_Disable                 ((uint16_t)0x0000)
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Output_Compare_Clear_State 
N  * @{
N  */
N
N#define TIM_OCClear_Enable                 ((uint16_t)0x0080)
N#define TIM_OCClear_Disable                ((uint16_t)0x0000)
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Trigger_Output_Source 
N  * @{
N  */
N
N#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)
N#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)
N#define TIM_TRGOSource_Update              ((uint16_t)0x0020)
N#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Slave_Mode 
N  * @{
N  */
N
N#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)
N#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)
N#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)
N#define TIM_SlaveMode_External1            ((uint16_t)0x0007)
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Master_Slave_Mode 
N  * @{
N  */
N
N#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Flags 
N  * @{
N  */
N
N#define TIM_FLAG_Update                    ((uint16_t)0x0001)
N#define TIM_FLAG_CC1                       ((uint16_t)0x0002)
N#define TIM_FLAG_CC2                       ((uint16_t)0x0004)
N#define TIM_FLAG_CC3                       ((uint16_t)0x0008)
N#define TIM_FLAG_CC4                       ((uint16_t)0x0010)
N#define TIM_FLAG_COM                       ((uint16_t)0x0020)
N#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)
N#define TIM_FLAG_Break                     ((uint16_t)0x0080)
N#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)
N#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)
N#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)
N#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_COM) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_Break) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_COM) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_Break) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N                               
N                               
N#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) & (uint16_t)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000))
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_Input_Capture_Filer_Value 
N  * @{
N  */
N
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N/**
N  * @}
N  */ 
N
N/** @defgroup TIM_External_Trigger_Filter 
N  * @{
N  */
N
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)
N/**
N  * @}
N  */
N
N/** @defgroup TIM_OCReferenceClear 
N  * @{
N  */
N#define TIM_OCReferenceClear_ETRF          ((uint16_t)0x0008)
N#define TIM_OCReferenceClear_OCREFCLR      ((uint16_t)0x0000)
N#define TIM_OCREFERENCECECLEAR_SOURCE(SOURCE) (((SOURCE) == TIM_OCReferenceClear_ETRF) || \
N                                              ((SOURCE) == TIM_OCReferenceClear_OCREFCLR)) 
X#define TIM_OCREFERENCECECLEAR_SOURCE(SOURCE) (((SOURCE) == TIM_OCReferenceClear_ETRF) ||                                               ((SOURCE) == TIM_OCReferenceClear_OCREFCLR)) 
N
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Remap 
N  * @{
N  */
N#define TIM14_GPIO                      ((uint16_t)0x0000)
N#define TIM14_RTC_CLK                   ((uint16_t)0x0001)
N#define TIM14_HSEDiv32                  ((uint16_t)0x0002)
N#define TIM14_MCO                       ((uint16_t)0x0003)
N
N#define IS_TIM_REMAP(TIM_REMAP)  (((TIM_REMAP) == TIM14_GPIO)|| \
N                                  ((TIM_REMAP) == TIM14_RTC_CLK) || \
N                                  ((TIM_REMAP) == TIM14_HSEDiv32) || \
N                                  ((TIM_REMAP) == TIM14_MCO))
X#define IS_TIM_REMAP(TIM_REMAP)  (((TIM_REMAP) == TIM14_GPIO)||                                   ((TIM_REMAP) == TIM14_RTC_CLK) ||                                   ((TIM_REMAP) == TIM14_HSEDiv32) ||                                   ((TIM_REMAP) == TIM14_MCO))
N/**
N  * @}
N  */
N
N/** @defgroup TIM_Legacy 
N  * @{
N  */
N
N#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer
N#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers
N#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers
N#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers
N#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers
N#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers
N#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers
N#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers
N#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers
N#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers
N#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers
N#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers
N#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers
N#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers
N#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers
N#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers
N#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers
N#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/ 
N
N/* TimeBase management ********************************************************/
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload);
Nuint32_t TIM_GetCounter(TIM_TypeDef* TIMx);
Nuint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Advanced-control timers (TIM15, TIM16 and TIM17) specific features*******************/
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Output Compare management **************************************************/
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);
Nvoid TIM_SelectOCREFClear(TIM_TypeDef* TIMx, uint16_t TIM_OCReferenceClear);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Input Capture management ***************************************************/
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nuint32_t TIM_GetCapture1(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture2(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture3(TIM_TypeDef* TIMx);
Nuint32_t TIM_GetCapture4(TIM_TypeDef* TIMx);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);
N
N/* Interrupts, DMA and flags management ***************************************/
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Clocks management **********************************************************/
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
N                                uint16_t TIM_ICPolarity, uint16_t ICFilter);
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                             uint16_t ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
N                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);
N
N
N/* Synchronization management *************************************************/
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
N                   uint16_t ExtTRGFilter);
N
N/* Specific interface management **********************************************/                   
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
N                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
N
N/* Specific remapping management **********************************************/
Nvoid TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /*__STM32F37X_TIM_H */
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 54 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_usart.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_usart.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_usart.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the USART 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_USART_H
N#define __STM32F37X_USART_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup USART
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N
N   
N   
N/** 
N  * @brief  USART Init Structure definition  
N  */ 
N
Ntypedef struct
N{
N  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
N                                           The baud rate is computed using the following formula:
N                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->USART_BaudRate)))
N                                            - FractionalDivider = ((IntegerDivider - ((uint32_t) IntegerDivider)) * 16) + 0.5 */
N
N  uint32_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
N                                           This parameter can be a value of @ref USART_Word_Length */
N
N  uint32_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
N                                           This parameter can be a value of @ref USART_Stop_Bits */
N
N  uint32_t USART_Parity;              /*!< Specifies the parity mode.
N                                           This parameter can be a value of @ref USART_Parity
N                                           @note When parity is enabled, the computed parity is inserted
N                                                 at the MSB position of the transmitted data (9th bit when
N                                                 the word length is set to 9 data bits; 8th bit when the
N                                                 word length is set to 8 data bits). */
N 
N  uint32_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.
N                                           This parameter can be a value of @ref USART_Mode */
N
N  uint32_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
N                                           or disabled.
N                                           This parameter can be a value of @ref USART_Hardware_Flow_Control*/
N} USART_InitTypeDef;
N
N/** 
N  * @brief  USART Clock Init Structure definition
N  */ 
N
Ntypedef struct
N{
N  uint32_t USART_Clock;             /*!< Specifies whether the USART clock is enabled or disabled.
N                                         This parameter can be a value of @ref USART_Clock */
N
N  uint32_t USART_CPOL;              /*!< Specifies the steady state of the serial clock.
N                                         This parameter can be a value of @ref USART_Clock_Polarity */
N
N  uint32_t USART_CPHA;              /*!< Specifies the clock transition on which the bit capture is made.
N                                         This parameter can be a value of @ref USART_Clock_Phase */
N
N  uint32_t USART_LastBit;           /*!< Specifies whether the clock pulse corresponding to the last transmitted
N                                         data bit (MSB) has to be output on the SCLK pin in synchronous mode.
N                                         This parameter can be a value of @ref USART_Last_Bit */
N} USART_ClockInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup USART_Exported_Constants
N  * @{
N  */ 
N
N#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
N                                     ((PERIPH) == USART2) || \
N                                     ((PERIPH) == USART3))
X#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) ||                                      ((PERIPH) == USART2) ||                                      ((PERIPH) == USART3))
N
N
N/** @defgroup USART_Word_Length 
N  * @{
N  */ 
N
N#define USART_WordLength_8b                  ((uint32_t)0x00000000)
N#define USART_WordLength_9b                  USART_CR1_M
N#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
N                                      ((LENGTH) == USART_WordLength_9b))
X#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) ||                                       ((LENGTH) == USART_WordLength_9b))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Stop_Bits 
N  * @{
N  */ 
N
N#define USART_StopBits_1                     ((uint32_t)0x00000000)
N#define USART_StopBits_2                     USART_CR2_STOP_1
N#define USART_StopBits_1_5                   (USART_CR2_STOP_0 | USART_CR2_STOP_1)
N#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
N                                     ((STOPBITS) == USART_StopBits_2) || \
N                                     ((STOPBITS) == USART_StopBits_1_5))
X#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) ||                                      ((STOPBITS) == USART_StopBits_2) ||                                      ((STOPBITS) == USART_StopBits_1_5))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Parity 
N  * @{
N  */ 
N
N#define USART_Parity_No                      ((uint32_t)0x00000000)
N#define USART_Parity_Even                    USART_CR1_PCE
N#define USART_Parity_Odd                     (USART_CR1_PCE | USART_CR1_PS) 
N#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
N                                 ((PARITY) == USART_Parity_Even) || \
N                                 ((PARITY) == USART_Parity_Odd))
X#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) ||                                  ((PARITY) == USART_Parity_Even) ||                                  ((PARITY) == USART_Parity_Odd))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Mode 
N  * @{
N  */ 
N
N#define USART_Mode_Rx                        USART_CR1_RE
N#define USART_Mode_Tx                        USART_CR1_TE
N#define IS_USART_MODE(MODE) ((((MODE) & (uint32_t)0xFFFFFFF3) == 0x00) && \
N                              ((MODE) != (uint32_t)0x00))
X#define IS_USART_MODE(MODE) ((((MODE) & (uint32_t)0xFFFFFFF3) == 0x00) &&                               ((MODE) != (uint32_t)0x00))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Hardware_Flow_Control 
N  * @{
N  */ 
N
N#define USART_HardwareFlowControl_None       ((uint32_t)0x00000000)
N#define USART_HardwareFlowControl_RTS        USART_CR3_RTSE
N#define USART_HardwareFlowControl_CTS        USART_CR3_CTSE
N#define USART_HardwareFlowControl_RTS_CTS    (USART_CR3_RTSE | USART_CR3_CTSE)
N#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == USART_HardwareFlowControl_None) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
X#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == USART_HardwareFlowControl_None) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS) ||                                ((CONTROL) == USART_HardwareFlowControl_CTS) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock 
N  * @{
N  */ 
N  
N#define USART_Clock_Disable                  ((uint32_t)0x00000000)
N#define USART_Clock_Enable                   USART_CR2_CLKEN
N#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
N                               ((CLOCK) == USART_Clock_Enable))
X#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) ||                                ((CLOCK) == USART_Clock_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Polarity 
N  * @{
N  */
N  
N#define USART_CPOL_Low                       ((uint32_t)0x00000000)
N#define USART_CPOL_High                      USART_CR2_CPOL
N#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Clock_Phase
N  * @{
N  */
N
N#define USART_CPHA_1Edge                     ((uint32_t)0x00000000)
N#define USART_CPHA_2Edge                     USART_CR2_CPHA
N#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
N
N/**
N  * @}
N  */
N
N/** @defgroup USART_Last_Bit
N  * @{
N  */
N
N#define USART_LastBit_Disable                ((uint32_t)0x00000000)
N#define USART_LastBit_Enable                 USART_CR2_LBCL
N#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
N                                   ((LASTBIT) == USART_LastBit_Enable))
X#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) ||                                    ((LASTBIT) == USART_LastBit_Enable))
N/**
N  * @}
N  */
N  
N/** @defgroup USART_DMA_Requests 
N  * @{
N  */
N
N#define USART_DMAReq_Tx                      USART_CR3_DMAT
N#define USART_DMAReq_Rx                      USART_CR3_DMAR
N#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint32_t)0xFFFFFF3F) == 0x00) && \
N                                  ((DMAREQ) != (uint32_t)0x00))
X#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint32_t)0xFFFFFF3F) == 0x00) &&                                   ((DMAREQ) != (uint32_t)0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_DMA_Recception_Error
N  * @{
N  */
N
N#define USART_DMAOnError_Enable              ((uint32_t)0x00000000)
N#define USART_DMAOnError_Disable             USART_CR3_DDRE
N#define IS_USART_DMAONERROR(DMAERROR) (((DMAERROR) == USART_DMAOnError_Disable)|| \
N                                       ((DMAERROR) == USART_DMAOnError_Enable))
X#define IS_USART_DMAONERROR(DMAERROR) (((DMAERROR) == USART_DMAOnError_Disable)||                                        ((DMAERROR) == USART_DMAOnError_Enable))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_MuteMode_WakeUp_methods
N  * @{
N  */
N
N#define USART_WakeUp_IdleLine                ((uint32_t)0x00000000)
N#define USART_WakeUp_AddressMark             USART_CR1_WAKE
N#define IS_USART_MUTEMODE_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
N                                          ((WAKEUP) == USART_WakeUp_AddressMark))
X#define IS_USART_MUTEMODE_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) ||                                           ((WAKEUP) == USART_WakeUp_AddressMark))
N/**
N  * @}
N  */
N
N/** @defgroup USART_Address_Detection
N  * @{
N  */ 
N
N#define USART_AddressLength_4b               ((uint32_t)0x00000000)
N#define USART_AddressLength_7b               USART_CR2_ADDM7
N#define IS_USART_ADDRESS_DETECTION(ADDRESS) (((ADDRESS) == USART_AddressLength_4b) || \
N                                             ((ADDRESS) == USART_AddressLength_7b))
X#define IS_USART_ADDRESS_DETECTION(ADDRESS) (((ADDRESS) == USART_AddressLength_4b) ||                                              ((ADDRESS) == USART_AddressLength_7b))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_StopMode_WakeUp_methods 
N  * @{
N  */ 
N
N#define USART_WakeUpSource_AddressMatch      ((uint32_t)0x00000000)
N#define USART_WakeUpSource_StartBit          USART_CR3_WUS_1
N#define USART_WakeUpSource_RXNE              (USART_CR3_WUS_0 | USART_CR3_WUS_1)
N#define IS_USART_STOPMODE_WAKEUPSOURCE(SOURCE) (((SOURCE) == USART_WakeUpSource_AddressMatch) || \
N                                                ((SOURCE) == USART_WakeUpSource_StartBit) || \
N                                                ((SOURCE) == USART_WakeUpSource_RXNE))
X#define IS_USART_STOPMODE_WAKEUPSOURCE(SOURCE) (((SOURCE) == USART_WakeUpSource_AddressMatch) ||                                                 ((SOURCE) == USART_WakeUpSource_StartBit) ||                                                 ((SOURCE) == USART_WakeUpSource_RXNE))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_LIN_Break_Detection_Length 
N  * @{
N  */
N  
N#define USART_LINBreakDetectLength_10b       ((uint32_t)0x00000000)
N#define USART_LINBreakDetectLength_11b       USART_CR2_LBDL
N#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
N                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
N                                ((LENGTH) == USART_LINBreakDetectLength_11b))
X#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH)                                (((LENGTH) == USART_LINBreakDetectLength_10b) ||                                 ((LENGTH) == USART_LINBreakDetectLength_11b))
N/**
N  * @}
N  */
N
N/** @defgroup USART_IrDA_Low_Power 
N  * @{
N  */
N
N#define USART_IrDAMode_LowPower              USART_CR3_IRLP
N#define USART_IrDAMode_Normal                ((uint32_t)0x00000000)
N#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
N                                  ((MODE) == USART_IrDAMode_Normal))
X#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) ||                                   ((MODE) == USART_IrDAMode_Normal))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_DE_Polarity 
N  * @{
N  */
N
N#define USART_DEPolarity_High                ((uint32_t)0x00000000)
N#define USART_DEPolarity_Low                 USART_CR3_DEP
N#define IS_USART_DE_POLARITY(POLARITY) (((POLARITY) == USART_DEPolarity_Low) || \
N                                        ((POLARITY) == USART_DEPolarity_High))
X#define IS_USART_DE_POLARITY(POLARITY) (((POLARITY) == USART_DEPolarity_Low) ||                                         ((POLARITY) == USART_DEPolarity_High))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Inversion_Pins 
N  * @{
N  */
N
N#define USART_InvPin_Tx                      USART_CR2_TXINV
N#define USART_InvPin_Rx                      USART_CR2_RXINV
N#define IS_USART_INVERSTION_PIN(PIN) ((((PIN) & (uint32_t)0xFFFCFFFF) == 0x00) && \
N                                       ((PIN) != (uint32_t)0x00))
X#define IS_USART_INVERSTION_PIN(PIN) ((((PIN) & (uint32_t)0xFFFCFFFF) == 0x00) &&                                        ((PIN) != (uint32_t)0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_AutoBaudRate_Mode 
N  * @{
N  */
N
N#define USART_AutoBaudRate_StartBit          ((uint32_t)0x00000000)
N#define USART_AutoBaudRate_FallingEdge       USART_CR2_ABRMODE_0
N#define IS_USART_AUTOBAUDRATE_MODE(MODE) (((MODE) == USART_AutoBaudRate_StartBit) || \
N                                          ((MODE) == USART_AutoBaudRate_FallingEdge))
X#define IS_USART_AUTOBAUDRATE_MODE(MODE) (((MODE) == USART_AutoBaudRate_StartBit) ||                                           ((MODE) == USART_AutoBaudRate_FallingEdge))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_OVR_DETECTION
N  * @{
N  */
N
N#define USART_OVRDetection_Enable            ((uint32_t)0x00000000)
N#define USART_OVRDetection_Disable           USART_CR3_OVRDIS
N#define IS_USART_OVRDETECTION(OVR) (((OVR) == USART_OVRDetection_Enable)|| \
N                                    ((OVR) == USART_OVRDetection_Disable))
X#define IS_USART_OVRDETECTION(OVR) (((OVR) == USART_OVRDetection_Enable)||                                     ((OVR) == USART_OVRDetection_Disable))
N/**
N  * @}
N  */ 
N/** @defgroup USART_Request 
N  * @{
N  */
N
N#define USART_Request_ABRRQ                  USART_RQR_ABRRQ
N#define USART_Request_SBKRQ                  USART_RQR_SBKRQ
N#define USART_Request_MMRQ                   USART_RQR_MMRQ
N#define USART_Request_RXFRQ                  USART_RQR_RXFRQ
N#define USART_Request_TXFRQ                  USART_RQR_TXFRQ
N
N#define IS_USART_REQUEST(REQUEST) (((REQUEST) == USART_Request_TXFRQ) || \
N                                   ((REQUEST) == USART_Request_RXFRQ) || \
N                                   ((REQUEST) == USART_Request_MMRQ) || \
N                                   ((REQUEST) == USART_Request_SBKRQ) || \
N                                   ((REQUEST) == USART_Request_ABRRQ))
X#define IS_USART_REQUEST(REQUEST) (((REQUEST) == USART_Request_TXFRQ) ||                                    ((REQUEST) == USART_Request_RXFRQ) ||                                    ((REQUEST) == USART_Request_MMRQ) ||                                    ((REQUEST) == USART_Request_SBKRQ) ||                                    ((REQUEST) == USART_Request_ABRRQ))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Flags 
N  * @{
N  */
N#define USART_FLAG_REACK                     USART_ISR_REACK
N#define USART_FLAG_TEACK                     USART_ISR_TEACK
N#define USART_FLAG_WU                        USART_ISR_WUF
N#define USART_FLAG_RWU                       USART_ISR_RWU
N#define USART_FLAG_SBK                       USART_ISR_SBKF
N#define USART_FLAG_CM                        USART_ISR_CMF
N#define USART_FLAG_BUSY                      USART_ISR_BUSY
N#define USART_FLAG_ABRF                      USART_ISR_ABRF
N#define USART_FLAG_ABRE                      USART_ISR_ABRE
N#define USART_FLAG_EOB                       USART_ISR_EOBF
N#define USART_FLAG_RTO                       USART_ISR_RTOF
N#define USART_FLAG_nCTSS                     USART_ISR_CTS 
N#define USART_FLAG_CTS                       USART_ISR_CTSIF
N#define USART_FLAG_LBD                       USART_ISR_LBD
N#define USART_FLAG_TXE                       USART_ISR_TXE
N#define USART_FLAG_TC                        USART_ISR_TC
N#define USART_FLAG_RXNE                      USART_ISR_RXNE
N#define USART_FLAG_IDLE                      USART_ISR_IDLE
N#define USART_FLAG_ORE                       USART_ISR_ORE
N#define USART_FLAG_NE                        USART_ISR_NE
N#define USART_FLAG_FE                        USART_ISR_FE
N#define USART_FLAG_PE                        USART_ISR_PE
N#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
N                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
N                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
N                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
N                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE) || \
N                             ((FLAG) == USART_FLAG_nCTSS) || ((FLAG) == USART_FLAG_RTO) || \
N                             ((FLAG) == USART_FLAG_EOB) || ((FLAG) == USART_FLAG_ABRE) || \
N                             ((FLAG) == USART_FLAG_ABRF) || ((FLAG) == USART_FLAG_BUSY) || \
N                             ((FLAG) == USART_FLAG_CM) || ((FLAG) == USART_FLAG_SBK) || \
N                             ((FLAG) == USART_FLAG_RWU) || ((FLAG) == USART_FLAG_WU) || \
N                             ((FLAG) == USART_FLAG_TEACK)|| ((FLAG) == USART_FLAG_REACK))
X#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) ||                              ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) ||                              ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) ||                              ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) ||                              ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE) ||                              ((FLAG) == USART_FLAG_nCTSS) || ((FLAG) == USART_FLAG_RTO) ||                              ((FLAG) == USART_FLAG_EOB) || ((FLAG) == USART_FLAG_ABRE) ||                              ((FLAG) == USART_FLAG_ABRF) || ((FLAG) == USART_FLAG_BUSY) ||                              ((FLAG) == USART_FLAG_CM) || ((FLAG) == USART_FLAG_SBK) ||                              ((FLAG) == USART_FLAG_RWU) || ((FLAG) == USART_FLAG_WU) ||                              ((FLAG) == USART_FLAG_TEACK)|| ((FLAG) == USART_FLAG_REACK))
N
N#define IS_USART_CLEAR_FLAG(FLAG) (((FLAG) == USART_FLAG_WU) || ((FLAG) == USART_FLAG_TC) || \
N                                   ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_ORE) || \
N                                   ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE) || \
N                                   ((FLAG) == USART_FLAG_LBD) || ((FLAG) == USART_FLAG_CTS) || \
N                                   ((FLAG) == USART_FLAG_RTO) || ((FLAG) == USART_FLAG_EOB) || \
N                                   ((FLAG) == USART_FLAG_CM) || ((FLAG) == USART_FLAG_PE))
X#define IS_USART_CLEAR_FLAG(FLAG) (((FLAG) == USART_FLAG_WU) || ((FLAG) == USART_FLAG_TC) ||                                    ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_ORE) ||                                    ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE) ||                                    ((FLAG) == USART_FLAG_LBD) || ((FLAG) == USART_FLAG_CTS) ||                                    ((FLAG) == USART_FLAG_RTO) || ((FLAG) == USART_FLAG_EOB) ||                                    ((FLAG) == USART_FLAG_CM) || ((FLAG) == USART_FLAG_PE))
N/**
N  * @}
N  */ 
N
N/** @defgroup USART_Interrupt_definition 
N  * @brief USART Interrupt definition
N  * USART_IT possible values
N  * Elements values convention: 0xZZZZYYXX
N  *   XX: Position of the corresponding Interrupt
N  *   YY: Register index
N  *   ZZZZ: Flag position
N  * @{
N  */
N
N#define USART_IT_WU                          ((uint32_t)0x00140316)
N#define USART_IT_CM                          ((uint32_t)0x0011010E)
N#define USART_IT_EOB                         ((uint32_t)0x000C011B)
N#define USART_IT_RTO                         ((uint32_t)0x000B011A)
N#define USART_IT_PE                          ((uint32_t)0x00000108)
N#define USART_IT_TXE                         ((uint32_t)0x00070107)
N#define USART_IT_TC                          ((uint32_t)0x00060106)
N#define USART_IT_RXNE                        ((uint32_t)0x00050105)
N#define USART_IT_IDLE                        ((uint32_t)0x00040104)
N#define USART_IT_LBD                         ((uint32_t)0x00080206)
N#define USART_IT_CTS                         ((uint32_t)0x0009030A) 
N#define USART_IT_ERR                         ((uint32_t)0x00000300)
N#define USART_IT_ORE                         ((uint32_t)0x00030300)
N#define USART_IT_NE                          ((uint32_t)0x00020300)
N#define USART_IT_FE                          ((uint32_t)0x00010300)
N
N#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR) || \
N                                ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) || \
N                                ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
X#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                                 ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                 ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                                 ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR) ||                                 ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) ||                                 ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
N
N#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                             ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                             ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                             ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
N                             ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE) || \
N                             ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) || \
N                             ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
X#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                              ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                              ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                              ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) ||                              ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE) ||                              ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) ||                              ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
N
N#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_PE) || \
N                               ((IT) == USART_IT_FE) || ((IT) == USART_IT_NE) || \
N                               ((IT) == USART_IT_ORE) || ((IT) == USART_IT_IDLE) || \
N                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS) || \
N                               ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) || \
N                               ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
X#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_PE) ||                                ((IT) == USART_IT_FE) || ((IT) == USART_IT_NE) ||                                ((IT) == USART_IT_ORE) || ((IT) == USART_IT_IDLE) ||                                ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS) ||                                ((IT) == USART_IT_RTO) || ((IT) == USART_IT_EOB) ||                                ((IT) == USART_IT_CM) || ((IT) == USART_IT_WU))
N/**
N  * @}
N  */
N
N/** @defgroup USART_Global_definition 
N  * @{
N  */
N
N#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x005B8D81))
N#define IS_USART_DE_ASSERTION_DEASSERTION_TIME(TIME) ((TIME) <= 0x1F)
N#define IS_USART_AUTO_RETRY_COUNTER(COUNTER) ((COUNTER) <= 0x7)
N#define IS_USART_TIMEOUT(TIMEOUT) ((TIMEOUT) <= 0x00FFFFFF)
N#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Initialization and Configuration functions *********************************/
Nvoid USART_DeInit(USART_TypeDef* USARTx);
Nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
Nvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct);
Nvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState NewState);
Nvoid USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
Nvoid USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState);
Nvoid USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut);
N
N/* STOP Mode functions ********************************************************/
Nvoid USART_STOPModeCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_StopModeWakeUpSourceConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUpSource);
N
N/* AutoBaudRate functions *****************************************************/
Nvoid USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate);
N
N/* Data transfers functions ***************************************************/
Nvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
Nuint16_t USART_ReceiveData(USART_TypeDef* USARTx);
N
N/* Multi-Processor Communication functions ************************************/
Nvoid USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
Nvoid USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp);
Nvoid USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength);
N/* LIN mode functions *********************************************************/
Nvoid USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint32_t USART_LINBreakDetectLength);
Nvoid USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* Half-duplex mode function **************************************************/
Nvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* Smartcard mode functions ***************************************************/
Nvoid USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);
Nvoid USART_SetAutoRetryCount(USART_TypeDef* USARTx, uint8_t USART_AutoCount);
Nvoid USART_SetBlockLength(USART_TypeDef* USARTx, uint8_t USART_BlockLength);
N
N/* IrDA mode functions ********************************************************/
Nvoid USART_IrDAConfig(USART_TypeDef* USARTx, uint32_t USART_IrDAMode);
Nvoid USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
N
N/* RS485 mode functions *******************************************************/
Nvoid USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity);
Nvoid USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime);
Nvoid USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime);
N
N/* DMA transfers management functions *****************************************/
Nvoid USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState);
Nvoid USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError);
N
N/* Interrupts and flags management functions **********************************/
Nvoid USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState);
Nvoid USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState);
Nvoid USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection);
NFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG);
Nvoid USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG);
NITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT);
Nvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_USART_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 55 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_wwdg.h"
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_wwdg.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_wwdg.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the WWDG 
N  *          firmware library.
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */ 
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_WWDG_H
N#define __STM32F37X_WWDG_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup WWDG
N  * @{
N  */ 
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup WWDG_Exported_Constants
N  * @{
N  */ 
N  
N/** @defgroup WWDG_Prescaler 
N  * @{
N  */ 
N  
N#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
N#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
N#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
N#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
N#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
N                                      ((PRESCALER) == WWDG_Prescaler_2) || \
N                                      ((PRESCALER) == WWDG_Prescaler_4) || \
N                                      ((PRESCALER) == WWDG_Prescaler_8))
X#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) ||                                       ((PRESCALER) == WWDG_Prescaler_2) ||                                       ((PRESCALER) == WWDG_Prescaler_4) ||                                       ((PRESCALER) == WWDG_Prescaler_8))
N#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
N#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/*  Function used to set the WWDG configuration to the default reset state ****/  
Nvoid WWDG_DeInit(void);
N
N/* Prescaler, Refresh window and Counter configuration functions **************/
Nvoid WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
Nvoid WWDG_SetWindowValue(uint8_t WindowValue);
Nvoid WWDG_EnableIT(void);
Nvoid WWDG_SetCounter(uint8_t Counter);
N
N/* WWDG activation functions **************************************************/
Nvoid WWDG_Enable(uint8_t Counter);
N
N/* Interrupts and flags management functions **********************************/
NFlagStatus WWDG_GetFlagStatus(void);
Nvoid WWDG_ClearFlag(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_WWDG_H */
N
N/**
N  * @}
N  */ 
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 56 "..\inc\stm32f37x_conf.h" 2
N#include "stm32f37x_misc.h"  /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */
L 1 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_misc.h" 1
N/**
N  ******************************************************************************
N  * @file    stm32f37x_misc.h
N  * @author  MCD Application Team
N  * @version V1.0.0
N  * @date    20-September-2012
N  * @brief   This file contains all the functions prototypes for the miscellaneous
N  *          firmware library functions (add-on to CMSIS functions).
N  ******************************************************************************
N  * @attention
N  *
N  * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
N  *
N  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
N  * You may not use this file except in compliance with the License.
N  * You may obtain a copy of the License at:
N  *
N  *        http://www.st.com/software_license_agreement_liberty_v2
N  *
N  * Unless required by applicable law or agreed to in writing, software 
N  * distributed under the License is distributed on an "AS IS" BASIS, 
N  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N  * See the License for the specific language governing permissions and
N  * limitations under the License.
N  *
N  ******************************************************************************
N  */
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F37X_MISC_H
N#define __STM32F37X_MISC_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f37x.h"
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup MISC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
N/** 
N  * @brief  NVIC Init Structure definition  
N  */
N
Ntypedef struct
N{
N  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.
N                                                   This parameter can be a value of @ref IRQn_Type 
N                                                   (For the complete STM32 Devices IRQ Channels list, please
N                                                    refer to stm32f37x.h file) */
N
N  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel
N                                                   specified in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table
N                                                   A lower priority value indicates a higher priority */
N
N  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified
N                                                   in NVIC_IRQChannel. This parameter can be a value
N                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table
N                                                   A lower priority value indicates a higher priority */
N
N  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
N                                                   will be enabled or disabled. 
N                                                   This parameter can be set either to ENABLE or DISABLE */   
N} NVIC_InitTypeDef;
N
N/**  
N  *
N@verbatim
N The table below gives the allowed values of the pre-emption priority and subpriority according
N to the Priority Grouping configuration performed by NVIC_PriorityGroupConfig function
N  ============================================================================================================================
N    NVIC_PriorityGroup   | NVIC_IRQChannelPreemptionPriority | NVIC_IRQChannelSubPriority  | Description
N  ============================================================================================================================
N   NVIC_PriorityGroup_0  |                0                  |            0-15             |   0 bits for pre-emption priority
N                         |                                   |                             |   4 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------
N   NVIC_PriorityGroup_1  |                0-1                |            0-7              |   1 bits for pre-emption priority
N                         |                                   |                             |   3 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------
N   NVIC_PriorityGroup_2  |                0-3                |            0-3              |   2 bits for pre-emption priority
N                         |                                   |                             |   2 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------
N   NVIC_PriorityGroup_3  |                0-7                |            0-1              |   3 bits for pre-emption priority
N                         |                                   |                             |   1 bits for subpriority
N  ----------------------------------------------------------------------------------------------------------------------------
N   NVIC_PriorityGroup_4  |                0-15               |            0                |   4 bits for pre-emption priority
N                         |                                   |                             |   0 bits for subpriority
N  ============================================================================================================================
N@endverbatim
N*/
N 
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup MISC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup MISC_Vector_Table_Base 
N  * @{
N  */
N
N#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)
N#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)
N#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
N                                  ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) ||                                   ((VECTTAB) == NVIC_VectTab_FLASH))
N/**
N  * @}
N  */
N
N/** @defgroup MISC_System_Low_Power 
N  * @{
N  */
N
N#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
N#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
N#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N/**
N  * @}
N  */
N
N/** @defgroup MISC_Preemption_Priority_Group 
N  * @{
N  */
N
N#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!< 0 bits for pre-emption priority
N                                                            4 bits for subpriority */
N#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority
N                                                            3 bits for subpriority */
N#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!< 2 bits for pre-emption priority
N                                                            2 bits for subpriority */
N#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!< 3 bits for pre-emption priority
N                                                            1 bits for subpriority */
N#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!< 4 bits for pre-emption priority
N                                                            0 bits for subpriority */
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
N                                       ((GROUP) == NVIC_PriorityGroup_1) || \
N                                       ((GROUP) == NVIC_PriorityGroup_2) || \
N                                       ((GROUP) == NVIC_PriorityGroup_3) || \
N                                       ((GROUP) == NVIC_PriorityGroup_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) ||                                        ((GROUP) == NVIC_PriorityGroup_1) ||                                        ((GROUP) == NVIC_PriorityGroup_2) ||                                        ((GROUP) == NVIC_PriorityGroup_3) ||                                        ((GROUP) == NVIC_PriorityGroup_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N
N#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x000FFFFF)
N
N/**
N  * @}
N  */
N
N/** @defgroup MISC_SysTick_clock_source 
N  * @{
N  */
N
N#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
N#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
N                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) ||                                        ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
Nvoid NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
Nvoid NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
Nvoid SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_MISC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 57 "..\inc\stm32f37x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to expanse the "assert_param" macro in the 
N   Standard Peripheral Library drivers code */
N/* #define USE_FULL_ASSERT    1 */
N
N/* Exported macro ------------------------------------------------------------*/
N#ifdef  USE_FULL_ASSERT
S
S/**
S  * @brief  The assert_param macro is used for function's parameters check.
S  * @param  expr: If expr is false, it calls assert_failed function which reports 
S  *         the name of the source file and the source line number of the call 
S  *         that failed. If expr is true, it returns no value.
S  * @retval None
S  */
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(uint8_t* file, uint32_t line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* USE_FULL_ASSERT */
N
N#endif /* __STM32F37X_CONF_H */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 5400 "..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include\stm32f37x.h" 2
N#endif /* USE_STDPERIPH_DRIVER */
N
N/** @addtogroup Exported_macro
N  * @{
N  */
N
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N
N#define READ_REG(REG)         ((REG))
N
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N
N/**
N  * @}
N  */
N
N#ifdef __cplusplus
S}
N#endif /* __cplusplus */
N
N#endif /* __STM32F37x_H */
N
N/**
N  * @}
N  */
N
N  /**
N  * @}
N  */
N
N/******************* (C) COPYRIGHT 2012 STMicroelectronics *****END OF FILE****/
L 39 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc\stm32f37x_rcc.h" 2
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @addtogroup RCC
N  * @{
N  */
N
N/* Exported types ------------------------------------------------------------*/
N
Ntypedef struct
N{
N  uint32_t SYSCLK_Frequency;
N  uint32_t HCLK_Frequency;
N  uint32_t PCLK1_Frequency;
N  uint32_t PCLK2_Frequency;
N  uint32_t ADCCLK_Frequency;
N  uint32_t SDADCCLK_Frequency;
N  uint32_t CECCLK_Frequency;
N  uint32_t I2C1CLK_Frequency;
N  uint32_t I2C2CLK_Frequency;
N  uint32_t USART1CLK_Frequency;
N  uint32_t USART2CLK_Frequency;
N  uint32_t USART3CLK_Frequency;
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N/** @defgroup RCC_Exported_Constants
N  * @{
N  */
N
N/** @defgroup RCC_HSE_configuration 
N  * @{
N  */
N
N#define RCC_HSE_OFF                      ((uint8_t)0x00)
N#define RCC_HSE_ON                       ((uint8_t)0x01)
N#define RCC_HSE_Bypass                   ((uint8_t)0x05)
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/**
N  * @}
N  */ 
N 
N/** @defgroup RCC_PLL_Clock_Source 
N  * @{
N  */
N
N#define RCC_PLLSource_HSI_Div2           RCC_CFGR_PLLSRC_HSI_Div2
N#define RCC_PLLSource_PREDIV1            RCC_CFGR_PLLSRC_PREDIV1
N 
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_PREDIV1))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_PREDIV1))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_PLL_Multiplication_Factor 
N  * @{
N  */
N
N#define RCC_PLLMul_2                    RCC_CFGR_PLLMULL2
N#define RCC_PLLMul_3                    RCC_CFGR_PLLMULL3
N#define RCC_PLLMul_4                    RCC_CFGR_PLLMULL4
N#define RCC_PLLMul_5                    RCC_CFGR_PLLMULL5
N#define RCC_PLLMul_6                    RCC_CFGR_PLLMULL6
N#define RCC_PLLMul_7                    RCC_CFGR_PLLMULL7
N#define RCC_PLLMul_8                    RCC_CFGR_PLLMULL8
N#define RCC_PLLMul_9                    RCC_CFGR_PLLMULL9
N#define RCC_PLLMul_10                   RCC_CFGR_PLLMULL10
N#define RCC_PLLMul_11                   RCC_CFGR_PLLMULL11
N#define RCC_PLLMul_12                   RCC_CFGR_PLLMULL12
N#define RCC_PLLMul_13                   RCC_CFGR_PLLMULL13
N#define RCC_PLLMul_14                   RCC_CFGR_PLLMULL14
N#define RCC_PLLMul_15                   RCC_CFGR_PLLMULL15
N#define RCC_PLLMul_16                   RCC_CFGR_PLLMULL16
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_PREDIV1_division_factor
N  * @{
N  */
N#define  RCC_PREDIV1_Div1               RCC_CFGR2_PREDIV1_DIV1
N#define  RCC_PREDIV1_Div2               RCC_CFGR2_PREDIV1_DIV2
N#define  RCC_PREDIV1_Div3               RCC_CFGR2_PREDIV1_DIV3
N#define  RCC_PREDIV1_Div4               RCC_CFGR2_PREDIV1_DIV4
N#define  RCC_PREDIV1_Div5               RCC_CFGR2_PREDIV1_DIV5
N#define  RCC_PREDIV1_Div6               RCC_CFGR2_PREDIV1_DIV6
N#define  RCC_PREDIV1_Div7               RCC_CFGR2_PREDIV1_DIV7
N#define  RCC_PREDIV1_Div8               RCC_CFGR2_PREDIV1_DIV8
N#define  RCC_PREDIV1_Div9               RCC_CFGR2_PREDIV1_DIV9
N#define  RCC_PREDIV1_Div10              RCC_CFGR2_PREDIV1_DIV10
N#define  RCC_PREDIV1_Div11              RCC_CFGR2_PREDIV1_DIV11
N#define  RCC_PREDIV1_Div12              RCC_CFGR2_PREDIV1_DIV12
N#define  RCC_PREDIV1_Div13              RCC_CFGR2_PREDIV1_DIV13
N#define  RCC_PREDIV1_Div14              RCC_CFGR2_PREDIV1_DIV14
N#define  RCC_PREDIV1_Div15              RCC_CFGR2_PREDIV1_DIV15
N#define  RCC_PREDIV1_Div16              RCC_CFGR2_PREDIV1_DIV16
N
N#define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \
N                                 ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
X#define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) ||                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) ||                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) ||                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) ||                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) ||                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) ||                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) ||                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))
N/**
N  * @}
N  */
N 
N/** @defgroup RCC_System_Clock_Source 
N  * @{
N  */
N
N#define RCC_SYSCLKSource_HSI             RCC_CFGR_SW_HSI
N#define RCC_SYSCLKSource_HSE             RCC_CFGR_SW_HSE
N#define RCC_SYSCLKSource_PLLCLK          RCC_CFGR_SW_PLL
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_AHB_Clock_Source
N  * @{
N  */
N
N#define RCC_SYSCLK_Div1                  RCC_CFGR_HPRE_DIV1
N#define RCC_SYSCLK_Div2                  RCC_CFGR_HPRE_DIV2
N#define RCC_SYSCLK_Div4                  RCC_CFGR_HPRE_DIV4
N#define RCC_SYSCLK_Div8                  RCC_CFGR_HPRE_DIV8
N#define RCC_SYSCLK_Div16                 RCC_CFGR_HPRE_DIV16
N#define RCC_SYSCLK_Div64                 RCC_CFGR_HPRE_DIV64
N#define RCC_SYSCLK_Div128                RCC_CFGR_HPRE_DIV128
N#define RCC_SYSCLK_Div256                RCC_CFGR_HPRE_DIV256
N#define RCC_SYSCLK_Div512                RCC_CFGR_HPRE_DIV512
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_APB1_APB2_Clock_Source
N  * @{
N  */
N
N#define RCC_HCLK_Div1                    RCC_CFGR_PPRE1_DIV1
N#define RCC_HCLK_Div2                    RCC_CFGR_PPRE1_DIV2
N#define RCC_HCLK_Div4                    RCC_CFGR_PPRE1_DIV4
N#define RCC_HCLK_Div8                    RCC_CFGR_PPRE1_DIV8
N#define RCC_HCLK_Div16                   RCC_CFGR_PPRE1_DIV16
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_ADC_clock_source 
N  * @{
N  */
N
N#define RCC_PCLK2_Div2                   ((uint32_t)0x00000000)
N#define RCC_PCLK2_Div4                   ((uint32_t)0x00004000)
N#define RCC_PCLK2_Div6                   ((uint32_t)0x00008000)
N#define RCC_PCLK2_Div8                   ((uint32_t)0x0000C000)
N
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
N                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) ||                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_SDADC_clock_source 
N  * @{
N  */
N
N#define RCC_SDADCCLK_SYSCLK_Div2                   ((uint32_t)0x80000000)
N#define RCC_SDADCCLK_SYSCLK_Div4                   ((uint32_t)0x88000000)
N#define RCC_SDADCCLK_SYSCLK_Div6                   ((uint32_t)0x90000000)
N#define RCC_SDADCCLK_SYSCLK_Div8                   ((uint32_t)0x98000000)
N#define RCC_SDADCCLK_SYSCLK_Div10                  ((uint32_t)0xA0000000)
N#define RCC_SDADCCLK_SYSCLK_Div12                  ((uint32_t)0xA8000000)
N#define RCC_SDADCCLK_SYSCLK_Div14                  ((uint32_t)0xB0000000)
N#define RCC_SDADCCLK_SYSCLK_Div16                  ((uint32_t)0xB8000000)
N#define RCC_SDADCCLK_SYSCLK_Div20                  ((uint32_t)0xC0000000)
N#define RCC_SDADCCLK_SYSCLK_Div24                  ((uint32_t)0xC8000000)
N#define RCC_SDADCCLK_SYSCLK_Div28                  ((uint32_t)0xD0000000)
N#define RCC_SDADCCLK_SYSCLK_Div32                  ((uint32_t)0xD8000000)
N#define RCC_SDADCCLK_SYSCLK_Div36                  ((uint32_t)0xE0000000)
N#define RCC_SDADCCLK_SYSCLK_Div40                  ((uint32_t)0xE8000000)
N#define RCC_SDADCCLK_SYSCLK_Div44                  ((uint32_t)0xF0000000)
N#define RCC_SDADCCLK_SYSCLK_Div48                  ((uint32_t)0xF8000000)
N
N#define IS_RCC_SDADCCLK(SDADCCLK) (((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div2) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div4) || \
N                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div6) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div8) || \
N                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div10) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div12) || \
N                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div14) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div16) || \
N                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div20) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div24) || \
N                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div28) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div32) || \
N                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div36) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div40) || \
N                                   ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div44) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div48))
X#define IS_RCC_SDADCCLK(SDADCCLK) (((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div2) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div4) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div6) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div8) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div10) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div12) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div14) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div16) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div20) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div24) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div28) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div32) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div36) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div40) ||                                    ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div44) || ((SDADCCLK) == RCC_SDADCCLK_SYSCLK_Div48))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_CEC_clock_source 
N  * @{
N  */
N
N#define RCC_CECCLK_HSI_Div244            ((uint32_t)0x00000000)
N#define RCC_CECCLK_LSE                   RCC_CFGR3_CECSW
N
N#define IS_RCC_CECCLK(CECCLK) (((CECCLK) == RCC_CECCLK_HSI_Div244) || ((CECCLK) == RCC_CECCLK_LSE))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_I2C_clock_source 
N  * @{
N  */
N
N#define RCC_I2C1CLK_HSI                   ((uint32_t)0x00000000)
N#define RCC_I2C1CLK_SYSCLK                RCC_CFGR3_I2C1SW
N
N#define RCC_I2C2CLK_HSI                   ((uint32_t)0x10000000)
N#define RCC_I2C2CLK_SYSCLK                ((uint32_t)0x10000020)
N
N#define IS_RCC_I2CCLK(I2CCLK) (((I2CCLK) == RCC_I2C1CLK_HSI) || ((I2CCLK) == RCC_I2C1CLK_SYSCLK) || \
N                               ((I2CCLK) == RCC_I2C2CLK_HSI) || ((I2CCLK) == RCC_I2C2CLK_SYSCLK))
X#define IS_RCC_I2CCLK(I2CCLK) (((I2CCLK) == RCC_I2C1CLK_HSI) || ((I2CCLK) == RCC_I2C1CLK_SYSCLK) ||                                ((I2CCLK) == RCC_I2C2CLK_HSI) || ((I2CCLK) == RCC_I2C2CLK_SYSCLK))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_USART_clock_source 
N  * @{
N  */
N
N#define RCC_USART1CLK_PCLK                  ((uint32_t)0x10000000)
N#define RCC_USART1CLK_SYSCLK                ((uint32_t)0x10000001)
N#define RCC_USART1CLK_LSE                   ((uint32_t)0x10000002)
N#define RCC_USART1CLK_HSI                   ((uint32_t)0x10000003)
N
N#define RCC_USART2CLK_PCLK                  ((uint32_t)0x20000000)
N#define RCC_USART2CLK_SYSCLK                ((uint32_t)0x20010000)
N#define RCC_USART2CLK_LSE                   ((uint32_t)0x20020000)
N#define RCC_USART2CLK_HSI                   ((uint32_t)0x20030000)
N
N#define RCC_USART3CLK_PCLK                  ((uint32_t)0x30000000)
N#define RCC_USART3CLK_SYSCLK                ((uint32_t)0x30040000)
N#define RCC_USART3CLK_LSE                   ((uint32_t)0x30080000)
N#define RCC_USART3CLK_HSI                   ((uint32_t)0x300C0000)
N
N#define IS_RCC_USARTCLK(USARTCLK) (((USARTCLK) == RCC_USART1CLK_PCLK) || ((USARTCLK) == RCC_USART1CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART1CLK_LSE) || ((USARTCLK) == RCC_USART1CLK_HSI) ||\
N                                   ((USARTCLK) == RCC_USART2CLK_PCLK) || ((USARTCLK) == RCC_USART2CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART2CLK_LSE) || ((USARTCLK) == RCC_USART2CLK_HSI) || \
N                                   ((USARTCLK) == RCC_USART3CLK_PCLK) || ((USARTCLK) == RCC_USART3CLK_SYSCLK) || \
N                                   ((USARTCLK) == RCC_USART3CLK_LSE) || ((USARTCLK) == RCC_USART3CLK_HSI))
X#define IS_RCC_USARTCLK(USARTCLK) (((USARTCLK) == RCC_USART1CLK_PCLK) || ((USARTCLK) == RCC_USART1CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART1CLK_LSE) || ((USARTCLK) == RCC_USART1CLK_HSI) ||                                   ((USARTCLK) == RCC_USART2CLK_PCLK) || ((USARTCLK) == RCC_USART2CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART2CLK_LSE) || ((USARTCLK) == RCC_USART2CLK_HSI) ||                                    ((USARTCLK) == RCC_USART3CLK_PCLK) || ((USARTCLK) == RCC_USART3CLK_SYSCLK) ||                                    ((USARTCLK) == RCC_USART3CLK_LSE) || ((USARTCLK) == RCC_USART3CLK_HSI))
N
N/**
N  * @}
N  */
N       
N/** @defgroup RCC_Interrupt_Source 
N  * @{
N  */
N
N#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
N#define RCC_IT_LSERDY                    ((uint8_t)0x02)
N#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
N#define RCC_IT_HSERDY                    ((uint8_t)0x08)
N#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
N#define RCC_IT_CSS                       ((uint8_t)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (uint8_t)0xC0) == 0x00) && ((IT) != 0x00))
N
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
N                           
N
N#define IS_RCC_CLEAR_IT(IT) ((((IT) & (uint8_t)0x40) == 0x00) && ((IT) != 0x00))
N
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_LSE_Configuration 
N  * @{
N  */
N
N#define RCC_LSE_OFF                      ((uint32_t)0x00000000)
N#define RCC_LSE_ON                       RCC_BDCR_LSEON
N#define RCC_LSE_Bypass                   ((uint32_t)(RCC_BDCR_LSEON | RCC_BDCR_LSEBYP))
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_RTC_Clock_Source
N  * @{
N  */
N
N#define RCC_RTCCLKSource_LSE             RCC_BDCR_RTCSEL_LSE
N#define RCC_RTCCLKSource_LSI             RCC_BDCR_RTCSEL_LSI
N#define RCC_RTCCLKSource_HSE_Div32       RCC_BDCR_RTCSEL_HSE
N
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div32))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div32))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_LSE_Drive_Configuration 
N  * @{
N  */
N
N#define RCC_LSEDrive_Low                 ((uint32_t)0x00000000)
N#define RCC_LSEDrive_MediumLow           RCC_BDCR_LSEDRV_0
N#define RCC_LSEDrive_MediumHigh          RCC_BDCR_LSEDRV_1
N#define RCC_LSEDrive_High                RCC_BDCR_LSEDRV
N#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDrive_Low) || ((DRIVE) == RCC_LSEDrive_MediumLow) || \
N                                 ((DRIVE) == RCC_LSEDrive_MediumHigh) || ((DRIVE) == RCC_LSEDrive_High))
X#define IS_RCC_LSE_DRIVE(DRIVE) (((DRIVE) == RCC_LSEDrive_Low) || ((DRIVE) == RCC_LSEDrive_MediumLow) ||                                  ((DRIVE) == RCC_LSEDrive_MediumHigh) || ((DRIVE) == RCC_LSEDrive_High))
N/**
N  * @}
N  */
N  
N/** @defgroup RCC_AHB_Peripherals 
N  * @{
N  */
N
N#define RCC_AHBPeriph_GPIOA               RCC_AHBENR_GPIOAEN
N#define RCC_AHBPeriph_GPIOB               RCC_AHBENR_GPIOBEN
N#define RCC_AHBPeriph_GPIOC               RCC_AHBENR_GPIOCEN
N#define RCC_AHBPeriph_GPIOD               RCC_AHBENR_GPIODEN
N#define RCC_AHBPeriph_GPIOE               RCC_AHBENR_GPIOEEN
N#define RCC_AHBPeriph_GPIOF               RCC_AHBENR_GPIOFEN
N#define RCC_AHBPeriph_TS                  RCC_AHBENR_TSEN
N#define RCC_AHBPeriph_CRC                 RCC_AHBENR_CRCEN
N#define RCC_AHBPeriph_FLITF               RCC_AHBENR_FLITFEN
N#define RCC_AHBPeriph_SRAM                RCC_AHBENR_SRAMEN
N#define RCC_AHBPeriph_DMA2                RCC_AHBENR_DMA2EN
N#define RCC_AHBPeriph_DMA1                RCC_AHBENR_DMA1EN
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFE81FFA8) == 0x00) && ((PERIPH) != 0x00))
N#define IS_RCC_AHB_RST_PERIPH(PERIPH) ((((PERIPH) & 0xFE81FFFF) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_APB2_Peripherals 
N  * @{
N  */
N
N#define RCC_APB2Periph_SYSCFG            RCC_APB2ENR_SYSCFGEN
N#define RCC_APB2Periph_ADC1              RCC_APB2ENR_ADC1EN
N#define RCC_APB2Periph_SPI1              RCC_APB2ENR_SPI1EN
N#define RCC_APB2Periph_USART1            RCC_APB2ENR_USART1EN
N#define RCC_APB2Periph_TIM15             RCC_APB2ENR_TIM15EN
N#define RCC_APB2Periph_TIM16             RCC_APB2ENR_TIM16EN
N#define RCC_APB2Periph_TIM17             RCC_APB2ENR_TIM17EN
N#define RCC_APB2Periph_TIM19             RCC_APB2ENR_TIM19EN
N#define RCC_APB2Periph_SDADC1            RCC_APB2ENR_SDADC1EN
N#define RCC_APB2Periph_SDADC2            RCC_APB2ENR_SDADC2EN
N#define RCC_APB2Periph_SDADC3            RCC_APB2ENR_SDADC3EN
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xF8F08DFE) == 0x00) && ((PERIPH) != 0x00))
N
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_APB1_Peripherals 
N  * @{
N  */
N#define RCC_APB1Periph_TIM2              RCC_APB1ENR_TIM2EN
N#define RCC_APB1Periph_TIM3              RCC_APB1ENR_TIM3EN
N#define RCC_APB1Periph_TIM4              RCC_APB1ENR_TIM4EN
N#define RCC_APB1Periph_TIM5              RCC_APB1ENR_TIM5EN
N#define RCC_APB1Periph_TIM6              RCC_APB1ENR_TIM6EN
N#define RCC_APB1Periph_TIM7              RCC_APB1ENR_TIM7EN
N#define RCC_APB1Periph_TIM12             RCC_APB1ENR_TIM12EN
N#define RCC_APB1Periph_TIM13             RCC_APB1ENR_TIM13EN
N#define RCC_APB1Periph_TIM14             RCC_APB1ENR_TIM14EN
N#define RCC_APB1Periph_TIM18             RCC_APB1ENR_TIM18EN
N#define RCC_APB1Periph_WWDG              RCC_APB1ENR_WWDGEN
N#define RCC_APB1Periph_SPI2              RCC_APB1ENR_SPI2EN
N#define RCC_APB1Periph_SPI3              RCC_APB1ENR_SPI3EN
N#define RCC_APB1Periph_USART2            RCC_APB1ENR_USART2EN
N#define RCC_APB1Periph_USART3            RCC_APB1ENR_USART3EN
N#define RCC_APB1Periph_I2C1              RCC_APB1ENR_I2C1EN
N#define RCC_APB1Periph_I2C2              RCC_APB1ENR_I2C2EN
N#define RCC_APB1Periph_USB               RCC_APB1ENR_USBEN
N#define RCC_APB1Periph_CAN1              RCC_APB1ENR_CAN1EN
N#define RCC_APB1Periph_DAC2              RCC_APB1ENR_DAC2EN
N#define RCC_APB1Periph_PWR               RCC_APB1ENR_PWREN
N#define RCC_APB1Periph_DAC1              RCC_APB1ENR_DAC1EN
N#define RCC_APB1Periph_CEC               RCC_APB1ENR_CECEN
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x89193400) == 0x00) && ((PERIPH) != 0x00))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_MCO_Clock_Source
N  * @{
N  */
N
N#define RCC_MCOSource_NoClock            ((uint8_t)0x00)
N#define RCC_MCOSource_LSI                ((uint8_t)0x02)
N#define RCC_MCOSource_LSE                ((uint8_t)0x03)
N#define RCC_MCOSource_SYSCLK             ((uint8_t)0x04)
N#define RCC_MCOSource_HSI                ((uint8_t)0x05)
N#define RCC_MCOSource_HSE                ((uint8_t)0x06)
N#define RCC_MCOSource_PLLCLK_Div2        ((uint8_t)0x07)
N
N#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) ||((SOURCE) == RCC_MCOSource_SYSCLK) ||\
N                                    ((SOURCE) == RCC_MCOSource_HSI)  || ((SOURCE) == RCC_MCOSource_HSE) || \
N                                    ((SOURCE) == RCC_MCOSource_LSI)  || ((SOURCE) == RCC_MCOSource_LSE) || \
N                                    ((SOURCE) == RCC_MCOSource_PLLCLK_Div2))
X#define IS_RCC_MCO_SOURCE(SOURCE) (((SOURCE) == RCC_MCOSource_NoClock) ||((SOURCE) == RCC_MCOSource_SYSCLK) ||                                    ((SOURCE) == RCC_MCOSource_HSI)  || ((SOURCE) == RCC_MCOSource_HSE) ||                                     ((SOURCE) == RCC_MCOSource_LSI)  || ((SOURCE) == RCC_MCOSource_LSE) ||                                     ((SOURCE) == RCC_MCOSource_PLLCLK_Div2))
N/**
N  * @}
N  */ 
N
N/** @defgroup RCC_USB_Device_clock_source 
N  * @{
N  */
N
N #define RCC_USBCLKSource_PLLCLK_1Div5   ((uint8_t)0x00)
N #define RCC_USBCLKSource_PLLCLK_Div1    ((uint8_t)0x01)
N
N #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
N                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
X #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) ||                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Flag 
N  * @{
N  */
N#define RCC_FLAG_HSIRDY                  ((uint8_t)0x01)
N#define RCC_FLAG_HSERDY                  ((uint8_t)0x11)
N#define RCC_FLAG_PLLRDY                  ((uint8_t)0x19)
N#define RCC_FLAG_LSERDY                  ((uint8_t)0x21)
N#define RCC_FLAG_LSIRDY                  ((uint8_t)0x41)
N#define RCC_FLAG_V18PWRRSTF              ((uint8_t)0x57)
N#define RCC_FLAG_OBLRST                  ((uint8_t)0x59)
N#define RCC_FLAG_PINRST                  ((uint8_t)0x5A)
N#define RCC_FLAG_PORRST                  ((uint8_t)0x5B)
N#define RCC_FLAG_SFTRST                  ((uint8_t)0x5C)
N#define RCC_FLAG_IWDGRST                 ((uint8_t)0x5D)
N#define RCC_FLAG_WWDGRST                 ((uint8_t)0x5E)
N#define RCC_FLAG_LPWRRST                 ((uint8_t)0x5F)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
N                           ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
N                           ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_OBLRST) || \
N                           ((FLAG) == RCC_FLAG_PINRST) || ((FLAG) == RCC_FLAG_PORRST) || \
N                           ((FLAG) == RCC_FLAG_SFTRST) || ((FLAG) == RCC_FLAG_IWDGRST)|| \
N                           ((FLAG) == RCC_FLAG_WWDGRST)|| ((FLAG) == RCC_FLAG_LPWRRST)|| \
N                           ((FLAG) == RCC_FLAG_V18PWRRSTF))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_OBLRST) ||                            ((FLAG) == RCC_FLAG_PINRST) || ((FLAG) == RCC_FLAG_PORRST) ||                            ((FLAG) == RCC_FLAG_SFTRST) || ((FLAG) == RCC_FLAG_IWDGRST)||                            ((FLAG) == RCC_FLAG_WWDGRST)|| ((FLAG) == RCC_FLAG_LPWRRST)||                            ((FLAG) == RCC_FLAG_V18PWRRSTF))
N
N#define IS_RCC_HSI_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N/* Function used to set the RCC clock configuration to the default reset state */
Nvoid RCC_DeInit(void);
N
N/* Internal/external clocks, PLL, CSS and MCO configuration functions *********/
Nvoid RCC_HSEConfig(uint8_t RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_LSEConfig(uint32_t RCC_LSE);
Nvoid RCC_LSEDriveConfig(uint32_t RCC_LSEDrive);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_MCOConfig(uint8_t RCC_MCOSource);
N
N/* System, AHB and APB busses clocks configuration functions ******************/
Nvoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
Nuint8_t RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(uint32_t RCC_SYSCLK);
Nvoid RCC_PCLK1Config(uint32_t RCC_HCLK);
Nvoid RCC_PCLK2Config(uint32_t RCC_HCLK);
Nvoid RCC_ADCCLKConfig(uint32_t RCC_PCLK2);
Nvoid RCC_SDADCCLKConfig(uint32_t RCC_SDADCCLK);
Nvoid RCC_CECCLKConfig(uint32_t RCC_CECCLK);
Nvoid RCC_I2CCLKConfig(uint32_t RCC_I2CCLK);
Nvoid RCC_USARTCLKConfig(uint32_t RCC_USARTCLK);
Nvoid RCC_USBCLKConfig(uint32_t RCC_USBCLKSource);
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
N
N/* Peripheral clocks configuration functions **********************************/
Nvoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
N
Nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
Nvoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
N
N/* Interrupts and flags management functions **********************************/
Nvoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
NFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(uint8_t RCC_IT);
Nvoid RCC_ClearITPendingBit(uint8_t RCC_IT);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __STM32F37X_RCC_H */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */ 
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
L 59 "..\..\..\Libraries\STM32F37x_StdPeriph_Driver\src\stm32f37x_rcc.c" 2
N
N/** @addtogroup STM32F37x_StdPeriph_Driver
N  * @{
N  */
N
N/** @defgroup RCC 
N  * @brief RCC driver modules
N  * @{
N  */ 
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N/* ------------ RCC registers bit address in the alias region ----------- */
N#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)
N
N/* --- CR Register ---*/
N
N/* Alias word address of HSION bit */
N#define CR_OFFSET                 (RCC_OFFSET + 0x00)
N#define HSION_BitNumber           0x00
N#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))
N
N/* Alias word address of PLLON bit */
N#define PLLON_BitNumber           0x18
N#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))
N
N/* Alias word address of CSSON bit */
N#define CSSON_BitNumber           0x13
N#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))
N
N/* --- CFGR Register ---*/
N/* Alias word address of USBPRE bit */
N#define CFGR_OFFSET               (RCC_OFFSET + 0x04)
N#define USBPRE_BitNumber          0x16
N#define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))
N
N/* --- BDCR Register ---*/
N
N/* Alias word address of RTCEN bit */
N#define BDCR_OFFSET               (RCC_OFFSET + 0x20)
N#define RTCEN_BitNumber           0x0F
N#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))
N
N/* Alias word address of BDRST bit */
N#define BDRST_BitNumber           0x10
N#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))
N
N/* --- CSR Register ---*/
N
N/* Alias word address of LSION bit */
N#define CSR_OFFSET                (RCC_OFFSET + 0x24)
N#define LSION_BitNumber           0x00
N#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))
N
N/* ---------------------- RCC registers bit mask ------------------------ */
N/* RCC Flag Mask */
N#define FLAG_MASK                 ((uint8_t)0x1F)
N
N/* CFGR register byte 3 (Bits[31:23]) base address */
N#define CFGR_BYTE3_ADDRESS        ((uint32_t)0x40021007)
N
N/* CIR register byte 2 (Bits[15:8]) base address */
N#define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)
N
N/* CIR register byte 3 (Bits[23:16]) base address */
N#define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)
N
N/* CR register byte 2 (Bits[23:16]) base address */
N#define CR_BYTE2_ADDRESS          ((uint32_t)0x40021002)
N
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
Nstatic __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
Xstatic volatile const uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
Nstatic __I uint8_t ADCPrescTable[4] = {2, 4, 6, 8};
Xstatic volatile const uint8_t ADCPrescTable[4] = {2, 4, 6, 8};
Nstatic __I uint8_t SDADCPrescTable[16] = {2, 4, 6, 8, 10, 12, 14, 16, 20, 24, 28, 32, 36, 40, 44, 48};
Xstatic volatile const uint8_t SDADCPrescTable[16] = {2, 4, 6, 8, 10, 12, 14, 16, 20, 24, 28, 32, 36, 40, 44, 48};
N
N/* Private function prototypes -----------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N
N/** @defgroup RCC_Private_Functions
N  * @{
N  */
N
N/** @defgroup RCC_Group1 Internal and external clocks, PLL, CSS and MCO configuration functions
N *  @brief   Internal and external clocks, PLL, CSS and MCO configuration functions 
N *
N@verbatim
N ===============================================================================
N ##### Internal-external clocks, PLL, CSS and MCO configuration functions #####
N ===============================================================================
N    [..] This section provides functions allowing to configure the internal/external clocks,
N         PLL, CSS and MCO.
N         (#) HSI (high-speed internal), 8 MHz factory-trimmed RC used directly 
N             or through the PLL as System clock source.
N             The HSI clock can be used also to clock the USART, I2C and CEC peripherals.
N         (#) LSI (low-speed internal), 40 KHz low consumption RC used as IWDG and/or RTC
N             clock source.
N         (#) HSE (high-speed external), 4 to 72 MHz crystal oscillator used directly or
N             through the PLL as System clock source. Can be used also as RTC clock source.
N         (#) LSE (low-speed external), 32 KHz oscillator used as RTC clock source.
N             LSE can be used also to clock the USART and CEC peripherals.
N         (#) PLL (clocked by HSI or HSE), for System clock.
N         (#) CSS (Clock security system), once enabled and if a HSE clock failure occurs 
N             (HSE used directly or through PLL as System clock source), the System clock
N             is automatically switched to HSI and an interrupt is generated if enabled. 
N             The interrupt is linked to the Cortex-M4 NMI (Non-Maskable Interrupt) 
N             exception vector.   
N         (#) MCO (microcontroller clock output), used to output SYSCLK, HSI, HSE, LSI, LSE,
N             PLL (divided by 2) clock on PA8 pin.
N
N@endverbatim
N  * @{
N  */
N
N/**
N  * @brief  Resets the RCC clock configuration to the default reset state.
N  * @note   The default reset state of the clock configuration is given below:
N  * @note      HSI ON and used as system clock source 
N  * @note      HSE and PLL OFF
N  * @note      AHB, APB1 and APB2 prescalers set to 1.
N  * @note      CSS and MCO OFF
N  * @note      All interrupts disabled
N  * @note   However, this function doesn't modify the configuration of the
N  * @note      Peripheral clocks
N  * @note      LSI, LSE and RTC clocks
N  * @param  None
N  * @retval None
N  */
Nvoid RCC_DeInit(void)
N{
N  /* Set HSION bit */
N  RCC->CR |= (uint32_t)0x00000001;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CR |= (uint32_t)0x00000001;
N
N  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, SDADCPRE and MCOSEL[2:0] bits */
N  RCC->CFGR &= (uint32_t)0x00FF0000;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR &= (uint32_t)0x00FF0000;
N  
N  /* Reset HSEON, CSSON and PLLON bits */
N  RCC->CR &= (uint32_t)0xFEF6FFFF;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CR &= (uint32_t)0xFEF6FFFF;
N
N  /* Reset HSEBYP bit */
N  RCC->CR &= (uint32_t)0xFFFBFFFF;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CR &= (uint32_t)0xFFFBFFFF;
N
N  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
N  RCC->CFGR &= (uint32_t)0xFF80FFFF;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR &= (uint32_t)0xFF80FFFF;
N
N  /* Reset PREDIV1[3:0] bits */
N  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR2 &= (uint32_t)0xFFFFFFF0;
N
N  /* Reset USARTSW[1:0], I2CSW and CECSW bits */
N  RCC->CFGR3 &= (uint32_t)0xFFF0F8C;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 &= (uint32_t)0xFFF0F8C;
N  
N  /* Disable all interrupts */
N  RCC->CIR = 0x00000000;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CIR = 0x00000000;
N}
N
N/**
N  * @brief  Configures the External High Speed oscillator (HSE).
N  * @note   After enabling the HSE (RCC_HSE_ON or RCC_HSE_Bypass), the application
N  *         software should wait on HSERDY flag to be set indicating that HSE clock
N  *         is stable and can be used to clock the PLL and/or system clock.
N  * @note   HSE state can not be changed if it is used directly or through the
N  *         PLL as system clock. In this case, you have to select another source
N  *         of the system clock then change the HSE state (ex. disable it).
N  * @note   The HSE is stopped by hardware when entering STOP and STANDBY modes.
N  * @note   This function resets the CSSON bit, so if the Clock security system(CSS)
N  *         was previously enabled you have to enable it again after calling this
N  *         function.
N  * @param  RCC_HSE: specifies the new state of the HSE.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_HSE_OFF: turn OFF the HSE oscillator, HSERDY flag goes low after
N  *                              6 HSE oscillator clock cycles.
N  *            @arg RCC_HSE_ON: turn ON the HSE oscillator
N  *            @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
N  * @retval None
N  */
Nvoid RCC_HSEConfig(uint8_t RCC_HSE)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_HSE(RCC_HSE));
X  ((void)0);
N
N  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
N  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
X  *(volatile uint8_t *) ((uint32_t)0x40021002) = ((uint8_t)0x00);
N
N  /* Set the new HSE configuration -------------------------------------------*/
N  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
X  *(volatile uint8_t *) ((uint32_t)0x40021002) = RCC_HSE;
N
N}
N
N/**
N  * @brief  Waits for HSE start-up.
N  * @note   This function waits on HSERDY flag to be set and return SUCCESS if 
N  *         this flag is set, otherwise returns ERROR if the timeout is reached 
N  *         and this flag is not set. The timeout value is defined by the constant
N  *         HSE_STARTUP_TIMEOUT in stm32f37x.h file. You can tailor it depending
N  *         on the HSE crystal used in your application.
N  * @param  None
N  * @retval An ErrorStatus enumeration value:
N  *          - SUCCESS: HSE oscillator is stable and ready to use
N  *          - ERROR: HSE oscillator not yet ready
N  */
NErrorStatus RCC_WaitForHSEStartUp(void)
N{
N  __IO uint32_t StartUpCounter = 0;
X  volatile uint32_t StartUpCounter = 0;
N  ErrorStatus status = ERROR;
N  FlagStatus HSEStatus = RESET;
N  
N  /* Wait till HSE is ready and if timeout is reached exit */
N  do
N  {
N    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
X    HSEStatus = RCC_GetFlagStatus(((uint8_t)0x11));
N    StartUpCounter++;  
N  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
X  } while((StartUpCounter != ((uint16_t)0x0500)) && (HSEStatus == RESET));
N  
N  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
X  if (RCC_GetFlagStatus(((uint8_t)0x11)) != RESET)
N  {
N    status = SUCCESS;
N  }
N  else
N  {
N    status = ERROR;
N  }  
N  return (status);
N}
N
N/**
N  * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.
N  * @note   The calibration is used to compensate for the variations in voltage
N  *         and temperature that influence the frequency of the internal HSI RC.
N  * @param  HSICalibrationValue: specifies the HSI calibration trimming value.
N  *          This parameter must be a number between 0 and 0x1F.
N  * @retval None
N  */
Nvoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
N{
N  uint32_t tmpreg = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
X  ((void)0);
N  
N  tmpreg = RCC->CR;
X  tmpreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CR;
N  
N  /* Clear HSITRIM[4:0] bits */
N  tmpreg &= ~RCC_CR_HSITRIM;
X  tmpreg &= ~((uint32_t)0x000000F8);
N  
N  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
N  tmpreg |= (uint32_t)HSICalibrationValue << 3;
N  
N  /* Store the new value */
N  RCC->CR = tmpreg;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CR = tmpreg;
N}
N
N/**
N  * @brief  Enables or disables the Internal High Speed oscillator (HSI).
N  * @note   After enabling the HSI, the application software should wait on 
N  *         HSIRDY flag to be set indicating that HSI clock is stable and can
N  *         be used to clock the PLL and/or system clock.
N  * @note   HSI can not be stopped if it is used directly or through the PLL
N  *         as system clock. In this case, you have to select another source 
N  *         of the system clock then stop the HSI.
N  * @note   The HSI is stopped by hardware when entering STOP and STANDBY modes.
N  * @param  NewState: new state of the HSI.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @note   When the HSI is stopped, HSIRDY flag goes low after 6 HSI oscillator
N  *         clock cycles.
N  * @retval None
N  */
Nvoid RCC_HSICmd(FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
X  *(volatile uint32_t *) (((uint32_t)0x42000000) + (((((((uint32_t)0x40000000) + 0x00020000) + 0x1000) - ((uint32_t)0x40000000)) + 0x00) * 32) + (0x00 * 4)) = (uint32_t)NewState;
N}
N
N/**
N  * @brief  Configures the External Low Speed oscillator (LSE).
N  * @note   As the LSE is in the Backup domain and write access is denied to this
N  *         domain after reset, you have to enable write access using 
N  *         PWR_BackupAccessCmd(ENABLE) function before to configure the LSE
N  *         (to be done once after reset).
N  * @note   After enabling the LSE (RCC_LSE_ON or RCC_LSE_Bypass), the application
N  *         software should wait on LSERDY flag to be set indicating that LSE clock
N  *         is stable and can be used to clock the RTC.
N  * @param  RCC_LSE: specifies the new state of the LSE.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_LSE_OFF: turn OFF the LSE oscillator, LSERDY flag goes low after
N  *                              6 LSE oscillator clock cycles.
N  *            @arg RCC_LSE_ON: turn ON the LSE oscillator
N  *            @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
N  * @retval None
N  */
Nvoid RCC_LSEConfig(uint32_t RCC_LSE)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_LSE(RCC_LSE));
X  ((void)0);
N
N  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
N  /* Reset LSEON bit */
N  RCC->BDCR &= ~(RCC_BDCR_LSEON);
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->BDCR &= ~(((uint32_t)0x00000001));
N
N  /* Reset LSEBYP bit */
N  RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->BDCR &= ~(((uint32_t)0x00000004));
N
N  /* Configure LSE */
N  RCC->BDCR |= RCC_LSE;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->BDCR |= RCC_LSE;
N}
N
N/**
N  * @brief  Configures the External Low Speed oscillator (LSE) drive capability.
N  * @param  RCC_LSEDrive: specifies the new state of the LSE drive capability.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_LSEDrive_Low: LSE oscillator low drive capability.
N  *            @arg RCC_LSEDrive_MediumLow: LSE oscillator medium low drive capability.
N  *            @arg RCC_LSEDrive_MediumHigh: LSE oscillator medium high drive capability.
N  *            @arg RCC_LSEDrive_High: LSE oscillator high drive capability.
N  * @retval None
N  */
Nvoid RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
X  ((void)0);
N  
N  /* Clear LSEDRV[1:0] bits */
N  RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->BDCR &= ~(((uint32_t)0x00000018));
N
N  /* Set the LSE Drive */
N  RCC->BDCR |= RCC_LSEDrive;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->BDCR |= RCC_LSEDrive;
N}
N
N/**
N  * @brief  Enables or disables the Internal Low Speed oscillator (LSI).
N  * @note   After enabling the LSI, the application software should wait on 
N  *         LSIRDY flag to be set indicating that LSI clock is stable and can
N  *         be used to clock the IWDG and/or the RTC.
N  * @note   LSI can not be disabled if the IWDG is running.
N  * @param  NewState: new state of the LSI.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @note   When the LSI is stopped, LSIRDY flag goes low after 6 LSI oscillator
N  *         clock cycles.
N  * @retval None
N  */
Nvoid RCC_LSICmd(FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
X  *(volatile uint32_t *) (((uint32_t)0x42000000) + (((((((uint32_t)0x40000000) + 0x00020000) + 0x1000) - ((uint32_t)0x40000000)) + 0x24) * 32) + (0x00 * 4)) = (uint32_t)NewState;
N}
N
N/**
N  * @brief  Configures the PLL clock source and multiplication factor.
N  * @note   This function must be used only when the PLL is disabled.
N  *
N  * @param  RCC_PLLSource: specifies the PLL entry clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock selected as PLL clock source
N  *            @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry
N  * @note   The minimum input clock frequency for PLL is 2 MHz (when using HSE as
N  *         PLL source).
N  *
N  * @param  RCC_PLLMul: specifies the PLL multiplication factor, which drive the PLLVCO clock
N  *          This parameter can be RCC_PLLMul_x where x:[2,16] 
N  *
N  * @retval None
N  */
Nvoid RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
X  ((void)0);
N  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
X  ((void)0);
N
N  /* Clear PLL Source [16] and Multiplier [21:18] bits */
N  RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR &= ~(((uint32_t)0x003C0000) | ((uint32_t)0x00010000));
N
N  /* Set the PLL Source and Multiplier */
N  RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
N}
N
N/**
N  * @brief  Enables or disables the PLL.
N  * @note   After enabling the PLL, the application software should wait on 
N  *         PLLRDY flag to be set indicating that PLL clock is stable and can
N  *         be used as system clock source.
N  * @note   The PLL can not be disabled if it is used as system clock source
N  * @note   The PLL is disabled by hardware when entering STOP and STANDBY modes.
N  * @param  NewState: new state of the PLL.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_PLLCmd(FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
X  *(volatile uint32_t *) (((uint32_t)0x42000000) + (((((((uint32_t)0x40000000) + 0x00020000) + 0x1000) - ((uint32_t)0x40000000)) + 0x00) * 32) + (0x18 * 4)) = (uint32_t)NewState;
N}
N
N/**
N  * @brief  Configures the PREDIV1 division factor.
N  * @note   This function must be used only when the PLL is disabled.
N  * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.
N  *          This parameter can be RCC_PREDIV1_Divx where x:[1,16]
N  * @retval None
N  */
Nvoid RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
N{
N  uint32_t tmpreg = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
X  ((void)0);
N
N  tmpreg = RCC->CFGR2;
X  tmpreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR2;
N  /* Clear PREDIV1[3:0] bits */
N  tmpreg &= ~(RCC_CFGR2_PREDIV1);
X  tmpreg &= ~(((uint32_t)0x0000000F));
N
N  /* Set the PREDIV1 division factor */
N  tmpreg |= RCC_PREDIV1_Div;
N
N  /* Store the new value */
N  RCC->CFGR2 = tmpreg;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR2 = tmpreg;
N}
N
N/**
N  * @brief  Enables or disables the Clock Security System.
N  * @note   If a failure is detected on the HSE oscillator clock, this oscillator
N  *         is automatically disabled and an interrupt is generated to inform the
N  *         software about the failure (Clock Security System Interrupt, CSSI),
N  *         allowing the MCU to perform rescue operations. The CSSI is linked to 
N  *         the Cortex-M4 NMI (Non-Maskable Interrupt) exception vector.  
N  * @param  NewState: new state of the Clock Security System.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
X  *(volatile uint32_t *) (((uint32_t)0x42000000) + (((((((uint32_t)0x40000000) + 0x00020000) + 0x1000) - ((uint32_t)0x40000000)) + 0x00) * 32) + (0x13 * 4)) = (uint32_t)NewState;
N}
N
N/**
N  * @brief  Selects the clock source to output on MCO pin (PA8).
N  * @note   PA8 should be configured in alternate function mode.
N  * @param  RCC_MCOSource: specifies the clock source to output.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_MCOSource_NoClock: No clock selected.
N  *            @arg RCC_MCOSource_LSI: LSI oscillator clock selected.
N  *            @arg RCC_MCOSource_LSE: LSE oscillator clock selected.
N  *            @arg RCC_MCOSource_SYSCLK: System clock selected.
N  *            @arg RCC_MCOSource_HSI: HSI oscillator clock selected.
N  *            @arg RCC_MCOSource_HSE: HSE oscillator clock selected.
N  *            @arg RCC_MCOSource_PLLCLK_Div2: PLL clock divided by 2 selected.
N  * @retval None
N  */
Nvoid RCC_MCOConfig(uint8_t RCC_MCOSource)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
X  ((void)0);
N    
N  /* Select MCO clock source and prescaler */
N  *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource; 
X  *(volatile uint8_t *) ((uint32_t)0x40021007) =  RCC_MCOSource; 
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Group2 System AHB, APB1 and APB2 busses clocks configuration functions
N *  @brief   System, AHB and APB busses clocks configuration functions
N *
N@verbatim
N ===============================================================================
N     ##### System, AHB, APB1 and APB2 busses clocks configuration functions #####
N ===============================================================================
N
N    [..] This section provide functions allowing to configure the System, AHB, APB1 and 
N         APB2 busses clocks.
N         (#) Several clock sources can be used to drive the System clock (SYSCLK): HSI,
N             HSE and PLL.
N             The AHB clock (HCLK) is derived from System clock through configurable prescaler
N             and used to clock the CPU, memory and peripherals mapped on AHB bus (DMA and GPIO).
N             APB1 (PCLK1) and APB2 (PCLK2) clocks are derived from AHB clock through 
N             configurable prescalers and used to clock the peripherals mapped on these busses.
N             You can use "RCC_GetClocksFreq()" function to retrieve the frequencies of these clocks.
N
N         -@- All the peripheral clocks are derived from the System clock (SYSCLK) except:
N             (+@) The FLASH program/erase clock  which is always HSI 8MHz clock.
N             (+@) The USB 48 MHz clock which is derived from the PLL VCO clock.
N             (+@) The USART clock which can be derived as well from HSI 8MHz, LSI or LSE.
N             (+@) The I2C clock which can be derived as well from HSI 8MHz clock.
N             (+@) The CEC clock which can be derived from HSI 8MHz or LSE. 
N             (+@) The RTC clock which is derived from the LSE, LSI or 1 MHz HSE_RTC (HSE
N                  divided by a programmable prescaler).
N                  The System clock (SYSCLK) frequency must be higher or equal to the RTC
N                  clock frequency.
N             (+@) IWDG clock which is always the LSI clock.
N       
N         (#) The maximum frequency of the SYSCLK, HCLK, PCLK1 and PCLK2 is 72 MHz.
N             Depending on the maximum frequency, the FLASH wait states (WS) should be 
N             adapted accordingly:
N        +---------------------------------+
N        |  Wait states  |   HCLK clock    |
N        |   (Latency)   | frequency (MHz) |
N        |-------------- |-----------------|
N        |0WS(1CPU cycle)| 0 < HCLK <= 24  |
N        |---------------|-----------------| 
N        |1WS(2CPU cycle)|24 < HCLK <=48   |
N        |---------------|-----------------| 
N        |2WS(3CPU cycle)|48 < HCLK <= 72  |
N        +---------------------------------+
N
N         (#) After reset, the System clock source is the HSI (8 MHz) with 0 WS and 
N             prefetch is disabled.
N    [..] It is recommended to use the following software sequences to tune the number
N         of wait states needed to access the Flash memory with the CPU frequency (HCLK).
N         (+) Increasing the CPU frequency
N         (++) Program the Flash Prefetch buffer, using "FLASH_PrefetchBufferCmd(ENABLE)" 
N              function
N         (++) Check that Flash Prefetch buffer activation is taken into account by 
N              reading FLASH_ACR using the FLASH_GetPrefetchBufferStatus() function
N         (++) Program Flash WS to 1 or 2, using "FLASH_SetLatency()" function
N         (++) Check that the new number of WS is taken into account by reading FLASH_ACR
N         (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
N         (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
N         (++) Check that the new CPU clock source is taken into account by reading 
N              the clock source status, using "RCC_GetSYSCLKSource()" function 
N         (+) Decreasing the CPU frequency
N         (++) Modify the CPU clock source, using "RCC_SYSCLKConfig()" function
N         (++) If needed, modify the CPU clock prescaler by using "RCC_HCLKConfig()" function
N         (++) Check that the new CPU clock source is taken into account by reading 
N              the clock source status, using "RCC_GetSYSCLKSource()" function
N         (++) Program the new number of WS, using "FLASH_SetLatency()" function
N         (++) Check that the new number of WS is taken into account by reading FLASH_ACR
N         (++) Disable the Flash Prefetch buffer using "FLASH_PrefetchBufferCmd(DISABLE)" 
N              function
N         (++) Check that Flash Prefetch buffer deactivation is taken into account by reading FLASH_ACR
N              using the FLASH_GetPrefetchBufferStatus() function.
N
N@endverbatim
N  * @{
N  */
N
N/**
N  * @brief  Configures the system clock (SYSCLK).
N  * @note   The HSI is used (enabled by hardware) as system clock source after
N  *         startup from Reset, wake-up from STOP and STANDBY mode, or in case
N  *         of failure of the HSE used directly or indirectly as system clock
N  *         (if the Clock Security System CSS is enabled).
N  * @note   A switch from one clock source to another occurs only if the target
N  *         clock source is ready (clock stable after startup delay or PLL locked). 
N  *         If a clock source which is not yet ready is selected, the switch will
N  *         occur when the clock source will be ready. 
N  *         You can use RCC_GetSYSCLKSource() function to know which clock is
N  *         currently used as system clock source.  
N  * @param  RCC_SYSCLKSource: specifies the clock source used as system clock source 
N  *          This parameter can be one of the following values:
N  *            @arg RCC_SYSCLKSource_HSI:    HSI selected as system clock source
N  *            @arg RCC_SYSCLKSource_HSE:    HSE selected as system clock source
N  *            @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock source
N  * @retval None
N  */
Nvoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
N{
N  uint32_t tmpreg = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
X  ((void)0);
N  
N  tmpreg = RCC->CFGR;
X  tmpreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR;
N  
N  /* Clear SW[1:0] bits */
N  tmpreg &= ~RCC_CFGR_SW;
X  tmpreg &= ~((uint32_t)0x00000003);
N  
N  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
N  tmpreg |= RCC_SYSCLKSource;
N  
N  /* Store the new value */
N  RCC->CFGR = tmpreg;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR = tmpreg;
N}
N
N/**
N  * @brief  Returns the clock source used as system clock.
N  * @param  None
N  * @retval The clock source used as system clock. The returned value can be one 
N  *         of the following values:
N  *           - 0x00: HSI used as system clock
N  *           - 0x04: HSE used as system clock  
N  *           - 0x08: PLL used as system clock
N  */
Nuint8_t RCC_GetSYSCLKSource(void)
N{
N  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
X  return ((uint8_t)(((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0x0000000C)));
N}
N
N/**
N  * @brief  Configures the AHB clock (HCLK).
N  * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from 
N  *                     the system clock (SYSCLK).
N  *          This parameter can be one of the following values:
N  *            @arg RCC_SYSCLK_Div1:   AHB clock = SYSCLK
N  *            @arg RCC_SYSCLK_Div2:   AHB clock = SYSCLK/2
N  *            @arg RCC_SYSCLK_Div4:   AHB clock = SYSCLK/4
N  *            @arg RCC_SYSCLK_Div8:   AHB clock = SYSCLK/8
N  *            @arg RCC_SYSCLK_Div16:  AHB clock = SYSCLK/16
N  *            @arg RCC_SYSCLK_Div64:  AHB clock = SYSCLK/64
N  *            @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128
N  *            @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
N  *            @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
N  * @retval None
N  */
Nvoid RCC_HCLKConfig(uint32_t RCC_SYSCLK)
N{
N  uint32_t tmpreg = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
X  ((void)0);
N  
N  tmpreg = RCC->CFGR;
X  tmpreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR;
N  
N  /* Clear HPRE[3:0] bits */
N  tmpreg &= ~RCC_CFGR_HPRE;
X  tmpreg &= ~((uint32_t)0x000000F0);
N  
N  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
N  tmpreg |= RCC_SYSCLK;
N  
N  /* Store the new value */
N  RCC->CFGR = tmpreg;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR = tmpreg;
N}
N
N/**
N  * @brief  Configures the Low Speed APB clock (PCLK1).
N  * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from 
N  *         the AHB clock (HCLK).
N  *          This parameter can be one of the following values:
N  *            @arg RCC_HCLK_Div1: APB1 clock = HCLK
N  *            @arg RCC_HCLK_Div2: APB1 clock = HCLK/2
N  *            @arg RCC_HCLK_Div4: APB1 clock = HCLK/4
N  *            @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
N  *            @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
N  * @retval None
N  */
Nvoid RCC_PCLK1Config(uint32_t RCC_HCLK)
N{
N  uint32_t tmpreg = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_PCLK(RCC_HCLK));
X  ((void)0);
N  
N  tmpreg = RCC->CFGR;
X  tmpreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR;
N  /* Clear PPRE1[2:0] bits */
N  tmpreg &= ~RCC_CFGR_PPRE1;
X  tmpreg &= ~((uint32_t)0x00000700);
N  
N  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
N  tmpreg |= RCC_HCLK;
N  
N  /* Store the new value */
N  RCC->CFGR = tmpreg;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR = tmpreg;
N}
N
N/**
N  * @brief  Configures the High Speed APB clock (PCLK2).
N  * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from 
N  *         the AHB clock (HCLK).
N  *          This parameter can be one of the following values:
N  *             @arg RCC_HCLK_Div1: APB2 clock = HCLK
N  *             @arg RCC_HCLK_Div2: APB2 clock = HCLK/2
N  *             @arg RCC_HCLK_Div4: APB2 clock = HCLK/4
N  *             @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
N  *             @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
N  * @retval None
N  */
Nvoid RCC_PCLK2Config(uint32_t RCC_HCLK)
N{
N  uint32_t tmpreg = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_PCLK(RCC_HCLK));
X  ((void)0);
N  
N  tmpreg = RCC->CFGR;
X  tmpreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR;
N  /* Clear PPRE2[2:0] bits */
N  tmpreg &= ~RCC_CFGR_PPRE2;
X  tmpreg &= ~((uint32_t)0x00003800);
N  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
N  tmpreg |= RCC_HCLK << 3;
N  /* Store the new value */
N  RCC->CFGR = tmpreg;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR = tmpreg;
N}
N
N/**
N  * @brief  Configures the ADC clock (ADCCLK).
N  * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from 
N  *         the APB2 clock (PCLK2).
N  *          This parameter can be one of the following values:
N  *             @arg RCC_PCLK2_Div2: ADC clock = PCLK2/2
N  *             @arg RCC_PCLK2_Div4: ADC clock = PCLK2/4
N  *             @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6
N  *             @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8
N  * @retval None
N  */
Nvoid RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
N{
N 
N  /* Check the parameters */
N  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
X  ((void)0);
N  
N  /* Clear ADCPRE[1:0] bits */
N  RCC->CFGR &= ~RCC_CFGR_ADCPRE;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR &= ~((uint32_t)0x0000C000);
N  
N  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
N  RCC->CFGR |= RCC_PCLK2;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR |= RCC_PCLK2;
N}
N
N/**
N  * @brief  Configures the SDADC clock (SDADCCLK).
N  * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from 
N  *         the system clock (SYSCLK).
N  *          This parameter can be one of the following values:
N  *             @arg RCC_SDADCCLK_SYSCLK_Div2: SDADC clock = SYSCLK/2
N  *             @arg RCC_SDADCCLK_SYSCLK_Div4: SDADC clock = SYSCLK/4
N  *             @arg RCC_SDADCCLK_SYSCLK_Div6: SDADC clock = SYSCLK/6
N  *             @arg RCC_SDADCCLK_SYSCLK_Div8: SDADC clock = SYSCLK/8
N  *             @arg RCC_SDADCCLK_SYSCLK_Div10: SDADC clock = SYSCLK/10
N  *             @arg RCC_SDADCCLK_SYSCLK_Div12: SDADC clock = SYSCLK/12
N  *             @arg RCC_SDADCCLK_SYSCLK_Div14: SDADC clock = SYSCLK/14
N  *             @arg RCC_SDADCCLK_SYSCLK_Div16: SDADC clock = SYSCLK/16
N  *             @arg RCC_SDADCCLK_SYSCLK_Div20: SDADC clock = SYSCLK/20
N  *             @arg RCC_SDADCCLK_SYSCLK_Div24: SDADC clock = SYSCLK/24
N  *             @arg RCC_SDADCCLK_SYSCLK_Div28: SDADC clock = SYSCLK/28
N  *             @arg RCC_SDADCCLK_SYSCLK_Div32: SDADC clock = SYSCLK/32
N  *             @arg RCC_SDADCCLK_SYSCLK_Div36: SDADC clock = SYSCLK/36
N  *             @arg RCC_SDADCCLK_SYSCLK_Div40: SDADC clock = SYSCLK/40
N  *             @arg RCC_SDADCCLK_SYSCLK_Div44: SDADC clock = SYSCLK/44
N  *             @arg RCC_SDADCCLK_SYSCLK_Div48: SDADC clock = SYSCLK/48                       
N  * @retval None
N  */
Nvoid RCC_SDADCCLKConfig(uint32_t RCC_SDADCCLK)
N{   
N  /* Check the parameters */
N  assert_param(IS_RCC_SDADCCLK(RCC_SDADCCLK));
X  ((void)0);
N  
N  /* Clear ADCPRE[1:0] bits */
N  RCC->CFGR &= ~RCC_CFGR_SDADCPRE;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR &= ~((uint32_t)0xF8000000);
N  
N  /* Set SDADCPRE[4:0] bits according to RCC_PCLK2 value */
N  RCC->CFGR |= RCC_SDADCCLK;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR |= RCC_SDADCCLK;
N}
N
N/**
N  * @brief  Configures the CEC clock (CECCLK).
N  * @param  RCC_CECCLK: defines the CEC clock source. This clock is derived 
N  *         from the HSI or LSE clock.
N  *          This parameter can be one of the following values:
N  *             @arg RCC_CECCLK_HSI_Div244: CEC clock = HSI/244 (32768Hz)
N  *             @arg RCC_CECCLK_LSE: CEC clock = LSE
N  * @retval None
N  */
Nvoid RCC_CECCLKConfig(uint32_t RCC_CECCLK)
N{ 
N  /* Check the parameters */
N  assert_param(IS_RCC_CECCLK(RCC_CECCLK));
X  ((void)0);
N
N  /* Clear CECSW bit */
N  RCC->CFGR3 &= ~RCC_CFGR3_CECSW;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 &= ~((uint32_t)0x00000040);
N  /* Set CECSW bits according to RCC_CECCLK value */
N  RCC->CFGR3 |= RCC_CECCLK;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 |= RCC_CECCLK;
N}
N
N/**
N  * @brief  Configures the I2C clock (I2CCLK).
N  * @param  RCC_I2CCLK: defines the I2C clock source. This clock is derived 
N  *         from the HSI or System clock.
N  *          This parameter can be one of the following values:
N  *             @arg RCC_I2CxCLK_HSI: I2Cx clock = HSI
N  *             @arg RCC_I2CxCLK_SYSCLK: I2Cx clock = System Clock
N  * @note  x can be 1 or 2  
N  * @retval None
N  */
Nvoid RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
N{ 
N  uint32_t tmp = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
X  ((void)0);
N
N  tmp = (RCC_I2CCLK >> 28);
N  
N  /* Clear I2CSW bit */
N  if (tmp == 0)
N  {
N    RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 &= ~((uint32_t)0x00000010);
N  }
N  else
N  {
N    RCC->CFGR3 &= ~RCC_CFGR3_I2C2SW;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 &= ~((uint32_t)0x00000020);
N  }
N  /* Set I2CSW bits according to RCC_I2CCLK value */
N  RCC->CFGR3 |= RCC_I2CCLK;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 |= RCC_I2CCLK;
N}
N
N/**
N  * @brief  Configures the USART clock (USARTCLK).
N  * @param  RCC_USARTCLK: defines the USART clock source. This clock is derived 
N  *         from the HSI or System clock.
N  *          This parameter can be one of the following values:
N  *             @arg RCC_USARTxCLK_PCLK: USART clock = APB Clock (PCLK)
N  *             @arg RCC_USARTxCLK_SYSCLK: USART clock = System Clock
N  *             @arg RCC_USARTxCLK_LSE: USART clock = LSE Clock
N  *             @arg RCC_USARTxCLK_HSI: USART clock = HSI Clock
N  * @note  x can be 1, 2 or 3  
N  * @retval None
N  */
Nvoid RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
N{ 
N  uint32_t tmp = 0;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
X  ((void)0);
N
N  tmp = (RCC_USARTCLK >> 28);
N
N  /* Clear USARTSW[1:0] bit */
N  switch (tmp)
N  {
N    case 0x01:  /* clear USART1SW */
N      RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
X      ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 &= ~((uint32_t)0x00000003);
N      break;
N    case 0x02:  /* clear USART2SW */
N      RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
X      ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 &= ~((uint32_t)0x00030000);
N      break;
N    case 0x03:  /* clear USART3SW */
N      RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
X      ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 &= ~((uint32_t)0x000C0000);
N      break;
N  default:
N      break;
N  }
N
N  /* Set USARTSW bits according to RCC_USARTCLK value */
N  RCC->CFGR3 |= RCC_USARTCLK;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 |= RCC_USARTCLK;
N}
N
N/**
N  * @brief  Configures the USB clock (USBCLK).
N  * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is 
N  *         derived from the PLL output.
N  *          This parameter can be one of the following values:
N  *             @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB 
N  *                  clock source
N  *             @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source
N  * @retval None
N  */
Nvoid RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
X  ((void)0);
N
N  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
X  *(volatile uint32_t *) (((uint32_t)0x42000000) + (((((((uint32_t)0x40000000) + 0x00020000) + 0x1000) - ((uint32_t)0x40000000)) + 0x04) * 32) + (0x16 * 4)) = RCC_USBCLKSource;
N}
N
N/**
N  * @brief  Returns the frequencies of the System, AHB, APB2 and APB1 busses clocks.
N  * @note    The frequency returned by this function is not the real frequency
N  *           in the chip. It is calculated based on the predefined constant and
N  *           the source selected by RCC_SYSCLKConfig():
N  *                                              
N  * @note     If SYSCLK source is HSI, function returns constant HSI_VALUE(*)
N  *                                              
N  * @note     If SYSCLK source is HSE, function returns constant HSE_VALUE(**)
N  *                          
N  * @note     If SYSCLK source is PLL, function returns constant HSE_VALUE(**) 
N  *             or HSI_VALUE(*) multiplied by the PLL factors.
N  *         
N  * @note     (*) HSI_VALUE is a constant defined in stm32f37x.h file (default value
N  *               8 MHz) but the real value may vary depending on the variations
N  *               in voltage and temperature, refer to RCC_AdjustHSICalibrationValue().   
N  *    
N  * @note     (**) HSE_VALUE is a constant defined in stm32f37x.h file (default value
N  *                8 MHz), user has to ensure that HSE_VALUE is same as the real
N  *                frequency of the crystal used. Otherwise, this function may
N  *                return wrong result.
N  *                
N  * @note   The result of this function could be not correct when using fractional
N  *         value for HSE crystal.   
N  *             
N  * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold 
N  *         the clocks frequencies. 
N  *     
N  * @note   This function can be used by the user application to compute the 
N  *         baudrate for the communication peripherals or configure other parameters.
N  * @note   Each time SYSCLK, HCLK, PCLK1 and/or PCLK2 clock changes, this function
N  *         must be called to update the structure's field. Otherwise, any
N  *         configuration based on this function will be incorrect.
N  *    
N  * @retval None
N  */
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
N{
N  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0;
N
N  /* Get SYSCLK source -------------------------------------------------------*/
N  tmp = RCC->CFGR & RCC_CFGR_SWS;
X  tmp = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0x0000000C);
N  
N  switch (tmp)
N  {
N    case 0x00:  /* HSI used as system clock */
N      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
X      RCC_Clocks->SYSCLK_Frequency = ((uint32_t)8000000);
N      break;
N    case 0x04:  /* HSE used as system clock */
N      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
X      RCC_Clocks->SYSCLK_Frequency = ((uint32_t)16000000);
N      break;
N    case 0x08:  /* PLL used as system clock */
N      /* Get PLL clock source and multiplication factor ----------------------*/
N      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
X      pllmull = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0x003C0000);
N      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
X      pllsource = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0x00010000);
N      pllmull = ( pllmull >> 18) + 2;
N      
N      if (pllsource == 0x00)
N      {
N        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
N        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
X        RCC_Clocks->SYSCLK_Frequency = (((uint32_t)8000000) >> 1) * pllmull;
N      }
N      else
N      {
N        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
X        prediv1factor = (((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR2 & ((uint32_t)0x0000000F)) + 1;
N        /* HSE oscillator clock selected as PREDIV1 clock entry */
N        RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
X        RCC_Clocks->SYSCLK_Frequency = (((uint32_t)16000000) / prediv1factor) * pllmull; 
N      }      
N      break;
N    default: /* HSI used as system clock */
N      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
X      RCC_Clocks->SYSCLK_Frequency = ((uint32_t)8000000);
N      break;
N  }
N  /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
N  /* Get HCLK prescaler */
N  tmp = RCC->CFGR & RCC_CFGR_HPRE;
X  tmp = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0x000000F0);
N  tmp = tmp >> 4;
N  presc = APBAHBPrescTable[tmp]; 
N  /* HCLK clock frequency */
N  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
N
N  /* Get PCLK1 prescaler */
N  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
X  tmp = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0x00000700);
N  tmp = tmp >> 8;
N  presc = APBAHBPrescTable[tmp];
N  /* PCLK1 clock frequency */
N  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
N  
N  /* Get PCLK2 prescaler */
N  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
X  tmp = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0x00003800);
N  tmp = tmp >> 11;
N  presc = APBAHBPrescTable[tmp];
N  /* PCLK2 clock frequency */
N  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
N  
N  /* Get ADCCLK prescaler */
N  tmp = RCC->CFGR & RCC_CFGR_ADCPRE;
X  tmp = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0x0000C000);
N  tmp = tmp >> 14;
N  presc = ADCPrescTable[tmp];
N  /* ADCCLK clock frequency */
N  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
N  
N  /* Get SDADCCLK prescaler */
N  tmp = RCC->CFGR & RCC_CFGR_SDADCPRE;
X  tmp = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR & ((uint32_t)0xF8000000);
N  tmp = (tmp >> 27) & 0x0F;
N  presc = SDADCPrescTable[tmp];
N  /* ADCCLK clock frequency */
N  RCC_Clocks->SDADCCLK_Frequency = RCC_Clocks->SYSCLK_Frequency / presc;
N  
N  /* CECCLK clock frequency */
N  if((RCC->CFGR3 & RCC_CFGR3_CECSW) != RCC_CFGR3_CECSW)
X  if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00000040)) != ((uint32_t)0x00000040))
N  {
N    /* CEC Clock is HSI/244 */
N    RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
X    RCC_Clocks->CECCLK_Frequency = ((uint32_t)8000000) / 244;
N  }
N  else
N  {
N    /* CECC Clock is LSE Osc. */
N    RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
X    RCC_Clocks->CECCLK_Frequency = ((uint32_t)32768);
N  }
N  
N  /* I2C1CLK clock frequency */
N  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
X  if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00000010)) != ((uint32_t)0x00000010))
N  {
N    /* I2C1 Clock is HSI Osc. */
N    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
X    RCC_Clocks->I2C1CLK_Frequency = ((uint32_t)8000000);
N  }
N  else
N  {
N    /* I2C1 Clock is System Clock */
N    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
N  }
N
N  /* I2C2CLK clock frequency */
N  if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
X  if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00000020)) != ((uint32_t)0x00000020))
N  {
N    /* I2C2 Clock is HSI Osc. */
N    RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
X    RCC_Clocks->I2C2CLK_Frequency = ((uint32_t)8000000);
N  }
N  else
N  {
N    /* I2C2 Clock is System Clock */
N    RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
N  }
N
N  /* USART1CLK clock frequency */
N  if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
X  if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00000003)) == 0x0)
N  {
N    /* USART Clock is PCLK */
N    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00000003)) == ((uint32_t)0x00000001))
N  {
N    /* USART Clock is System Clock */
N    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00000003)) == ((uint32_t)0x00000002))
N  {
N    /* USART Clock is LSE Osc. */
N    RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
X    RCC_Clocks->USART1CLK_Frequency = ((uint32_t)32768);
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00000003)) == ((uint32_t)0x00000003))
N  {
N    /* USART Clock is HSI Osc. */
N    RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
X    RCC_Clocks->USART1CLK_Frequency = ((uint32_t)8000000);
N  }
N
N  /* USART2CLK clock frequency */
N  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
X  if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00030000)) == 0x0)
N  {
N    /* USART Clock is PCLK */
N    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00030000)) == ((uint32_t)0x00010000))
N  {
N    /* USART Clock is System Clock */
N    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00030000)) == ((uint32_t)0x00020000))
N  {
N    /* USART Clock is LSE Osc. */
N    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
X    RCC_Clocks->USART2CLK_Frequency = ((uint32_t)32768);
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x00030000)) == ((uint32_t)0x00030000))
N  {
N    /* USART Clock is HSI Osc. */
N    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
X    RCC_Clocks->USART2CLK_Frequency = ((uint32_t)8000000);
N  }    
N
N  /* USART3CLK clock frequency */
N  if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
X  if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x000C0000)) == 0x0)
N  {
N    /* USART Clock is PCLK */
N    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x000C0000)) == ((uint32_t)0x00040000))
N  {
N    /* USART Clock is System Clock */
N    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x000C0000)) == ((uint32_t)0x00080000))
N  {
N    /* USART Clock is LSE Osc. */
N    RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
X    RCC_Clocks->USART3CLK_Frequency = ((uint32_t)32768);
N  }
N  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
X  else if((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CFGR3 & ((uint32_t)0x000C0000)) == ((uint32_t)0x000C0000))
N  {
N    /* USART Clock is HSI Osc. */
N    RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
X    RCC_Clocks->USART3CLK_Frequency = ((uint32_t)8000000);
N  }  
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Group3 Peripheral clocks configuration functions
N *  @brief   Peripheral clocks configuration functions 
N *
N@verbatim
N ===============================================================================
N             #####Peripheral clocks configuration functions #####
N ===============================================================================
N    [..] This section provides functions allowing to configure the Peripheral clocks. 
N         (#) The RTC clock which is derived from the LSE, LSI or  HSE_Div32 (HSE
N             divided by 32).
N         (#) After restart from Reset or wakeup from STANDBY, all peripherals are off
N             except internal SRAM, Flash and SWD. Before to start using a peripheral you
N             have to enable its interface clock. You can do this using RCC_AHBPeriphClockCmd(),
N             RCC_APB2PeriphClockCmd() and RCC_APB1PeriphClockCmd() functions.
N         (#) To reset the peripherals configuration (to the default state after device reset)
N             you can use RCC_AHBPeriphResetCmd(), RCC_APB2PeriphResetCmd() and 
N             RCC_APB1PeriphResetCmd() functions.
N
N@endverbatim
N  * @{
N  */
N
N/**
N  * @brief  Configures the RTC clock (RTCCLK).
N  * @note   As the RTC clock configuration bits are in the Backup domain and write
N  *         access is denied to this domain after reset, you have to enable write
N  *         access using PWR_BackupAccessCmd(ENABLE) function before to configure
N  *         the RTC clock source (to be done once after reset).    
N  * @note   Once the RTC clock is configured it can't be changed unless the RTC
N  *         is reset using RCC_BackupResetCmd function, or by a Power On Reset (POR)
N  *             
N  * @param  RCC_RTCCLKSource: specifies the RTC clock source.
N  *          This parameter can be one of the following values:
N  *            @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock
N  *            @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock
N  *            @arg RCC_RTCCLKSource_HSE_Div32: HSE divided by 32 selected as RTC clock
N  *       
N  * @note   If the LSE or LSI is used as RTC clock source, the RTC continues to
N  *         work in STOP and STANDBY modes, and can be used as wakeup source.
N  *         However, when the HSE clock is used as RTC clock source, the RTC
N  *         cannot be used in STOP and STANDBY modes.
N  *             
N  * @note   The maximum input clock frequency for RTC is 2MHz (when using HSE as
N  *         RTC clock source).
N  *                          
N  * @retval None
N  */
Nvoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
X  ((void)0);
N  
N  /* Select the RTC clock source */
N  RCC->BDCR |= RCC_RTCCLKSource;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->BDCR |= RCC_RTCCLKSource;
N}
N
N/**
N  * @brief  Enables or disables the RTC clock.
N  * @note   This function must be used only after the RTC clock source was selected
N  *         using the RCC_RTCCLKConfig function.
N  * @param  NewState: new state of the RTC clock.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_RTCCLKCmd(FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
X  *(volatile uint32_t *) (((uint32_t)0x42000000) + (((((((uint32_t)0x40000000) + 0x00020000) + 0x1000) - ((uint32_t)0x40000000)) + 0x20) * 32) + (0x0F * 4)) = (uint32_t)NewState;
N}
N
N/**
N  * @brief  Forces or releases the Backup domain reset.
N  * @note   This function resets the RTC peripheral (including the backup registers)
N  *         and the RTC clock source selection in RCC_BDCR register.
N  * @param  NewState: new state of the Backup domain reset.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_BackupResetCmd(FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
X  *(volatile uint32_t *) (((uint32_t)0x42000000) + (((((((uint32_t)0x40000000) + 0x00020000) + 0x1000) - ((uint32_t)0x40000000)) + 0x20) * 32) + (0x10 * 4)) = (uint32_t)NewState;
N}
N
N/**
N  * @brief  Enables or disables the AHB peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.    
N  * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.
N  *          This parameter can be any combination of the following values:
N  *             @arg RCC_AHBPeriph_GPIOA: GPIOA clock
N  *             @arg RCC_AHBPeriph_GPIOB: GPIOB clock
N  *             @arg RCC_AHBPeriph_GPIOC: GPIOC clock
N  *             @arg RCC_AHBPeriph_GPIOD: GPIOD clock
N  *             @arg RCC_AHBPeriph_GPIOE: GPIOE clock
N  *             @arg RCC_AHBPeriph_GPIOF: GPIOF clock
N  *             @arg RCC_AHBPeriph_TS:    TS clock
N  *             @arg RCC_AHBPeriph_CRC:   CRC clock
N  *             @arg RCC_AHBPeriph_FLITF: (has effect only when the Flash memory is in power down mode)  
N  *             @arg RCC_AHBPeriph_SRAM:  SRAM clock
N  *             @arg RCC_AHBPeriph_DMA2:  DMA2 clock
N  *             @arg RCC_AHBPeriph_DMA1:  DMA1 clock
N  * @param  NewState: new state of the specified peripheral clock.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    RCC->AHBENR |= RCC_AHBPeriph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->AHBENR |= RCC_AHBPeriph;
N  }
N  else
N  {
N    RCC->AHBENR &= ~RCC_AHBPeriph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->AHBENR &= ~RCC_AHBPeriph;
N  }
N}
N
N/**
N  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.
N  *          This parameter can be any combination of the following values:
N  *             @arg RCC_APB2Periph_SYSCFG:      SYSCFG clock
N  *             @arg RCC_APB2Periph_ADC1:        ADC1 clock
N  *             @arg RCC_APB2Periph_SPI1:        SPI1 clock
N  *             @arg RCC_APB2Periph_USART1:      USART1 clock
N  *             @arg RCC_APB2Periph_TIM15:       TIM15 clock
N  *             @arg RCC_APB2Periph_TIM16:       TIM16 clock
N  *             @arg RCC_APB2Periph_TIM17:       TIM17 clock
N  *             @arg RCC_APB2Periph_TIM19:       TIM19 clock
N  *             @arg RCC_APB2Periph_SDADC1:      SDADC1 clock
N  *             @arg RCC_APB2Periph_SDADC2:      SDADC2 clock
N  *             @arg RCC_APB2Periph_SDADC3:      SDADC3 clock
N  * @param  NewState: new state of the specified peripheral clock.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    RCC->APB2ENR |= RCC_APB2Periph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->APB2ENR |= RCC_APB2Periph;
N  }
N  else
N  {
N    RCC->APB2ENR &= ~RCC_APB2Periph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->APB2ENR &= ~RCC_APB2Periph;
N  }
N}
N
N/**
N  * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.
N  * @note   After reset, the peripheral clock (used for registers read/write access)
N  *         is disabled and the application software has to enable this clock before 
N  *         using it.
N  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.
N  *          This parameter can be any combination of the following values:
N  *           @arg RCC_APB1Periph_TIM2:      TIM2 clock
N  *           @arg RCC_APB1Periph_TIM3:      TIM3 clock
N  *           @arg RCC_APB1Periph_TIM4:      TIM4 clock
N  *           @arg RCC_APB1Periph_TIM5:      TIM5 clock
N  *           @arg RCC_APB1Periph_TIM6:      TIM6 clock
N  *           @arg RCC_APB1Periph_TIM7:      TIM7 clock
N  *           @arg RCC_APB1Periph_TIM12:     TIM12 clock
N  *           @arg RCC_APB1Periph_TIM13:     TIM13 clock
N  *           @arg RCC_APB1Periph_TIM14:     TIM14 clock
N  *           @arg RCC_APB1Periph_TIM18:     TIM18 clock
N  *           @arg RCC_APB1Periph_WWDG:      WWDG clock
N  *           @arg RCC_APB1Periph_SPI2:      SPI2 clock
N  *           @arg RCC_APB1Periph_SPI3:      SPI3 clock
N  *           @arg RCC_APB1Periph_USART2:    USART2 clock
N  *           @arg RCC_APB1Periph_USART3:    USART3 clock
N  *           @arg RCC_APB1Periph_I2C1:      I2C1 clock
N  *           @arg RCC_APB1Periph_I2C2:      I2C2 clock
N  *           @arg RCC_APB1Periph_USB:       USB clock
N  *           @arg RCC_APB1Periph_CAN1:      CAN1 clock
N  *           @arg RCC_APB1Periph_DAC2:      DAC2 clock
N  *           @arg RCC_APB1Periph_PWR:       PWR clock
N  *           @arg RCC_APB1Periph_DAC1:      DAC1 clock
N  *           @arg RCC_APB1Periph_CEC:       CEC clock
N  * @param  NewState: new state of the specified peripheral clock.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    RCC->APB1ENR |= RCC_APB1Periph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->APB1ENR |= RCC_APB1Periph;
N  }
N  else
N  {
N    RCC->APB1ENR &= ~RCC_APB1Periph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->APB1ENR &= ~RCC_APB1Periph;
N  }
N}
N
N/**
N  * @brief  Forces or releases AHB peripheral reset.
N  * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.
N  *          This parameter can be any combination of the following values:
N  *             @arg RCC_AHBPeriph_GPIOA:         GPIOA clock
N  *             @arg RCC_AHBPeriph_GPIOB:         GPIOB clock
N  *             @arg RCC_AHBPeriph_GPIOC:         GPIOC clock
N  *             @arg RCC_AHBPeriph_GPIOD:         GPIOD clock
N  *             @arg RCC_AHBPeriph_GPIOE:         GPIOE clock
N  *             @arg RCC_AHBPeriph_GPIOF:         GPIOF clock
N  *             @arg RCC_AHBPeriph_TS:            TS clock
N  * @param  NewState: new state of the specified peripheral reset.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    RCC->AHBRSTR |= RCC_AHBPeriph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->AHBRSTR |= RCC_AHBPeriph;
N  }
N  else
N  {
N    RCC->AHBRSTR &= ~RCC_AHBPeriph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->AHBRSTR &= ~RCC_AHBPeriph;
N  }
N}
N
N/**
N  * @brief  Forces or releases High Speed APB (APB2) peripheral reset.
N  * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.
N  *          This parameter can be any combination of the following values:
N  *             @arg RCC_APB2Periph_SYSCFG:      SYSCFG clock
N  *             @arg RCC_APB2Periph_ADC1:        ADC1 clock
N  *             @arg RCC_APB2Periph_SPI1:        SPI1 clock
N  *             @arg RCC_APB2Periph_USART1:      USART1 clock
N  *             @arg RCC_APB2Periph_TIM15:       TIM15 clock
N  *             @arg RCC_APB2Periph_TIM16:       TIM16 clock
N  *             @arg RCC_APB2Periph_TIM17:       TIM17 clock
N  *             @arg RCC_APB2Periph_TIM19:       TIM19 clock
N  *             @arg RCC_APB2Periph_SDADC1:      SDADC1 clock
N  *             @arg RCC_APB2Periph_SDADC2:      SDADC2 clock
N  *             @arg RCC_APB2Periph_SDADC3:      SDADC3 clock
N  * @param  NewState: new state of the specified peripheral reset.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    RCC->APB2RSTR |= RCC_APB2Periph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->APB2RSTR |= RCC_APB2Periph;
N  }
N  else
N  {
N    RCC->APB2RSTR &= ~RCC_APB2Periph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->APB2RSTR &= ~RCC_APB2Periph;
N  }
N}
N
N/**
N  * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.
N  * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.
N  *          This parameter can be any combination of the following values:
N  *           @arg RCC_APB1Periph_TIM2:      TIM2 clock
N  *           @arg RCC_APB1Periph_TIM3:      TIM3 clock
N  *           @arg RCC_APB1Periph_TIM4:      TIM4 clock
N  *           @arg RCC_APB1Periph_TIM5:      TIM5 clock  
N  *           @arg RCC_APB1Periph_TIM6:      TIM6 clock
N  *           @arg RCC_APB1Periph_TIM7:      TIM7 clock
N  *           @arg RCC_APB1Periph_TIM12:     TIM12 clock
N  *           @arg RCC_APB1Periph_TIM13:     TIM13 clock
N  *           @arg RCC_APB1Periph_TIM14:     TIM14 clock
N  *           @arg RCC_APB1Periph_TIM18:     TIM18 clock
N  *           @arg RCC_APB1Periph_WWDG:      WWDG clock
N  *           @arg RCC_APB1Periph_SPI2:      SPI2 clock
N  *           @arg RCC_APB1Periph_SPI3:      SPI3 clock
N  *           @arg RCC_APB1Periph_USART2:    USART2 clock
N  *           @arg RCC_APB1Periph_USART3:    USART3 clock
N  *           @arg RCC_APB1Periph_I2C1:      I2C1 clock
N  *           @arg RCC_APB1Periph_I2C2:      I2C2 clock
N  *           @arg RCC_APB1Periph_USB:       USB clock
N  *           @arg RCC_APB1Periph_CAN1:      CAN1 clock
N  *           @arg RCC_APB1Periph_DAC2:      DAC2 clock
N  *           @arg RCC_APB1Periph_PWR:       PWR clock
N  *           @arg RCC_APB1Periph_DAC1:      DAC1 clock
N  *           @arg RCC_APB1Periph_CEC:       CEC clock
N  * @param  NewState: new state of the specified peripheral clock.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    RCC->APB1RSTR |= RCC_APB1Periph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->APB1RSTR |= RCC_APB1Periph;
N  }
N  else
N  {
N    RCC->APB1RSTR &= ~RCC_APB1Periph;
X    ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->APB1RSTR &= ~RCC_APB1Periph;
N  }
N}
N
N/**
N  * @}
N  */
N
N/** @defgroup RCC_Group4 Interrupts and flags management functions
N *  @brief   Interrupts and flags management functions 
N *
N@verbatim
N ===============================================================================
N             ##### Interrupts and flags management functions #####
N ===============================================================================
N@endverbatim
N  * @{
N  */
N
N/**
N  * @brief  Enables or disables the specified RCC interrupts.
N  * @note   The CSS interrupt doesn't have an enable bit; once the CSS is enabled
N  *         and if the HSE clock fails, the CSS interrupt occurs and an NMI is
N  *         automatically generated. The NMI will be executed indefinitely, and 
N  *         since NMI has higher priority than any other IRQ (and main program)
N  *         the application will be stacked in the NMI ISR unless the CSS interrupt
N  *         pending bit is cleared.
N  * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.
N  *          This parameter can be any combination of the following values:
N  *             @arg RCC_IT_LSIRDY: LSI ready interrupt
N  *             @arg RCC_IT_LSERDY: LSE ready interrupt
N  *             @arg RCC_IT_HSIRDY: HSI ready interrupt
N  *             @arg RCC_IT_HSERDY: HSE ready interrupt
N  *             @arg RCC_IT_PLLRDY: PLL ready interrupt
N  * @param  NewState: new state of the specified RCC interrupts.
N  *          This parameter can be: ENABLE or DISABLE.
N  * @retval None
N  */
Nvoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_IT(RCC_IT));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
N    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
X    *(volatile uint8_t *) ((uint32_t)0x40021009) |= RCC_IT;
N  }
N  else
N  {
N    /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
N    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
X    *(volatile uint8_t *) ((uint32_t)0x40021009) &= (uint8_t)~RCC_IT;
N  }
N}
N
N/**
N  * @brief  Checks whether the specified RCC flag is set or not.
N  * @param  RCC_FLAG: specifies the flag to check.
N  *          This parameter can be one of the following values:
N  *             @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready  
N  *             @arg RCC_FLAG_HSERDY: HSE oscillator clock ready
N  *             @arg RCC_FLAG_PLLRDY: PLL clock ready
N  *             @arg RCC_FLAG_LSERDY: LSE oscillator clock ready
N  *             @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready
N  *             @arg RCC_FLAG_OBLRST: Option Byte Loader (OBL) reset 
N  *             @arg RCC_FLAG_PINRST: Pin reset
N  *             @arg RCC_FLAG_V18PWRRSTF: Voltage regulator reset
N  *             @arg RCC_FLAG_PORRST: POR/PDR reset
N  *             @arg RCC_FLAG_SFTRST: Software reset
N  *             @arg RCC_FLAG_IWDGRST: Independent Watchdog reset
N  *             @arg RCC_FLAG_WWDGRST: Window Watchdog reset
N  *             @arg RCC_FLAG_LPWRRST: Low Power reset
N  * @retval The new state of RCC_FLAG (SET or RESET).
N  */
NFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
N{
N  uint32_t tmp = 0;
N  uint32_t statusreg = 0;
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_RCC_FLAG(RCC_FLAG));
X  ((void)0);
N
N  /* Get the RCC register index */
N  tmp = RCC_FLAG >> 5;
N
N   if (tmp == 0)               /* The flag to check is in CR register */
N  {
N    statusreg = RCC->CR;
X    statusreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CR;
N  }
N  else if (tmp == 1)          /* The flag to check is in BDCR register */
N  {
N    statusreg = RCC->BDCR;
X    statusreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->BDCR;
N  }
N  else                       /* The flag to check is in CSR register */
N  {
N    statusreg = RCC->CSR;
X    statusreg = ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CSR;
N  }
N
N  /* Get the flag position */
N  tmp = RCC_FLAG & FLAG_MASK;
X  tmp = RCC_FLAG & ((uint8_t)0x1F);
N
N  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  /* Return the flag status */
N  return bitstatus;
N}
N
N/**
N  * @brief  Clears the RCC reset flags.
N  *         The reset flags are: RCC_FLAG_OBLRST, RCC_FLAG_PINRST, RCC_FLAG_PORRST, 
N  *         RCC_FLAG_SFTRST, RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST, RCC_FLAG_V18PWRRSTF.
N  * @param  None
N  * @retval None
N  */
Nvoid RCC_ClearFlag(void)
N{
N  /* Set RMVF bit to clear the reset flags */
N  RCC->CSR |= RCC_CSR_RMVF;
X  ((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CSR |= ((uint32_t)0x01000000);
N}
N
N/**
N  * @brief  Checks whether the specified RCC interrupt has occurred or not.
N  * @param  RCC_IT: specifies the RCC interrupt source to check.
N  *          This parameter can be one of the following values:
N  *             @arg RCC_IT_LSIRDY: LSI ready interrupt
N  *             @arg RCC_IT_LSERDY: LSE ready interrupt
N  *             @arg RCC_IT_HSIRDY: HSI ready interrupt
N  *             @arg RCC_IT_HSERDY: HSE ready interrupt
N  *             @arg RCC_IT_PLLRDY: PLL ready interrupt
N  *             @arg RCC_IT_CSS: Clock Security System interrupt
N  * @retval The new state of RCC_IT (SET or RESET).
N  */
NITStatus RCC_GetITStatus(uint8_t RCC_IT)
N{
N  ITStatus bitstatus = RESET;
N  
N  /* Check the parameters */
N  assert_param(IS_RCC_GET_IT(RCC_IT));
X  ((void)0);
N  
N  /* Check the status of the specified RCC interrupt */
N  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
X  if ((((RCC_TypeDef *) ((((uint32_t)0x40000000) + 0x00020000) + 0x1000))->CIR & RCC_IT) != (uint32_t)RESET)
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  /* Return the RCC_IT status */
N  return  bitstatus;
N}
N
N/**
N  * @brief  Clears the RCC's interrupt pending bits.
N  * @param  RCC_IT: specifies the interrupt pending bit to clear.
N  *          This parameter can be any combination of the following values:
N  *             @arg RCC_IT_LSIRDY: LSI ready interrupt
N  *             @arg RCC_IT_LSERDY: LSE ready interrupt
N  *             @arg RCC_IT_HSIRDY: HSI ready interrupt
N  *             @arg RCC_IT_HSERDY: HSE ready interrupt
N  *             @arg RCC_IT_PLLRDY: PLL ready interrupt
N  *             @arg RCC_IT_CSS: Clock Security System interrupt
N  * @retval None
N  */
Nvoid RCC_ClearITPendingBit(uint8_t RCC_IT)
N{
N  /* Check the parameters */
N  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
X  ((void)0);
N  
N  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
N     pending bits */
N  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
X  *(volatile uint8_t *) ((uint32_t)0x4002100A) = RCC_IT;
N}
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/**
N  * @}
N  */
N
N/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
