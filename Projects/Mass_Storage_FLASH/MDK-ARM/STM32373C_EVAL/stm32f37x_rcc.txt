; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32373c_eval\stm32f37x_rcc.o --asm_dir=.\STM32373C_EVAL\ --list_dir=.\STM32373C_EVAL\ --depend=.\stm32373c_eval\stm32f37x_rcc.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32373C_EVAL -IE:\STM32F373_USB_BootLoader\Projects\Mass_Storage_FLASH\MDK-ARM\RTE -ID:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -ID:\MDK\install\ARM\PACK\Keil\STM32F3xx_DFP\1.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F37X -DUSE_STDPERIPH_DRIVER -DSTM32F37X -DUSE_STM32373C_EVAL --omf_browse=.\stm32373c_eval\stm32f37x_rcc.crf ..\..\..\Libraries\STM32F37x_StdPeriph_Driver\src\stm32f37x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;757      */
;;;758    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  4904              LDR      r1,|L1.20|
;;;759    {
;;;760     
;;;761      /* Check the parameters */
;;;762      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;763      
;;;764      /* Clear ADCPRE[1:0] bits */
;;;765      RCC->CFGR &= ~RCC_CFGR_ADCPRE;
000002  684a              LDR      r2,[r1,#4]
000004  f4224240          BIC      r2,r2,#0xc000
000008  604a              STR      r2,[r1,#4]
;;;766      
;;;767      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;768      RCC->CFGR |= RCC_PCLK2;
00000a  684a              LDR      r2,[r1,#4]
00000c  4302              ORRS     r2,r2,r0
00000e  604a              STR      r2,[r1,#4]
;;;769    }
000010  4770              BX       lr
;;;770    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1243     */
;;;1244   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1245   {
;;;1246     /* Check the parameters */
;;;1247     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1248     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1249     
;;;1250     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1251     {
;;;1252       RCC->AHBENR |= RCC_AHBPeriph;
;;;1253     }
;;;1254     else
;;;1255     {
;;;1256       RCC->AHBENR &= ~RCC_AHBPeriph;
000004  6951              LDR      r1,[r2,#0x14]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1252
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6151              STR      r1,[r2,#0x14]         ;1252
;;;1257     }
;;;1258   }
000010  4770              BX       lr
;;;1259   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphResetCmd PROC
;;;1362     */
;;;1363   void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1364   {
;;;1365     /* Check the parameters */
;;;1366     assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
;;;1367     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1368   
;;;1369     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1370     {
;;;1371       RCC->AHBRSTR |= RCC_AHBPeriph;
;;;1372     }
;;;1373     else
;;;1374     {
;;;1375       RCC->AHBRSTR &= ~RCC_AHBPeriph;
000004  6a91              LDR      r1,[r2,#0x28]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1371
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  6291              STR      r1,[r2,#0x28]         ;1371
;;;1376     }
;;;1377   }
000010  4770              BX       lr
;;;1378   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1331     */
;;;1332   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1333   {
;;;1334     /* Check the parameters */
;;;1335     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1336     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1337   
;;;1338     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1339     {
;;;1340       RCC->APB1ENR |= RCC_APB1Periph;
;;;1341     }
;;;1342     else
;;;1343     {
;;;1344       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1340
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  61d1              STR      r1,[r2,#0x1c]         ;1340
;;;1345     }
;;;1346   }
000010  4770              BX       lr
;;;1347   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1444     */
;;;1445   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1446   {
;;;1447     /* Check the parameters */
;;;1448     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1449     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1450   
;;;1451     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1452     {
;;;1453       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1454     }
;;;1455     else
;;;1456     {
;;;1457       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1453
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6111              STR      r1,[r2,#0x10]         ;1453
;;;1458     }
;;;1459   }
000010  4770              BX       lr
;;;1460   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1281     */
;;;1282   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1283   {
;;;1284     /* Check the parameters */
;;;1285     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1286     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1287   
;;;1288     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1289     {
;;;1290       RCC->APB2ENR |= RCC_APB2Periph;
;;;1291     }
;;;1292     else
;;;1293     {
;;;1294       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6991              LDR      r1,[r2,#0x18]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1290
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6191              STR      r1,[r2,#0x18]         ;1290
;;;1295     }
;;;1296   }
000010  4770              BX       lr
;;;1297   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1397     */
;;;1398   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;1399   {
;;;1400     /* Check the parameters */
;;;1401     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1402     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1403   
;;;1404     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1405     {
;;;1406       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1407     }
;;;1408     else
;;;1409     {
;;;1410       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  68d1              LDR      r1,[r2,#0xc]
000006  d001              BEQ      |L7.12|
000008  4301              ORRS     r1,r1,r0              ;1406
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4381              BICS     r1,r1,r0
                  |L7.14|
00000e  60d1              STR      r1,[r2,#0xc]          ;1406
;;;1411     }
;;;1412   }
000010  4770              BX       lr
;;;1413   
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;290      */
;;;291    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L8.16|
;;;292    {
;;;293      uint32_t tmpreg = 0;
;;;294      
;;;295      /* Check the parameters */
;;;296      assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
;;;297      
;;;298      tmpreg = RCC->CR;
000002  680a              LDR      r2,[r1,#0]
;;;299      
;;;300      /* Clear HSITRIM[4:0] bits */
;;;301      tmpreg &= ~RCC_CR_HSITRIM;
000004  f02202f8          BIC      r2,r2,#0xf8
;;;302      
;;;303      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;304      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;305      
;;;306      /* Store the new value */
;;;307      RCC->CR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;308    }
00000e  4770              BX       lr
;;;309    
                          ENDP

                  |L8.16|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1212     */
;;;1213   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L9.8|
;;;1214   {
;;;1215     /* Check the parameters */
;;;1216     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1217     
;;;1218     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1219   }
000004  4770              BX       lr
;;;1220   
                          ENDP

000006  0000              DCW      0x0000
                  |L9.8|
                          DCD      0x42420440

                          AREA ||i.RCC_CECCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_CECCLKConfig PROC
;;;814      */
;;;815    void RCC_CECCLKConfig(uint32_t RCC_CECCLK)
000000  4904              LDR      r1,|L10.20|
;;;816    { 
;;;817      /* Check the parameters */
;;;818      assert_param(IS_RCC_CECCLK(RCC_CECCLK));
;;;819    
;;;820      /* Clear CECSW bit */
;;;821      RCC->CFGR3 &= ~RCC_CFGR3_CECSW;
000002  6b0a              LDR      r2,[r1,#0x30]
000004  f0220240          BIC      r2,r2,#0x40
000008  630a              STR      r2,[r1,#0x30]
;;;822      /* Set CECSW bits according to RCC_CECCLK value */
;;;823      RCC->CFGR3 |= RCC_CECCLK;
00000a  6b0a              LDR      r2,[r1,#0x30]
00000c  4302              ORRS     r2,r2,r0
00000e  630a              STR      r2,[r1,#0x30]
;;;824    }
000010  4770              BX       lr
;;;825    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1578     */
;;;1579   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L11.12|
;;;1580   {
;;;1581     /* Set RMVF bit to clear the reset flags */
;;;1582     RCC->CSR |= RCC_CSR_RMVF;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;1583   }
00000a  4770              BX       lr
;;;1584   
                          ENDP

                  |L11.12|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1628     */
;;;1629   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L12.8|
;;;1630   {
;;;1631     /* Check the parameters */
;;;1632     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1633     
;;;1634     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1635        pending bits */
;;;1636     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1637   }
000004  4770              BX       lr
;;;1638   
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;491      */
;;;492    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L13.8|
;;;493    {
;;;494      /* Check the parameters */
;;;495      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;496      
;;;497      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;498    }
000004  4770              BX       lr
;;;499    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;186      */
;;;187    void RCC_DeInit(void)
000000  480f              LDR      r0,|L14.64|
;;;188    {
;;;189      /* Set HSION bit */
;;;190      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;191    
;;;192      /* Reset SW[1:0], HPRE[3:0], PPRE[2:0], ADCPRE, SDADCPRE and MCOSEL[2:0] bits */
;;;193      RCC->CFGR &= (uint32_t)0x00FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  f401017f          AND      r1,r1,#0xff0000
000010  6041              STR      r1,[r0,#4]
;;;194      
;;;195      /* Reset HSEON, CSSON and PLLON bits */
;;;196      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4a0b              LDR      r2,|L14.68|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;197    
;;;198      /* Reset HSEBYP bit */
;;;199      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;200    
;;;201      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
;;;202      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000022  6841              LDR      r1,[r0,#4]
000024  f42101fe          BIC      r1,r1,#0x7f0000
000028  6041              STR      r1,[r0,#4]
;;;203    
;;;204      /* Reset PREDIV1[3:0] bits */
;;;205      RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
00002a  6ac1              LDR      r1,[r0,#0x2c]
00002c  f021010f          BIC      r1,r1,#0xf
000030  62c1              STR      r1,[r0,#0x2c]
;;;206    
;;;207      /* Reset USARTSW[1:0], I2CSW and CECSW bits */
;;;208      RCC->CFGR3 &= (uint32_t)0xFFF0F8C;
000032  6b01              LDR      r1,[r0,#0x30]
000034  4a04              LDR      r2,|L14.72|
000036  4011              ANDS     r1,r1,r2
000038  6301              STR      r1,[r0,#0x30]
;;;209      
;;;210      /* Disable all interrupts */
;;;211      RCC->CIR = 0x00000000;
00003a  2100              MOVS     r1,#0
00003c  6081              STR      r1,[r0,#8]
;;;212    }
00003e  4770              BX       lr
;;;213    
                          ENDP

                  |L14.64|
                          DCD      0x40021000
                  |L14.68|
                          DCD      0xfef6ffff
                  |L14.72|
                          DCD      0x0fff0f8c

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;952      */
;;;953    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b5f0              PUSH     {r4-r7,lr}
;;;954    {
;;;955      uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0;
;;;956    
;;;957      /* Get SYSCLK source -------------------------------------------------------*/
;;;958      tmp = RCC->CFGR & RCC_CFGR_SWS;
000002  495c              LDR      r1,|L15.372|
000004  684a              LDR      r2,[r1,#4]
;;;959      
;;;960      switch (tmp)
;;;961      {
;;;962        case 0x00:  /* HSI used as system clock */
;;;963          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000006  4e5c              LDR      r6,|L15.376|
000008  f012020c          ANDS     r2,r2,#0xc            ;958
00000c  d004              BEQ      |L15.24|
;;;964          break;
;;;965        case 0x04:  /* HSE used as system clock */
;;;966          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
00000e  0074              LSLS     r4,r6,#1
000010  2a04              CMP      r2,#4                 ;960
000012  d003              BEQ      |L15.28|
000014  2a08              CMP      r2,#8                 ;960
000016  d003              BEQ      |L15.32|
                  |L15.24|
000018  6006              STR      r6,[r0,#0]            ;964
00001a  e014              B        |L15.70|
                  |L15.28|
;;;967          break;
00001c  6004              STR      r4,[r0,#0]
00001e  e012              B        |L15.70|
                  |L15.32|
;;;968        case 0x08:  /* PLL used as system clock */
;;;969          /* Get PLL clock source and multiplication factor ----------------------*/
;;;970          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
000020  684a              LDR      r2,[r1,#4]
;;;971          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000022  684b              LDR      r3,[r1,#4]
000024  f4021270          AND      r2,r2,#0x3c0000       ;970
;;;972          pllmull = ( pllmull >> 18) + 2;
000028  f04f0502          MOV      r5,#2
00002c  f4133f80          TST      r3,#0x10000           ;971
000030  eb054292          ADD      r2,r5,r2,LSR #18
;;;973          
;;;974          if (pllsource == 0x00)
000034  d03d              BEQ      |L15.178|
;;;975          {
;;;976            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;977            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;978          }
;;;979          else
;;;980          {
;;;981            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
000036  6acb              LDR      r3,[r1,#0x2c]
000038  f003030f          AND      r3,r3,#0xf
00003c  1c5b              ADDS     r3,r3,#1
;;;982            /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;983            RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
00003e  fbb4f3f3          UDIV     r3,r4,r3
000042  4353              MULS     r3,r2,r3
000044  6003              STR      r3,[r0,#0]
                  |L15.70|
;;;984          }      
;;;985          break;
;;;986        default: /* HSI used as system clock */
;;;987          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;988          break;
;;;989      }
;;;990      /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
;;;991      /* Get HCLK prescaler */
;;;992      tmp = RCC->CFGR & RCC_CFGR_HPRE;
000046  684a              LDR      r2,[r1,#4]
;;;993      tmp = tmp >> 4;
;;;994      presc = APBAHBPrescTable[tmp]; 
;;;995      /* HCLK clock frequency */
;;;996      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;997    
;;;998      /* Get PCLK1 prescaler */
;;;999      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;1000     tmp = tmp >> 8;
;;;1001     presc = APBAHBPrescTable[tmp];
;;;1002     /* PCLK1 clock frequency */
;;;1003     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1004     
;;;1005     /* Get PCLK2 prescaler */
;;;1006     tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;1007     tmp = tmp >> 11;
;;;1008     presc = APBAHBPrescTable[tmp];
;;;1009     /* PCLK2 clock frequency */
;;;1010     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;1011     
;;;1012     /* Get ADCCLK prescaler */
;;;1013     tmp = RCC->CFGR & RCC_CFGR_ADCPRE;
;;;1014     tmp = tmp >> 14;
;;;1015     presc = ADCPrescTable[tmp];
;;;1016     /* ADCCLK clock frequency */
;;;1017     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
;;;1018     
;;;1019     /* Get SDADCCLK prescaler */
;;;1020     tmp = RCC->CFGR & RCC_CFGR_SDADCPRE;
;;;1021     tmp = (tmp >> 27) & 0x0F;
;;;1022     presc = SDADCPrescTable[tmp];
;;;1023     /* ADCCLK clock frequency */
;;;1024     RCC_Clocks->SDADCCLK_Frequency = RCC_Clocks->SYSCLK_Frequency / presc;
;;;1025     
;;;1026     /* CECCLK clock frequency */
;;;1027     if((RCC->CFGR3 & RCC_CFGR3_CECSW) != RCC_CFGR3_CECSW)
;;;1028     {
;;;1029       /* CEC Clock is HSI/244 */
;;;1030       RCC_Clocks->CECCLK_Frequency = HSI_VALUE / 244;
;;;1031     }
;;;1032     else
;;;1033     {
;;;1034       /* CECC Clock is LSE Osc. */
;;;1035       RCC_Clocks->CECCLK_Frequency = LSE_VALUE;
;;;1036     }
;;;1037     
;;;1038     /* I2C1CLK clock frequency */
;;;1039     if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
;;;1040     {
;;;1041       /* I2C1 Clock is HSI Osc. */
;;;1042       RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
;;;1043     }
;;;1044     else
;;;1045     {
;;;1046       /* I2C1 Clock is System Clock */
;;;1047       RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1048     }
;;;1049   
;;;1050     /* I2C2CLK clock frequency */
;;;1051     if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
;;;1052     {
;;;1053       /* I2C2 Clock is HSI Osc. */
;;;1054       RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
;;;1055     }
;;;1056     else
;;;1057     {
;;;1058       /* I2C2 Clock is System Clock */
;;;1059       RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1060     }
;;;1061   
;;;1062     /* USART1CLK clock frequency */
;;;1063     if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
;;;1064     {
;;;1065       /* USART Clock is PCLK */
;;;1066       RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
;;;1067     }
;;;1068     else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
;;;1069     {
;;;1070       /* USART Clock is System Clock */
;;;1071       RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1072     }
;;;1073     else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
;;;1074     {
;;;1075       /* USART Clock is LSE Osc. */
;;;1076       RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
;;;1077     }
;;;1078     else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
;;;1079     {
;;;1080       /* USART Clock is HSI Osc. */
;;;1081       RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
;;;1082     }
;;;1083   
;;;1084     /* USART2CLK clock frequency */
;;;1085     if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
;;;1086     {
;;;1087       /* USART Clock is PCLK */
;;;1088       RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
;;;1089     }
;;;1090     else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
;;;1091     {
;;;1092       /* USART Clock is System Clock */
;;;1093       RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1094     }
;;;1095     else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
;;;1096     {
;;;1097       /* USART Clock is LSE Osc. */
;;;1098       RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
;;;1099     }
;;;1100     else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
;;;1101     {
;;;1102       /* USART Clock is HSI Osc. */
;;;1103       RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
;;;1104     }    
;;;1105   
;;;1106     /* USART3CLK clock frequency */
;;;1107     if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
;;;1108     {
;;;1109       /* USART Clock is PCLK */
;;;1110       RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
;;;1111     }
;;;1112     else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
;;;1113     {
;;;1114       /* USART Clock is System Clock */
;;;1115       RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
;;;1116     }
;;;1117     else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
;;;1118     {
;;;1119       /* USART Clock is LSE Osc. */
;;;1120       RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
;;;1121     }
;;;1122     else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
;;;1123     {
;;;1124       /* USART Clock is HSI Osc. */
;;;1125       RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
;;;1126     }  
;;;1127   }
000048  230f              MOVS     r3,#0xf
00004a  4f4c              LDR      r7,|L15.380|
00004c  ea031212          AND      r2,r3,r2,LSR #4
000050  5cbb              LDRB     r3,[r7,r2]            ;994
000052  6802              LDR      r2,[r0,#0]            ;996
000054  fa22f503          LSR      r5,r2,r3              ;996
000058  6045              STR      r5,[r0,#4]            ;999
00005a  684b              LDR      r3,[r1,#4]            ;999
00005c  2407              MOVS     r4,#7
00005e  ea042313          AND      r3,r4,r3,LSR #8
000062  f817c003          LDRB     r12,[r7,r3]           ;1001
000066  fa25f30c          LSR      r3,r5,r12             ;1003
00006a  6083              STR      r3,[r0,#8]            ;1006
00006c  f8d1c004          LDR      r12,[r1,#4]           ;1006
000070  ea0424dc          AND      r4,r4,r12,LSR #11
000074  5d3c              LDRB     r4,[r7,r4]            ;1008
000076  fa25f404          LSR      r4,r5,r4              ;1010
00007a  60c4              STR      r4,[r0,#0xc]          ;1013
00007c  684d              LDR      r5,[r1,#4]            ;1013
00007e  2703              MOVS     r7,#3
000080  ea073595          AND      r5,r7,r5,LSR #14
000084  4f3d              LDR      r7,|L15.380|
000086  1f3f              SUBS     r7,r7,#4              ;1015
000088  5d7d              LDRB     r5,[r7,r5]            ;1015
00008a  fbb4f5f5          UDIV     r5,r4,r5              ;1017
00008e  6105              STR      r5,[r0,#0x10]         ;1020
000090  684d              LDR      r5,[r1,#4]            ;1020
000092  3714              ADDS     r7,r7,#0x14           ;1022
000094  f3c565c3          UBFX     r5,r5,#27,#4          ;1021
000098  5d7d              LDRB     r5,[r7,r5]            ;1022
00009a  fbb2f5f5          UDIV     r5,r2,r5              ;1024
00009e  6145              STR      r5,[r0,#0x14]         ;1027
0000a0  6b0d              LDR      r5,[r1,#0x30]         ;1027
0000a2  066f              LSLS     r7,r5,#25             ;1027
0000a4  f44f4500          MOV      r5,#0x8000            ;1035
0000a8  d407              BMI      |L15.186|
0000aa  f2480712          MOV      r7,#0x8012            ;1030
0000ae  6187              STR      r7,[r0,#0x18]         ;1030
0000b0  e004              B        |L15.188|
                  |L15.178|
0000b2  4b33              LDR      r3,|L15.384|
0000b4  435a              MULS     r2,r3,r2              ;977
0000b6  6002              STR      r2,[r0,#0]            ;977
0000b8  e7c5              B        |L15.70|
                  |L15.186|
0000ba  6185              STR      r5,[r0,#0x18]         ;1035
                  |L15.188|
0000bc  6b0f              LDR      r7,[r1,#0x30]         ;1039
0000be  06ff              LSLS     r7,r7,#27             ;1039
0000c0  d401              BMI      |L15.198|
0000c2  61c6              STR      r6,[r0,#0x1c]         ;1042
0000c4  e000              B        |L15.200|
                  |L15.198|
0000c6  61c2              STR      r2,[r0,#0x1c]         ;1047
                  |L15.200|
0000c8  6b0f              LDR      r7,[r1,#0x30]         ;1051
0000ca  06bf              LSLS     r7,r7,#26             ;1051
0000cc  d401              BMI      |L15.210|
0000ce  6206              STR      r6,[r0,#0x20]         ;1054
0000d0  e000              B        |L15.212|
                  |L15.210|
0000d2  6202              STR      r2,[r0,#0x20]         ;1059
                  |L15.212|
0000d4  6b0f              LDR      r7,[r1,#0x30]         ;1063
0000d6  07bf              LSLS     r7,r7,#30             ;1063
0000d8  d00e              BEQ      |L15.248|
0000da  6b0c              LDR      r4,[r1,#0x30]         ;1068
0000dc  f0040403          AND      r4,r4,#3              ;1068
0000e0  2c01              CMP      r4,#1                 ;1068
0000e2  d00b              BEQ      |L15.252|
0000e4  6b0c              LDR      r4,[r1,#0x30]         ;1073
0000e6  f0040403          AND      r4,r4,#3              ;1073
0000ea  2c02              CMP      r4,#2                 ;1073
0000ec  d008              BEQ      |L15.256|
0000ee  6b0c              LDR      r4,[r1,#0x30]         ;1078
0000f0  43e4              MVNS     r4,r4                 ;1078
0000f2  07a4              LSLS     r4,r4,#30             ;1078
0000f4  d006              BEQ      |L15.260|
0000f6  e006              B        |L15.262|
                  |L15.248|
0000f8  6244              STR      r4,[r0,#0x24]         ;1066
0000fa  e004              B        |L15.262|
                  |L15.252|
0000fc  6242              STR      r2,[r0,#0x24]         ;1071
0000fe  e002              B        |L15.262|
                  |L15.256|
000100  6245              STR      r5,[r0,#0x24]         ;1076
000102  e000              B        |L15.262|
                  |L15.260|
000104  6246              STR      r6,[r0,#0x24]         ;1081
                  |L15.262|
000106  6b0c              LDR      r4,[r1,#0x30]         ;1085
000108  f4143f40          TST      r4,#0x30000           ;1085
00010c  d00f              BEQ      |L15.302|
00010e  6b0c              LDR      r4,[r1,#0x30]         ;1090
000110  f3c44401          UBFX     r4,r4,#16,#2          ;1090
000114  2c01              CMP      r4,#1                 ;1090
000116  d00c              BEQ      |L15.306|
000118  6b0c              LDR      r4,[r1,#0x30]         ;1095
00011a  f3c44401          UBFX     r4,r4,#16,#2          ;1095
00011e  2c02              CMP      r4,#2                 ;1095
000120  d009              BEQ      |L15.310|
000122  6b0c              LDR      r4,[r1,#0x30]         ;1100
000124  f3c44401          UBFX     r4,r4,#16,#2          ;1100
000128  2c03              CMP      r4,#3                 ;1100
00012a  d006              BEQ      |L15.314|
00012c  e006              B        |L15.316|
                  |L15.302|
00012e  6283              STR      r3,[r0,#0x28]         ;1088
000130  e004              B        |L15.316|
                  |L15.306|
000132  6282              STR      r2,[r0,#0x28]         ;1093
000134  e002              B        |L15.316|
                  |L15.310|
000136  6285              STR      r5,[r0,#0x28]         ;1098
000138  e000              B        |L15.316|
                  |L15.314|
00013a  6286              STR      r6,[r0,#0x28]         ;1103
                  |L15.316|
00013c  6b0c              LDR      r4,[r1,#0x30]         ;1107
00013e  f4142f40          TST      r4,#0xc0000           ;1107
000142  d010              BEQ      |L15.358|
000144  6b0b              LDR      r3,[r1,#0x30]         ;1112
000146  f3c34381          UBFX     r3,r3,#18,#2          ;1112
00014a  2b01              CMP      r3,#1                 ;1112
00014c  d00d              BEQ      |L15.362|
00014e  6b0a              LDR      r2,[r1,#0x30]         ;1117
000150  f3c24281          UBFX     r2,r2,#18,#2          ;1117
000154  2a02              CMP      r2,#2                 ;1117
000156  d00a              BEQ      |L15.366|
000158  6b09              LDR      r1,[r1,#0x30]         ;1122
00015a  f3c14181          UBFX     r1,r1,#18,#2          ;1122
00015e  2903              CMP      r1,#3                 ;1122
000160  d100              BNE      |L15.356|
000162  62c6              STR      r6,[r0,#0x2c]         ;1125
                  |L15.356|
000164  bdf0              POP      {r4-r7,pc}
                  |L15.358|
000166  62c3              STR      r3,[r0,#0x2c]         ;1110
000168  bdf0              POP      {r4-r7,pc}
                  |L15.362|
00016a  62c2              STR      r2,[r0,#0x2c]         ;1115
00016c  bdf0              POP      {r4-r7,pc}
                  |L15.366|
00016e  62c5              STR      r5,[r0,#0x2c]         ;1120
000170  bdf0              POP      {r4-r7,pc}
;;;1128   
                          ENDP

000172  0000              DCW      0x0000
                  |L15.372|
                          DCD      0x40021000
                  |L15.376|
                          DCD      0x007a1200
                  |L15.380|
                          DCD      ||.data||+0x4
                  |L15.384|
                          DCD      0x003d0900

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1531     */
;;;1532   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4602              MOV      r2,r0
;;;1533   {
;;;1534     uint32_t tmp = 0;
;;;1535     uint32_t statusreg = 0;
;;;1536     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1537   
;;;1538     /* Check the parameters */
;;;1539     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1540   
;;;1541     /* Get the RCC register index */
;;;1542     tmp = RCC_FLAG >> 5;
;;;1543   
;;;1544      if (tmp == 0)               /* The flag to check is in CR register */
;;;1545     {
;;;1546       statusreg = RCC->CR;
000004  4908              LDR      r1,|L16.40|
000006  0953              LSRS     r3,r2,#5              ;1542
000008  d00a              BEQ      |L16.32|
;;;1547     }
;;;1548     else if (tmp == 1)          /* The flag to check is in BDCR register */
00000a  2b01              CMP      r3,#1
00000c  d00a              BEQ      |L16.36|
;;;1549     {
;;;1550       statusreg = RCC->BDCR;
;;;1551     }
;;;1552     else                       /* The flag to check is in CSR register */
;;;1553     {
;;;1554       statusreg = RCC->CSR;
00000e  6a49              LDR      r1,[r1,#0x24]
                  |L16.16|
;;;1555     }
;;;1556   
;;;1557     /* Get the flag position */
;;;1558     tmp = RCC_FLAG & FLAG_MASK;
000010  f002021f          AND      r2,r2,#0x1f
;;;1559   
;;;1560     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000014  2301              MOVS     r3,#1
000016  4093              LSLS     r3,r3,r2
000018  420b              TST      r3,r1
00001a  d000              BEQ      |L16.30|
;;;1561     {
;;;1562       bitstatus = SET;
00001c  2001              MOVS     r0,#1
                  |L16.30|
;;;1563     }
;;;1564     else
;;;1565     {
;;;1566       bitstatus = RESET;
;;;1567     }
;;;1568     /* Return the flag status */
;;;1569     return bitstatus;
;;;1570   }
00001e  4770              BX       lr
                  |L16.32|
000020  6809              LDR      r1,[r1,#0]            ;1546
000022  e7f5              B        |L16.16|
                  |L16.36|
000024  6a09              LDR      r1,[r1,#0x20]         ;1550
000026  e7f3              B        |L16.16|
;;;1571   
                          ENDP

                  |L16.40|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1596     */
;;;1597   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L17.16|
;;;1598   {
000002  4601              MOV      r1,r0
;;;1599     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1600     
;;;1601     /* Check the parameters */
;;;1602     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1603     
;;;1604     /* Check the status of the specified RCC interrupt */
;;;1605     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L17.14|
;;;1606     {
;;;1607       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L17.14|
;;;1608     }
;;;1609     else
;;;1610     {
;;;1611       bitstatus = RESET;
;;;1612     }
;;;1613     /* Return the RCC_IT status */
;;;1614     return  bitstatus;
;;;1615   }
00000e  4770              BX       lr
;;;1616   
                          ENDP

                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;648      */
;;;649    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L18.12|
;;;650    {
;;;651      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;652    }
000008  4770              BX       lr
;;;653    
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;669      */
;;;670    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L19.16|
;;;671    {
;;;672      uint32_t tmpreg = 0;
;;;673      
;;;674      /* Check the parameters */
;;;675      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;676      
;;;677      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;678      
;;;679      /* Clear HPRE[3:0] bits */
;;;680      tmpreg &= ~RCC_CFGR_HPRE;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;681      
;;;682      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;683      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;684      
;;;685      /* Store the new value */
;;;686      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;687    }
00000c  4770              BX       lr
;;;688    
                          ENDP

00000e  0000              DCW      0x0000
                  |L19.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;233      */
;;;234    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  4902              LDR      r1,|L20.12|
;;;235    {
;;;236      /* Check the parameters */
;;;237      assert_param(IS_RCC_HSE(RCC_HSE));
;;;238    
;;;239      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;240      *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
000002  2200              MOVS     r2,#0
000004  708a              STRB     r2,[r1,#2]
;;;241    
;;;242      /* Set the new HSE configuration -------------------------------------------*/
;;;243      *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
000006  7088              STRB     r0,[r1,#2]
;;;244    
;;;245    }
000008  4770              BX       lr
;;;246    
                          ENDP

00000a  0000              DCW      0x0000
                  |L20.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;324      */
;;;325    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L21.8|
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;329      
;;;330      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;331    }
000004  4770              BX       lr
;;;332    
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x42420000

                          AREA ||i.RCC_I2CCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2CCLKConfig PROC
;;;835      */
;;;836    void RCC_I2CCLKConfig(uint32_t RCC_I2CCLK)
000000  4906              LDR      r1,|L22.28|
;;;837    { 
;;;838      uint32_t tmp = 0;
;;;839      
;;;840      /* Check the parameters */
;;;841      assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));
;;;842    
;;;843      tmp = (RCC_I2CCLK >> 28);
000002  0f02              LSRS     r2,r0,#28
;;;844      
;;;845      /* Clear I2CSW bit */
;;;846      if (tmp == 0)
;;;847      {
;;;848        RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
;;;849      }
;;;850      else
;;;851      {
;;;852        RCC->CFGR3 &= ~RCC_CFGR3_I2C2SW;
000004  6b0a              LDR      r2,[r1,#0x30]
000006  d006              BEQ      |L22.22|
000008  f0220220          BIC      r2,r2,#0x20
                  |L22.12|
00000c  630a              STR      r2,[r1,#0x30]
;;;853      }
;;;854      /* Set I2CSW bits according to RCC_I2CCLK value */
;;;855      RCC->CFGR3 |= RCC_I2CCLK;
00000e  6b0a              LDR      r2,[r1,#0x30]
000010  4302              ORRS     r2,r2,r0
000012  630a              STR      r2,[r1,#0x30]
;;;856    }
000014  4770              BX       lr
                  |L22.22|
000016  f0220210          BIC      r2,r2,#0x10           ;848
00001a  e7f7              B        |L22.12|
;;;857    
                          ENDP

                  |L22.28|
                          DCD      0x40021000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1494     */
;;;1495   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L23.20|
;;;1496   {
;;;1497     /* Check the parameters */
;;;1498     assert_param(IS_RCC_IT(RCC_IT));
;;;1499     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1500     
;;;1501     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1502     {
;;;1503       /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
;;;1504       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;1505     }
;;;1506     else
;;;1507     {
;;;1508       /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
;;;1509       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7a51              LDRB     r1,[r2,#9]
000006  d001              BEQ      |L23.12|
000008  4301              ORRS     r1,r1,r0              ;1504
00000a  e000              B        |L23.14|
                  |L23.12|
00000c  4381              BICS     r1,r1,r0
                  |L23.14|
00000e  7251              STRB     r1,[r2,#9]            ;1504
;;;1510     }
;;;1511   }
000010  4770              BX       lr
;;;1512   
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;349      */
;;;350    void RCC_LSEConfig(uint32_t RCC_LSE)
000000  4906              LDR      r1,|L24.28|
;;;351    {
;;;352      /* Check the parameters */
;;;353      assert_param(IS_RCC_LSE(RCC_LSE));
;;;354    
;;;355      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;356      /* Reset LSEON bit */
;;;357      RCC->BDCR &= ~(RCC_BDCR_LSEON);
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  620a              STR      r2,[r1,#0x20]
;;;358    
;;;359      /* Reset LSEBYP bit */
;;;360      RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  f0220204          BIC      r2,r2,#4
000010  620a              STR      r2,[r1,#0x20]
;;;361    
;;;362      /* Configure LSE */
;;;363      RCC->BDCR |= RCC_LSE;
000012  6a0a              LDR      r2,[r1,#0x20]
000014  4302              ORRS     r2,r2,r0
000016  620a              STR      r2,[r1,#0x20]
;;;364    }
000018  4770              BX       lr
;;;365    
                          ENDP

00001a  0000              DCW      0x0000
                  |L24.28|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEDriveConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEDriveConfig PROC
;;;375      */
;;;376    void RCC_LSEDriveConfig(uint32_t RCC_LSEDrive)
000000  4904              LDR      r1,|L25.20|
;;;377    {
;;;378      /* Check the parameters */
;;;379      assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
;;;380      
;;;381      /* Clear LSEDRV[1:0] bits */
;;;382      RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
000002  6a0a              LDR      r2,[r1,#0x20]
000004  f0220218          BIC      r2,r2,#0x18
000008  620a              STR      r2,[r1,#0x20]
;;;383    
;;;384      /* Set the LSE Drive */
;;;385      RCC->BDCR |= RCC_LSEDrive;
00000a  6a0a              LDR      r2,[r1,#0x20]
00000c  4302              ORRS     r2,r2,r0
00000e  620a              STR      r2,[r1,#0x20]
;;;386    }
000010  4770              BX       lr
;;;387    
                          ENDP

000012  0000              DCW      0x0000
                  |L25.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;399      */
;;;400    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404      
;;;405      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;406    }
000004  4770              BX       lr
;;;407    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;513      */
;;;514    void RCC_MCOConfig(uint8_t RCC_MCOSource)
000000  4901              LDR      r1,|L27.8|
;;;515    {
;;;516      /* Check the parameters */
;;;517      assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
;;;518        
;;;519      /* Select MCO clock source and prescaler */
;;;520      *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource; 
000002  71c8              STRB     r0,[r1,#7]
;;;521    }
000004  4770              BX       lr
;;;522    
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;700      */
;;;701    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L28.16|
;;;702    {
;;;703      uint32_t tmpreg = 0;
;;;704      
;;;705      /* Check the parameters */
;;;706      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;707      
;;;708      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;709      /* Clear PPRE1[2:0] bits */
;;;710      tmpreg &= ~RCC_CFGR_PPRE1;
000004  f42161e0          BIC      r1,r1,#0x700
;;;711      
;;;712      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;713      tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;714      
;;;715      /* Store the new value */
;;;716      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;717    }
00000c  4770              BX       lr
;;;718    
                          ENDP

00000e  0000              DCW      0x0000
                  |L28.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;730      */
;;;731    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L29.16|
;;;732    {
;;;733      uint32_t tmpreg = 0;
;;;734      
;;;735      /* Check the parameters */
;;;736      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;737      
;;;738      tmpreg = RCC->CFGR;
000002  684a              LDR      r2,[r1,#4]
;;;739      /* Clear PPRE2[2:0] bits */
;;;740      tmpreg &= ~RCC_CFGR_PPRE2;
000004  f4225260          BIC      r2,r2,#0x3800
;;;741      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;742      tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;743      /* Store the new value */
;;;744      RCC->CFGR = tmpreg;
00000c  6048              STR      r0,[r1,#4]
;;;745    }
00000e  4770              BX       lr
;;;746    
                          ENDP

                  |L29.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;447      */
;;;448    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L30.8|
;;;449    {
;;;450      /* Check the parameters */
;;;451      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;452    
;;;453      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;454    }
000004  4770              BX       lr
;;;455    
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;423      */
;;;424    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  4a04              LDR      r2,|L31.20|
;;;425    {
;;;426      /* Check the parameters */
;;;427      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;428      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;429    
;;;430      /* Clear PLL Source [16] and Multiplier [21:18] bits */
;;;431      RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
000002  6853              LDR      r3,[r2,#4]
000004  f4231374          BIC      r3,r3,#0x3d0000
000008  6053              STR      r3,[r2,#4]
;;;432    
;;;433      /* Set the PLL Source and Multiplier */
;;;434      RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
00000a  6853              LDR      r3,[r2,#4]
00000c  4308              ORRS     r0,r0,r1
00000e  4303              ORRS     r3,r3,r0
000010  6053              STR      r3,[r2,#4]
;;;435    }
000012  4770              BX       lr
;;;436    
                          ENDP

                  |L31.20|
                          DCD      0x40021000

                          AREA ||i.RCC_PREDIV1Config||, CODE, READONLY, ALIGN=2

                  RCC_PREDIV1Config PROC
;;;462      */
;;;463    void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Div)
000000  4a03              LDR      r2,|L32.16|
;;;464    {
;;;465      uint32_t tmpreg = 0;
;;;466      
;;;467      /* Check the parameters */
;;;468      assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));
;;;469    
;;;470      tmpreg = RCC->CFGR2;
000002  6ad1              LDR      r1,[r2,#0x2c]
;;;471      /* Clear PREDIV1[3:0] bits */
;;;472      tmpreg &= ~(RCC_CFGR2_PREDIV1);
000004  f021010f          BIC      r1,r1,#0xf
;;;473    
;;;474      /* Set the PREDIV1 division factor */
;;;475      tmpreg |= RCC_PREDIV1_Div;
000008  4301              ORRS     r1,r1,r0
;;;476    
;;;477      /* Store the new value */
;;;478      RCC->CFGR2 = tmpreg;
00000a  62d1              STR      r1,[r2,#0x2c]
;;;479    }
00000c  4770              BX       lr
;;;480    
                          ENDP

00000e  0000              DCW      0x0000
                  |L32.16|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1196     */
;;;1197   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L33.8|
;;;1198   {
;;;1199     /* Check the parameters */
;;;1200     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1201     
;;;1202     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1203   }
000004  4770              BX       lr
;;;1204   
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;1179     */
;;;1180   void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L34.12|
;;;1181   {
;;;1182     /* Check the parameters */
;;;1183     assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1184     
;;;1185     /* Select the RTC clock source */
;;;1186     RCC->BDCR |= RCC_RTCCLKSource;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4302              ORRS     r2,r2,r0
000006  620a              STR      r2,[r1,#0x20]
;;;1187   }
000008  4770              BX       lr
;;;1188   
                          ENDP

00000a  0000              DCW      0x0000
                  |L34.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SDADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SDADCCLKConfig PROC
;;;793      */
;;;794    void RCC_SDADCCLKConfig(uint32_t RCC_SDADCCLK)
000000  4904              LDR      r1,|L35.20|
;;;795    {   
;;;796      /* Check the parameters */
;;;797      assert_param(IS_RCC_SDADCCLK(RCC_SDADCCLK));
;;;798      
;;;799      /* Clear ADCPRE[1:0] bits */
;;;800      RCC->CFGR &= ~RCC_CFGR_SDADCPRE;
000002  684a              LDR      r2,[r1,#4]
000004  f0224278          BIC      r2,r2,#0xf8000000
000008  604a              STR      r2,[r1,#4]
;;;801      
;;;802      /* Set SDADCPRE[4:0] bits according to RCC_PCLK2 value */
;;;803      RCC->CFGR |= RCC_SDADCCLK;
00000a  684a              LDR      r2,[r1,#4]
00000c  4302              ORRS     r2,r2,r0
00000e  604a              STR      r2,[r1,#4]
;;;804    }
000010  4770              BX       lr
;;;805    
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;620      */
;;;621    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L36.16|
;;;622    {
;;;623      uint32_t tmpreg = 0;
;;;624      
;;;625      /* Check the parameters */
;;;626      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;627      
;;;628      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;629      
;;;630      /* Clear SW[1:0] bits */
;;;631      tmpreg &= ~RCC_CFGR_SW;
000004  f0210103          BIC      r1,r1,#3
;;;632      
;;;633      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;634      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;635      
;;;636      /* Store the new value */
;;;637      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;638    }
00000c  4770              BX       lr
;;;639    
                          ENDP

00000e  0000              DCW      0x0000
                  |L36.16|
                          DCD      0x40021000

                          AREA ||i.RCC_USARTCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USARTCLKConfig PROC
;;;869      */
;;;870    void RCC_USARTCLKConfig(uint32_t RCC_USARTCLK)
000000  0f02              LSRS     r2,r0,#28
;;;871    { 
;;;872      uint32_t tmp = 0;
;;;873      
;;;874      /* Check the parameters */
;;;875      assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));
;;;876    
;;;877      tmp = (RCC_USARTCLK >> 28);
;;;878    
;;;879      /* Clear USARTSW[1:0] bit */
;;;880      switch (tmp)
;;;881      {
;;;882        case 0x01:  /* clear USART1SW */
;;;883          RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
000002  490c              LDR      r1,|L37.52|
000004  2a01              CMP      r2,#1                 ;880
000006  d004              BEQ      |L37.18|
000008  2a02              CMP      r2,#2                 ;880
00000a  d006              BEQ      |L37.26|
00000c  2a03              CMP      r2,#3                 ;880
00000e  d108              BNE      |L37.34|
000010  e00b              B        |L37.42|
                  |L37.18|
000012  6b0a              LDR      r2,[r1,#0x30]
000014  f0220203          BIC      r2,r2,#3
;;;884          break;
000018  e002              B        |L37.32|
                  |L37.26|
;;;885        case 0x02:  /* clear USART2SW */
;;;886          RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
00001a  6b0a              LDR      r2,[r1,#0x30]
00001c  f4223240          BIC      r2,r2,#0x30000
                  |L37.32|
000020  630a              STR      r2,[r1,#0x30]         ;883
                  |L37.34|
;;;887          break;
;;;888        case 0x03:  /* clear USART3SW */
;;;889          RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
;;;890          break;
;;;891      default:
;;;892          break;
;;;893      }
;;;894    
;;;895      /* Set USARTSW bits according to RCC_USARTCLK value */
;;;896      RCC->CFGR3 |= RCC_USARTCLK;
000022  6b0a              LDR      r2,[r1,#0x30]
000024  4302              ORRS     r2,r2,r0
000026  630a              STR      r2,[r1,#0x30]
;;;897    }
000028  4770              BX       lr
                  |L37.42|
00002a  6b0a              LDR      r2,[r1,#0x30]         ;889
00002c  f4222240          BIC      r2,r2,#0xc0000        ;889
000030  e7f6              B        |L37.32|
;;;898    
                          ENDP

000032  0000              DCW      0x0000
                  |L37.52|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;908      */
;;;909    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4901              LDR      r1,|L38.8|
;;;910    {
;;;911      /* Check the parameters */
;;;912      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;913    
;;;914      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  f8c100d8          STR      r0,[r1,#0xd8]
;;;915    }
000006  4770              BX       lr
;;;916    
                          ENDP

                  |L38.8|
                          DCD      0x42420000

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;258      */
;;;259    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b518              PUSH     {r3,r4,lr}
;;;260    {
;;;261      __IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
;;;262      ErrorStatus status = ERROR;
;;;263      FlagStatus HSEStatus = RESET;
;;;264      
;;;265      /* Wait till HSE is ready and if timeout is reached exit */
;;;266      do
;;;267      {
;;;268        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;269        StartUpCounter++;  
;;;270      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
000004  f44f64a0          MOV      r4,#0x500
000008  9000              STR      r0,[sp,#0]
                  |L39.10|
00000a  2011              MOVS     r0,#0x11              ;268
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  9900              LDR      r1,[sp,#0]            ;269
000012  1c49              ADDS     r1,r1,#1              ;269
000014  9100              STR      r1,[sp,#0]
000016  42a1              CMP      r1,r4
000018  d001              BEQ      |L39.30|
00001a  2800              CMP      r0,#0
00001c  d0f5              BEQ      |L39.10|
                  |L39.30|
;;;271      
;;;272      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001e  2011              MOVS     r0,#0x11
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d000              BEQ      |L39.42|
;;;273      {
;;;274        status = SUCCESS;
000028  2001              MOVS     r0,#1
                  |L39.42|
;;;275      }
;;;276      else
;;;277      {
;;;278        status = ERROR;
;;;279      }  
;;;280      return (status);
;;;281    }
00002a  bd18              POP      {r3,r4,pc}
;;;282    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09
                  SDADCPrescTable
000014  02040608          DCB      0x02,0x04,0x06,0x08
000018  0a0c0e10          DCB      0x0a,0x0c,0x0e,0x10
00001c  14181c20          DCB      0x14,0x18,0x1c,0x20
000020  24282c30          DCB      0x24,0x28,0x2c,0x30

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F37x_StdPeriph_Driver\\src\\stm32f37x_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f37x_rcc_c_49e27980____REV16|
#line 138 "D:\\MDK\\install\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f37x_rcc_c_49e27980____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f37x_rcc_c_49e27980____REVSH|
#line 153
|__asm___15_stm32f37x_rcc_c_49e27980____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f37x_rcc_c_49e27980____RRX|
#line 328
|__asm___15_stm32f37x_rcc_c_49e27980____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
