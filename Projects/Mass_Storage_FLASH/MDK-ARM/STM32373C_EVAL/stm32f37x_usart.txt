; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32373c_eval\stm32f37x_usart.o --asm_dir=.\STM32373C_EVAL\ --list_dir=.\STM32373C_EVAL\ --depend=.\stm32373c_eval\stm32f37x_usart.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32373C_EVAL -IE:\STM32F373_USB_BootLoader\Projects\Mass_Storage_FLASH\MDK-ARM\RTE -ID:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -ID:\MDK\install\ARM\PACK\Keil\STM32F3xx_DFP\1.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F37X -DUSE_STDPERIPH_DRIVER -DSTM32F37X -DUSE_STM32373C_EVAL --omf_browse=.\stm32373c_eval\stm32f37x_usart.crf ..\..\..\Libraries\STM32F37x_StdPeriph_Driver\src\stm32f37x_usart.c]
                          THUMB

                          AREA ||i.USART_AddressDetectionConfig||, CODE, READONLY, ALIGN=1

                  USART_AddressDetectionConfig PROC
;;;993      */
;;;994    void USART_AddressDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_AddressLength)
000000  6842              LDR      r2,[r0,#4]
;;;995    {
;;;996      /* Check the parameters */
;;;997      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;998      assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));
;;;999    
;;;1000     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
000002  f0220210          BIC      r2,r2,#0x10
000006  6042              STR      r2,[r0,#4]
;;;1001     USARTx->CR2 |= USART_AddressLength;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;1002   }
00000e  4770              BX       lr
;;;1003   
                          ENDP


                          AREA ||i.USART_AutoBaudRateCmd||, CODE, READONLY, ALIGN=1

                  USART_AutoBaudRateCmd PROC
;;;793      */
;;;794    void USART_AutoBaudRateCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;795    {
;;;796      /* Check the parameters */
;;;797      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;798      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;799    
;;;800      if (NewState != DISABLE)
;;;801      {
;;;802        /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
;;;803           register */
;;;804        USARTx->CR2 |= USART_CR2_ABREN;
;;;805      }
;;;806      else
;;;807      {
;;;808        /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
;;;809           register */
;;;810        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L2.12|
000006  f4411180          ORR      r1,r1,#0x100000       ;804
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  f4211180          BIC      r1,r1,#0x100000
                  |L2.16|
000010  6041              STR      r1,[r0,#4]            ;804
;;;811      }
;;;812    }
000012  4770              BX       lr
;;;813    
                          ENDP


                          AREA ||i.USART_AutoBaudRateConfig||, CODE, READONLY, ALIGN=1

                  USART_AutoBaudRateConfig PROC
;;;823      */
;;;824    void USART_AutoBaudRateConfig(USART_TypeDef* USARTx, uint32_t USART_AutoBaudRate)
000000  6842              LDR      r2,[r0,#4]
;;;825    {
;;;826      /* Check the parameters */
;;;827      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;828      assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));
;;;829    
;;;830      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
000002  f42202c0          BIC      r2,r2,#0x600000
000006  6042              STR      r2,[r0,#4]
;;;831      USARTx->CR2 |= USART_AutoBaudRate;
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;832    }
00000e  4770              BX       lr
;;;833    
                          ENDP


                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;1873     */
;;;1874   void USART_ClearFlag(USART_TypeDef* USARTx, uint32_t USART_FLAG)
000000  6201              STR      r1,[r0,#0x20]
;;;1875   {
;;;1876     /* Check the parameters */
;;;1877     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1878     assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1879        
;;;1880     USARTx->ICR = USART_FLAG;
;;;1881   }
000002  4770              BX       lr
;;;1882   
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1974     */
;;;1975   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint32_t USART_IT)
000000  0c0a              LSRS     r2,r1,#16
;;;1976   {
;;;1977     uint32_t bitpos = 0, itmask = 0;
;;;1978     /* Check the parameters */
;;;1979     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1980     assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;1981     
;;;1982     bitpos = USART_IT >> 0x10;
;;;1983     itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
000002  2101              MOVS     r1,#1
000004  4091              LSLS     r1,r1,r2
;;;1984     USARTx->ICR = (uint32_t)itmask;
000006  6201              STR      r1,[r0,#0x20]
;;;1985   }
000008  4770              BX       lr
;;;1986   
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;337      */
;;;338    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;339    {
;;;340      uint32_t tmpreg = 0;
;;;341      /* Check the parameters */
;;;342      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;343      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;344      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;345      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;346      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;347    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;348      tmpreg = USARTx->CR2;
000002  6842              LDR      r2,[r0,#4]
;;;349      /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
;;;350      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
000004  f4226370          BIC      r3,r2,#0xf00
000008  e9d12400          LDRD     r2,r4,[r1,#0]
;;;351      /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
;;;352      /* Set CLKEN bit according to USART_Clock value */
;;;353      /* Set CPOL bit according to USART_CPOL value */
;;;354      /* Set CPHA bit according to USART_CPHA value */
;;;355      /* Set LBCL bit according to USART_LastBit value */
;;;356      tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00000c  4322              ORRS     r2,r2,r4
00000e  e9d14102          LDRD     r4,r1,[r1,#8]
000012  430c              ORRS     r4,r4,r1
000014  4322              ORRS     r2,r2,r4
000016  431a              ORRS     r2,r2,r3
;;;357                           USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
;;;358      /* Write to USART CR2 */
;;;359      USARTx->CR2 = tmpreg;
000018  6042              STR      r2,[r0,#4]
;;;360    }
00001a  bd10              POP      {r4,pc}
;;;361    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;367      */
;;;368    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;369    {
;;;370      /* USART_ClockInitStruct members default value */
;;;371      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
;;;372      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000002  6001              STR      r1,[r0,#0]
;;;373      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000004  6041              STR      r1,[r0,#4]
;;;374      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;375    }
00000a  4770              BX       lr
;;;376    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;383      */
;;;384    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;385    {
;;;386      /* Check the parameters */
;;;387      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;388      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;389      
;;;390      if (NewState != DISABLE)
;;;391      {
;;;392        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;393        USARTx->CR1 |= USART_CR1_UE;
;;;394      }
;;;395      else
;;;396      {
;;;397        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;398        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L8.12|
000006  f0410101          ORR      r1,r1,#1              ;393
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L8.16|
000010  6001              STR      r1,[r0,#0]            ;393
;;;399      }
;;;400    }
000012  4770              BX       lr
;;;401    
                          ENDP


                          AREA ||i.USART_DECmd||, CODE, READONLY, ALIGN=1

                  USART_DECmd PROC
;;;1427     */
;;;1428   void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1429   {
;;;1430     /* Check the parameters */
;;;1431     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1432     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1433     if (NewState != DISABLE)
;;;1434     {
;;;1435       /* Enable the DE functionality by setting the DEM bit in the CR3 register */
;;;1436       USARTx->CR3 |= USART_CR3_DEM;
;;;1437     }
;;;1438     else
;;;1439     {
;;;1440       /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
;;;1441       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L9.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;1436
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L9.16|
000010  6081              STR      r1,[r0,#8]            ;1436
;;;1442     }
;;;1443   }
000012  4770              BX       lr
;;;1444   
                          ENDP


                          AREA ||i.USART_DEPolarityConfig||, CODE, READONLY, ALIGN=1

                  USART_DEPolarityConfig PROC
;;;1453     */
;;;1454   void USART_DEPolarityConfig(USART_TypeDef* USARTx, uint32_t USART_DEPolarity)
000000  6882              LDR      r2,[r0,#8]
;;;1455   {
;;;1456     /* Check the parameters */
;;;1457     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1458     assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));
;;;1459   
;;;1460     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
000002  f4224200          BIC      r2,r2,#0x8000
000006  6082              STR      r2,[r0,#8]
;;;1461     USARTx->CR3 |= USART_DEPolarity;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;1462   }
00000e  4770              BX       lr
;;;1463   
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;1535     */
;;;1536   void USART_DMACmd(USART_TypeDef* USARTx, uint32_t USART_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1537   {
;;;1538     /* Check the parameters */
;;;1539     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1540     assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;1541     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1542   
;;;1543     if (NewState != DISABLE)
;;;1544     {
;;;1545       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1546          DMAR bits in the USART CR3 register */
;;;1547       USARTx->CR3 |= USART_DMAReq;
;;;1548     }
;;;1549     else
;;;1550     {
;;;1551       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1552          DMAR bits in the USART CR3 register */
;;;1553       USARTx->CR3 &= (uint32_t)~USART_DMAReq;
000002  6882              LDR      r2,[r0,#8]
000004  d001              BEQ      |L11.10|
000006  430a              ORRS     r2,r2,r1              ;1547
000008  e000              B        |L11.12|
                  |L11.10|
00000a  438a              BICS     r2,r2,r1
                  |L11.12|
00000c  6082              STR      r2,[r0,#8]            ;1547
;;;1554     }
;;;1555   }
00000e  4770              BX       lr
;;;1556   
                          ENDP


                          AREA ||i.USART_DMAReceptionErrorConfig||, CODE, READONLY, ALIGN=1

                  USART_DMAReceptionErrorConfig PROC
;;;1567     */
;;;1568   void USART_DMAReceptionErrorConfig(USART_TypeDef* USARTx, uint32_t USART_DMAOnError)
000000  6882              LDR      r2,[r0,#8]
;;;1569   {
;;;1570     /* Check the parameters */
;;;1571     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1572     assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
;;;1573     
;;;1574     /* Clear the DMA Reception error detection bit */
;;;1575     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
000002  f4225200          BIC      r2,r2,#0x2000
000006  6082              STR      r2,[r0,#8]
;;;1576     /* Set the new value for the DMA Reception error detection bit */
;;;1577     USARTx->CR3 |= USART_DMAOnError;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;1578   }
00000e  4770              BX       lr
;;;1579   
                          ENDP


                          AREA ||i.USART_DataInvCmd||, CODE, READONLY, ALIGN=1

                  USART_DataInvCmd PROC
;;;528      */
;;;529    void USART_DataInvCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;530    {
;;;531      /* Check the parameters */
;;;532      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;533      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;534    
;;;535      if (NewState != DISABLE)
;;;536      {
;;;537        /* Enable the binary data inversion feature by setting the DATAINV bit in 
;;;538           the CR2 register */
;;;539        USARTx->CR2 |= USART_CR2_DATAINV;
;;;540      }
;;;541      else
;;;542      {
;;;543        /* Disable the binary data inversion feature by clearing the DATAINV bit in 
;;;544           the CR2 register */
;;;545        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L13.12|
000006  f4412180          ORR      r1,r1,#0x40000        ;539
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f4212180          BIC      r1,r1,#0x40000
                  |L13.16|
000010  6041              STR      r1,[r0,#4]            ;539
;;;546      }
;;;547    }
000012  4770              BX       lr
;;;548    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;171      */
;;;172    void USART_DeInit(USART_TypeDef* USARTx)
000000  4911              LDR      r1,|L14.72|
;;;173    {
000002  b510              PUSH     {r4,lr}
;;;174      /* Check the parameters */
;;;175      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;176      
;;;177      if (USARTx == USART1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L14.30|
;;;178      {
;;;179        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  038c              LSLS     r4,r1,#14
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;180        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L14.30|
;;;181      }
;;;182      else if (USARTx == USART2)
00001e  490b              LDR      r1,|L14.76|
000020  4288              CMP      r0,r1
000022  d102              BNE      |L14.42|
;;;183      {
;;;184        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  044c              LSLS     r4,r1,#17
;;;185        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);    
000028  e004              B        |L14.52|
                  |L14.42|
;;;186      }
;;;187      else 
;;;188      {
;;;189        if  (USARTx == USART3)
00002a  4909              LDR      r1,|L14.80|
00002c  4288              CMP      r0,r1
00002e  d10a              BNE      |L14.70|
;;;190        {
;;;191          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000030  2101              MOVS     r1,#1
000032  048c              LSLS     r4,r1,#18
                  |L14.52|
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;192          RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
00003a  4620              MOV      r0,r4
00003c  e8bd4010          POP      {r4,lr}
000040  2100              MOVS     r1,#0
000042  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L14.70|
;;;193        }
;;;194      }  
;;;195    }
000046  bd10              POP      {r4,pc}
;;;196    
                          ENDP

                  |L14.72|
                          DCD      0x40013800
                  |L14.76|
                          DCD      0x40004400
                  |L14.80|
                          DCD      0x40004800

                          AREA ||i.USART_DirectionModeCmd||, CODE, READONLY, ALIGN=1

                  USART_DirectionModeCmd PROC
;;;412      */
;;;413    void USART_DirectionModeCmd(USART_TypeDef* USARTx, uint32_t USART_DirectionMode, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;414    {
;;;415      /* Check the parameters */
;;;416      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;417      assert_param(IS_USART_MODE(USART_DirectionMode));
;;;418      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;419    
;;;420      if (NewState != DISABLE)
;;;421      {
;;;422        /* Enable the USART's transfer interface by setting the TE and/or RE bits 
;;;423           in the USART CR1 register */
;;;424        USARTx->CR1 |= USART_DirectionMode;
;;;425      }
;;;426      else
;;;427      {
;;;428        /* Disable the USART's transfer interface by clearing the TE and/or RE bits
;;;429           in the USART CR3 register */
;;;430        USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
000002  6802              LDR      r2,[r0,#0]
000004  d001              BEQ      |L15.10|
000006  430a              ORRS     r2,r2,r1              ;424
000008  e000              B        |L15.12|
                  |L15.10|
00000a  438a              BICS     r2,r2,r1
                  |L15.12|
00000c  6002              STR      r2,[r0,#0]            ;424
;;;431      }
;;;432    }
00000e  4770              BX       lr
;;;433    
                          ENDP


                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;1825     */
;;;1826   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint32_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;1827   {
;;;1828     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1829     /* Check the parameters */
;;;1830     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1831     assert_param(IS_USART_FLAG(USART_FLAG));
;;;1832     
;;;1833     if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
000004  69d2              LDR      r2,[r2,#0x1c]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L16.12|
;;;1834     {
;;;1835       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L16.12|
;;;1836     }
;;;1837     else
;;;1838     {
;;;1839       bitstatus = RESET;
;;;1840     }
;;;1841     return bitstatus;
;;;1842   }
00000c  4770              BX       lr
;;;1843   
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;1903     */
;;;1904   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1905   {
;;;1906     uint32_t bitpos = 0, itmask = 0, usartreg = 0;
;;;1907     ITStatus bitstatus = RESET;
;;;1908     /* Check the parameters */
;;;1909     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1910     assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1911     
;;;1912     /* Get the USART register index */
;;;1913     usartreg = (((uint16_t)USART_IT) >> 0x08);
;;;1914     /* Get the interrupt position */
;;;1915     itmask = USART_IT & IT_MASK;
;;;1916     itmask = (uint32_t)0x01 << itmask;
000002  2201              MOVS     r2,#1
000004  2500              MOVS     r5,#0                 ;1907
000006  f3c12307          UBFX     r3,r1,#8,#8           ;1913
00000a  fa02f401          LSL      r4,r2,r1
;;;1917     
;;;1918     if (usartreg == 0x01) /* The IT  is in CR1 register */
00000e  2b01              CMP      r3,#1
000010  d00f              BEQ      |L17.50|
;;;1919     {
;;;1920       itmask &= USARTx->CR1;
;;;1921     }
;;;1922     else if (usartreg == 0x02) /* The IT  is in CR2 register */
000012  2b02              CMP      r3,#2
000014  d00f              BEQ      |L17.54|
;;;1923     {
;;;1924       itmask &= USARTx->CR2;
;;;1925     }
;;;1926     else /* The IT  is in CR3 register */
;;;1927     {
;;;1928       itmask &= USARTx->CR3;
000016  6883              LDR      r3,[r0,#8]
                  |L17.24|
;;;1929     }
;;;1930     
;;;1931     bitpos = USART_IT >> 0x10;
000018  ea4f4111          LSR      r1,r1,#16
;;;1932     bitpos = (uint32_t)0x01 << bitpos;
;;;1933     bitpos &= USARTx->ISR;
00001c  69c0              LDR      r0,[r0,#0x1c]
00001e  4223              TST      r3,r4                 ;1924
000020  fa02f201          LSL      r2,r2,r1              ;1932
000024  ea000002          AND      r0,r0,r2
000028  d001              BEQ      |L17.46|
;;;1934     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00002a  b100              CBZ      r0,|L17.46|
;;;1935     {
;;;1936       bitstatus = SET;
00002c  2501              MOVS     r5,#1
                  |L17.46|
;;;1937     }
;;;1938     else
;;;1939     {
;;;1940       bitstatus = RESET;
;;;1941     }
;;;1942     
;;;1943     return bitstatus;  
00002e  4628              MOV      r0,r5
;;;1944   }
000030  bd30              POP      {r4,r5,pc}
                  |L17.50|
000032  6803              LDR      r3,[r0,#0]            ;1920
000034  e7f0              B        |L17.24|
                  |L17.54|
000036  6843              LDR      r3,[r0,#4]            ;1924
000038  e7ee              B        |L17.24|
;;;1945   
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;1129     */
;;;1130   void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1131   {
;;;1132     /* Check the parameters */
;;;1133     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1134     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1135     
;;;1136     if (NewState != DISABLE)
;;;1137     {
;;;1138       /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;1139       USARTx->CR3 |= USART_CR3_HDSEL;
;;;1140     }
;;;1141     else
;;;1142     {
;;;1143       /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;1144       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L18.12|
000006  f0410108          ORR      r1,r1,#8              ;1139
00000a  e001              B        |L18.16|
                  |L18.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L18.16|
000010  6081              STR      r1,[r0,#8]            ;1139
;;;1145     }
;;;1146   }
000012  4770              BX       lr
;;;1147   
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;1699     */
;;;1700   void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1701   {
;;;1702     uint32_t usartreg = 0, itpos = 0, itmask = 0;
;;;1703     uint32_t usartxbase = 0;
;;;1704     /* Check the parameters */
;;;1705     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1706     assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;1707     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1708     
;;;1709     usartxbase = (uint32_t)USARTx;
;;;1710   
;;;1711     /* Get the USART register index */
;;;1712     usartreg = (((uint16_t)USART_IT) >> 0x08);
;;;1713   
;;;1714     /* Get the interrupt position */
;;;1715     itpos = USART_IT & IT_MASK;
;;;1716     itmask = (((uint32_t)0x01) << itpos);
000002  2301              MOVS     r3,#1
000004  f3c12407          UBFX     r4,r1,#8,#8           ;1712
000008  408b              LSLS     r3,r3,r1
;;;1717   
;;;1718     if (usartreg == 0x02) /* The IT is in CR2 register */
00000a  2c02              CMP      r4,#2
00000c  d002              BEQ      |L19.20|
;;;1719     {
;;;1720       usartxbase += 0x04;
;;;1721     }
;;;1722     else if (usartreg == 0x03) /* The IT is in CR3 register */
00000e  2c03              CMP      r4,#3
000010  d002              BEQ      |L19.24|
000012  e002              B        |L19.26|
                  |L19.20|
000014  1d00              ADDS     r0,r0,#4
000016  e000              B        |L19.26|
                  |L19.24|
000018  3008              ADDS     r0,r0,#8              ;1720
                  |L19.26|
;;;1723     {
;;;1724       usartxbase += 0x08;
;;;1725     }
;;;1726     else /* The IT is in CR1 register */
;;;1727     {
;;;1728     }
;;;1729     if (NewState != DISABLE)
;;;1730     {
;;;1731       *(__IO uint32_t*)usartxbase  |= itmask;
;;;1732     }
;;;1733     else
;;;1734     {
;;;1735       *(__IO uint32_t*)usartxbase &= ~itmask;
00001a  6801              LDR      r1,[r0,#0]
00001c  b10a              CBZ      r2,|L19.34|
00001e  4319              ORRS     r1,r1,r3              ;1731
000020  e000              B        |L19.36|
                  |L19.34|
000022  4399              BICS     r1,r1,r3
                  |L19.36|
000024  6001              STR      r1,[r0,#0]            ;1731
;;;1736     }
;;;1737   }
000026  bd10              POP      {r4,pc}
;;;1738   
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;204      */
;;;205    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;206    {
000002  4604              MOV      r4,r0
;;;207      uint32_t divider = 0, apbclock = 0, tmpreg = 0;
;;;208      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;209    
;;;210      /* Check the parameters */
;;;211      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;212      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;213      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;214      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;215      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;216      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;217      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;218      
;;;219      /* Disable USART */
;;;220      USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
000004  6800              LDR      r0,[r0,#0]
000006  b08d              SUB      sp,sp,#0x34           ;206
000008  460d              MOV      r5,r1                 ;206
00000a  f0200001          BIC      r0,r0,#1
00000e  6020              STR      r0,[r4,#0]
;;;221      
;;;222    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;223      tmpreg = USARTx->CR2;
000010  6860              LDR      r0,[r4,#4]
;;;224      /* Clear STOP[13:12] bits */
;;;225      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
000012  f4205140          BIC      r1,r0,#0x3000
;;;226    
;;;227      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;228      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;229      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000016  68a8              LDR      r0,[r5,#8]
000018  4308              ORRS     r0,r0,r1
;;;230      
;;;231      /* Write to USART CR2 */
;;;232      USARTx->CR2 = tmpreg;
00001a  6060              STR      r0,[r4,#4]
;;;233    
;;;234    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;235      tmpreg = USARTx->CR1;
00001c  6820              LDR      r0,[r4,#0]
;;;236      /* Clear M, PCE, PS, TE and RE bits */
;;;237      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
00001e  f241610c          MOV      r1,#0x160c
000022  4388              BICS     r0,r0,r1
;;;238    
;;;239      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;240      /* Set the M bits according to USART_WordLength value */
;;;241      /* Set PCE and PS bits according to USART_Parity value */
;;;242      /* Set TE and RE bits according to USART_Mode value */
;;;243      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
000024  68ea              LDR      r2,[r5,#0xc]
000026  6869              LDR      r1,[r5,#4]
000028  4311              ORRS     r1,r1,r2
00002a  692a              LDR      r2,[r5,#0x10]
00002c  4302              ORRS     r2,r2,r0
00002e  4311              ORRS     r1,r1,r2
;;;244                USART_InitStruct->USART_Mode;
;;;245    
;;;246      /* Write to USART CR1 */
;;;247      USARTx->CR1 = tmpreg;
000030  6021              STR      r1,[r4,#0]
;;;248    
;;;249      /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;250      tmpreg = USARTx->CR3;
000032  68a0              LDR      r0,[r4,#8]
;;;251      /* Clear CTSE and RTSE bits */
;;;252      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
000034  f4207140          BIC      r1,r0,#0x300
;;;253    
;;;254      /* Configure the USART HFC -------------------------------------------------*/
;;;255      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;256      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000038  6968              LDR      r0,[r5,#0x14]
00003a  4308              ORRS     r0,r0,r1
;;;257    
;;;258      /* Write to USART CR3 */
;;;259      USARTx->CR3 = tmpreg;
00003c  60a0              STR      r0,[r4,#8]
;;;260    
;;;261      /*---------------------------- USART BRR Configuration -----------------------*/
;;;262      /* Configure the USART Baud Rate -------------------------------------------*/
;;;263      RCC_GetClocksFreq(&RCC_ClocksStatus);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       RCC_GetClocksFreq
;;;264      
;;;265      if (USARTx == USART1)
000044  4817              LDR      r0,|L20.164|
000046  4284              CMP      r4,r0
000048  d101              BNE      |L20.78|
;;;266      {
;;;267        apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
00004a  9909              LDR      r1,[sp,#0x24]
00004c  e005              B        |L20.90|
                  |L20.78|
;;;268      }
;;;269      else if (USARTx == USART2)
00004e  4816              LDR      r0,|L20.168|
000050  4284              CMP      r4,r0
000052  d101              BNE      |L20.88|
;;;270      {
;;;271        apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
000054  990a              LDR      r1,[sp,#0x28]
000056  e000              B        |L20.90|
                  |L20.88|
;;;272      }
;;;273      else 
;;;274      {
;;;275        apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
000058  990b              LDR      r1,[sp,#0x2c]
                  |L20.90|
;;;276      }  
;;;277      
;;;278      /* Determine the integer part */
;;;279      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00005a  6820              LDR      r0,[r4,#0]
00005c  0400              LSLS     r0,r0,#16
00005e  d508              BPL      |L20.114|
;;;280      {
;;;281        /* (divider * 10) computing in case Oversampling mode is 8 Samples */
;;;282        divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
000060  004a              LSLS     r2,r1,#1
000062  6829              LDR      r1,[r5,#0]
000064  fbb2f0f1          UDIV     r0,r2,r1
;;;283        tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
000068  fbb2f3f1          UDIV     r3,r2,r1
00006c  fb012113          MLS      r1,r1,r3,r2
000070  e006              B        |L20.128|
                  |L20.114|
;;;284      }
;;;285      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;286      {
;;;287        /* (divider * 10) computing in case Oversampling mode is 16 Samples */
;;;288        divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
000072  682a              LDR      r2,[r5,#0]
000074  fbb1f0f2          UDIV     r0,r1,r2
;;;289        tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
000078  fbb1f3f2          UDIV     r3,r1,r2
00007c  fb021113          MLS      r1,r2,r3,r1
                  |L20.128|
;;;290      }
;;;291      
;;;292      /* round the divider : if fractional part i greater than 0.5 increment divider */
;;;293      if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
000080  682a              LDR      r2,[r5,#0]
000082  ebb10f52          CMP      r1,r2,LSR #1
000086  d300              BCC      |L20.138|
000088  1c40              ADDS     r0,r0,#1
                  |L20.138|
;;;294      {
;;;295        divider++;
;;;296      } 
;;;297      
;;;298      /* Implement the divider in case Oversampling mode is 8 Samples */
;;;299      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
00008a  6821              LDR      r1,[r4,#0]
00008c  0409              LSLS     r1,r1,#16
00008e  d505              BPL      |L20.156|
;;;300      {
;;;301        /* get the LSB of divider and shift it to the right by 1 bit */
;;;302        tmpreg = (divider & (uint16_t)0x000F) >> 1;
000090  f3c00142          UBFX     r1,r0,#1,#3
;;;303        
;;;304        /* update the divider value */
;;;305        divider = (divider & (uint16_t)0xFFF0) | tmpreg;
000094  f64f72f0          MOV      r2,#0xfff0
000098  4010              ANDS     r0,r0,r2
00009a  4308              ORRS     r0,r0,r1
                  |L20.156|
;;;306      }
;;;307      
;;;308      /* Write to USART BRR */
;;;309      USARTx->BRR = (uint16_t)divider;
00009c  81a0              STRH     r0,[r4,#0xc]
;;;310    }
00009e  b00d              ADD      sp,sp,#0x34
0000a0  bd30              POP      {r4,r5,pc}
;;;311    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L20.164|
                          DCD      0x40013800
                  |L20.168|
                          DCD      0x40004400

                          AREA ||i.USART_InvPinCmd||, CODE, READONLY, ALIGN=1

                  USART_InvPinCmd PROC
;;;562      */
;;;563    void USART_InvPinCmd(USART_TypeDef* USARTx, uint32_t USART_InvPin, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;564    {
;;;565      /* Check the parameters */
;;;566      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;567      assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));  
;;;568      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;569    
;;;570      if (NewState != DISABLE)
;;;571      {
;;;572        /* Enable the active level inversion for selected pins by setting the TXINV 
;;;573           and/or RXINV bits in the USART CR2 register */
;;;574        USARTx->CR2 |= USART_InvPin;
;;;575      }
;;;576      else
;;;577      {
;;;578        /* Disable the active level inversion for selected requests by clearing the 
;;;579           TXINV and/or RXINV bits in the USART CR2 register */
;;;580        USARTx->CR2 &= (uint32_t)~USART_InvPin;
000002  6842              LDR      r2,[r0,#4]
000004  d001              BEQ      |L21.10|
000006  430a              ORRS     r2,r2,r1              ;574
000008  e000              B        |L21.12|
                  |L21.10|
00000a  438a              BICS     r2,r2,r1
                  |L21.12|
00000c  6042              STR      r2,[r0,#4]            ;574
;;;581      }
;;;582    }
00000e  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;1370     */
;;;1371   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1372   {
;;;1373     /* Check the parameters */
;;;1374     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1375     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1376   
;;;1377     if (NewState != DISABLE)
;;;1378     {
;;;1379       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1380       USARTx->CR3 |= USART_CR3_IREN;
;;;1381     }
;;;1382     else
;;;1383     {
;;;1384       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1385       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L22.12|
000006  f0410102          ORR      r1,r1,#2              ;1380
00000a  e001              B        |L22.16|
                  |L22.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L22.16|
000010  6081              STR      r1,[r0,#8]            ;1380
;;;1386     }
;;;1387   }
000012  4770              BX       lr
;;;1388   /**
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;1353     */
;;;1354   void USART_IrDAConfig(USART_TypeDef* USARTx, uint32_t USART_IrDAMode)
000000  6882              LDR      r2,[r0,#8]
;;;1355   {
;;;1356     /* Check the parameters */
;;;1357     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1358     assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;1359   
;;;1360     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
000002  f0220204          BIC      r2,r2,#4
000006  6082              STR      r2,[r0,#8]
;;;1361     USARTx->CR3 |= USART_IrDAMode;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;1362   }
00000e  4770              BX       lr
;;;1363   
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;1056     */
;;;1057   void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint32_t USART_LINBreakDetectLength)
000000  6842              LDR      r2,[r0,#4]
;;;1058   {
;;;1059     /* Check the parameters */
;;;1060     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1061     assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;1062   
;;;1063     USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
000002  f0220220          BIC      r2,r2,#0x20
000006  6042              STR      r2,[r0,#4]
;;;1064     USARTx->CR2 |= USART_LINBreakDetectLength;  
000008  6842              LDR      r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  6042              STR      r2,[r0,#4]
;;;1065   }
00000e  4770              BX       lr
;;;1066   
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;1073     */
;;;1074   void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1075   {
;;;1076     /* Check the parameters */
;;;1077     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1078     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1079   
;;;1080     if (NewState != DISABLE)
;;;1081     {
;;;1082       /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;1083       USARTx->CR2 |= USART_CR2_LINEN;
;;;1084     }
;;;1085     else
;;;1086     {
;;;1087       /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;1088       USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L25.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;1083
00000a  e001              B        |L25.16|
                  |L25.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L25.16|
000010  6041              STR      r1,[r0,#4]            ;1083
;;;1089     }
;;;1090   }
000012  4770              BX       lr
;;;1091   
                          ENDP


                          AREA ||i.USART_MSBFirstCmd||, CODE, READONLY, ALIGN=1

                  USART_MSBFirstCmd PROC
;;;496      */
;;;497    void USART_MSBFirstCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;498    {
;;;499      /* Check the parameters */
;;;500      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;501      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;502      
;;;503      if (NewState != DISABLE)
;;;504      {
;;;505        /* Enable the most significant bit first transmitted/received following the 
;;;506           start bit by setting the MSBFIRST bit in the CR2 register */
;;;507        USARTx->CR2 |= USART_CR2_MSBFIRST;
;;;508      }
;;;509      else
;;;510      {
;;;511        /* Disable the most significant bit first transmitted/received following the 
;;;512           start bit by clearing the MSBFIRST bit in the CR2 register */
;;;513        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L26.12|
000006  f4412100          ORR      r1,r1,#0x80000        ;507
00000a  e001              B        |L26.16|
                  |L26.12|
00000c  f4212100          BIC      r1,r1,#0x80000
                  |L26.16|
000010  6041              STR      r1,[r0,#4]            ;507
;;;514      }
;;;515    }
000012  4770              BX       lr
;;;516    
                          ENDP


                          AREA ||i.USART_MuteModeCmd||, CODE, READONLY, ALIGN=1

                  USART_MuteModeCmd PROC
;;;947      */
;;;948    void USART_MuteModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;949    {
;;;950      /* Check the parameters */
;;;951      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;952      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;953      
;;;954      if (NewState != DISABLE)
;;;955      {
;;;956        /* Enable the USART mute mode by setting the MME bit in the CR1 register */
;;;957        USARTx->CR1 |= USART_CR1_MME;
;;;958      }
;;;959      else
;;;960      {
;;;961        /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
;;;962        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L27.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;957
00000a  e001              B        |L27.16|
                  |L27.12|
00000c  f4215100          BIC      r1,r1,#0x2000
                  |L27.16|
000010  6001              STR      r1,[r0,#0]            ;957
;;;963      }
;;;964    }
000012  4770              BX       lr
;;;965    
                          ENDP


                          AREA ||i.USART_MuteModeWakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_MuteModeWakeUpConfig PROC
;;;974      */
;;;975    void USART_MuteModeWakeUpConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUp)
000000  6802              LDR      r2,[r0,#0]
;;;976    {
;;;977      /* Check the parameters */
;;;978      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;979      assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));
;;;980    
;;;981      USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
000002  f4226200          BIC      r2,r2,#0x800
000006  6002              STR      r2,[r0,#0]
;;;982      USARTx->CR1 |= USART_WakeUp;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;983    }
00000e  4770              BX       lr
;;;984    
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;468      */
;;;469    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;470    {
;;;471      /* Check the parameters */
;;;472      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;473      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;474      
;;;475      if (NewState != DISABLE)
;;;476      {
;;;477        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;478        USARTx->CR3 |= USART_CR3_ONEBIT;
;;;479      }
;;;480      else
;;;481      {
;;;482        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;483        USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L29.12|
000006  f4416100          ORR      r1,r1,#0x800          ;478
00000a  e001              B        |L29.16|
                  |L29.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L29.16|
000010  6081              STR      r1,[r0,#8]            ;478
;;;484      }
;;;485    }
000012  4770              BX       lr
;;;486    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;442      */
;;;443    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;444    {
;;;445      /* Check the parameters */
;;;446      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;447      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;448      
;;;449      if (NewState != DISABLE)
;;;450      {
;;;451        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;452        USARTx->CR1 |= USART_CR1_OVER8;
;;;453      }
;;;454      else
;;;455      {
;;;456        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;457        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L30.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;452
00000a  e001              B        |L30.16|
                  |L30.12|
00000c  f4214100          BIC      r1,r1,#0x8000
                  |L30.16|
000010  6001              STR      r1,[r0,#0]            ;452
;;;458      }
;;;459    }  
000012  4770              BX       lr
;;;460    
                          ENDP


                          AREA ||i.USART_OverrunDetectionConfig||, CODE, READONLY, ALIGN=1

                  USART_OverrunDetectionConfig PROC
;;;1784     */
;;;1785   void USART_OverrunDetectionConfig(USART_TypeDef* USARTx, uint32_t USART_OVRDetection)
000000  6882              LDR      r2,[r0,#8]
;;;1786   {
;;;1787     /* Check the parameters */
;;;1788     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1789     assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
;;;1790     
;;;1791     /* Clear the OVR detection bit */
;;;1792     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
000002  f4225280          BIC      r2,r2,#0x1000
000006  6082              STR      r2,[r0,#8]
;;;1793     /* Set the new value for the OVR detection bit */
;;;1794     USARTx->CR3 |= USART_OVRDetection;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;1795   }
00000e  4770              BX       lr
;;;1796   
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;880      */
;;;881    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  8c80              LDRH     r0,[r0,#0x24]
;;;882    {
;;;883      /* Check the parameters */
;;;884      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;885      
;;;886      /* Receive Data */
;;;887      return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;888    }
000006  4770              BX       lr
;;;889    
                          ENDP


                          AREA ||i.USART_ReceiverTimeOutCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverTimeOutCmd PROC
;;;618      */
;;;619    void USART_ReceiverTimeOutCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;620    {
;;;621      /* Check the parameters */
;;;622      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;623      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;624    
;;;625      if (NewState != DISABLE)
;;;626      {
;;;627        /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
;;;628           register */
;;;629        USARTx->CR2 |= USART_CR2_RTOEN;
;;;630      }
;;;631      else
;;;632      {
;;;633        /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
;;;634           register */
;;;635        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L33.12|
000006  f4410100          ORR      r1,r1,#0x800000       ;629
00000a  e001              B        |L33.16|
                  |L33.12|
00000c  f4210100          BIC      r1,r1,#0x800000
                  |L33.16|
000010  6041              STR      r1,[r0,#4]            ;629
;;;636      }
;;;637    }
000012  4770              BX       lr
;;;638    
                          ENDP


                          AREA ||i.USART_RequestCmd||, CODE, READONLY, ALIGN=1

                  USART_RequestCmd PROC
;;;1752     */
;;;1753   void USART_RequestCmd(USART_TypeDef* USARTx, uint32_t USART_Request, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1754   {
;;;1755     /* Check the parameters */
;;;1756     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1757     assert_param(IS_USART_REQUEST(USART_Request));
;;;1758     assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1759   
;;;1760     if (NewState != DISABLE)
;;;1761     {
;;;1762       /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
;;;1763          register.*/
;;;1764       USARTx->RQR |= USART_Request;
;;;1765     }
;;;1766     else
;;;1767     {
;;;1768       /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
;;;1769          register.*/
;;;1770       USARTx->RQR &= (uint32_t)~USART_Request;
000002  8b02              LDRH     r2,[r0,#0x18]
000004  d001              BEQ      |L34.10|
000006  430a              ORRS     r2,r2,r1              ;1764
000008  e000              B        |L34.12|
                  |L34.10|
00000a  438a              BICS     r2,r2,r1
                  |L34.12|
00000c  8302              STRH     r2,[r0,#0x18]         ;1764
;;;1771     }
;;;1772   }
00000e  4770              BX       lr
;;;1773   
                          ENDP


                          AREA ||i.USART_STOPModeCmd||, CODE, READONLY, ALIGN=1

                  USART_STOPModeCmd PROC
;;;712      */
;;;713    void USART_STOPModeCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;714    {
;;;715      /* Check the parameters */
;;;716      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;717      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;718      
;;;719      if (NewState != DISABLE)
;;;720      {
;;;721        /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
;;;722           register */
;;;723        USARTx->CR1 |= USART_CR1_UESM;
;;;724      }
;;;725      else
;;;726      {
;;;727        /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
;;;728           register */
;;;729        USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L35.12|
000006  f0410102          ORR      r1,r1,#2              ;723
00000a  e001              B        |L35.16|
                  |L35.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L35.16|
000010  6001              STR      r1,[r0,#0]            ;723
;;;730      }
;;;731    }
000012  4770              BX       lr
;;;732    
                          ENDP


                          AREA ||i.USART_SWAPPinCmd||, CODE, READONLY, ALIGN=1

                  USART_SWAPPinCmd PROC
;;;593      */
;;;594    void USART_SWAPPinCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;595    {
;;;596      /* Check the parameters */
;;;597      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;598      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;599    
;;;600      if (NewState != DISABLE)
;;;601      {
;;;602        /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
;;;603        USARTx->CR2 |= USART_CR2_SWAP;
;;;604      }
;;;605      else
;;;606      {
;;;607        /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
;;;608        USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L36.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;603
00000a  e001              B        |L36.16|
                  |L36.12|
00000c  f4214100          BIC      r1,r1,#0x8000
                  |L36.16|
000010  6041              STR      r1,[r0,#4]            ;603
;;;609      }
;;;610    }
000012  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;865      */
;;;866    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;867    {
;;;868      /* Check the parameters */
;;;869      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;870      assert_param(IS_USART_DATA(Data)); 
;;;871        
;;;872      /* Transmit Data */
;;;873      USARTx->TDR = (Data & (uint16_t)0x01FF);
000004  8501              STRH     r1,[r0,#0x28]
;;;874    }
000006  4770              BX       lr
;;;875    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;929      */
;;;930    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  6842              LDR      r2,[r0,#4]
;;;931    {
;;;932      /* Check the parameters */
;;;933      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;934      
;;;935      /* Clear the USART address */
;;;936      USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
000002  f022427f          BIC      r2,r2,#0xff000000
000006  6042              STR      r2,[r0,#4]
;;;937      /* Set the USART address node */
;;;938      USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
000008  6842              LDR      r2,[r0,#4]
00000a  ea426101          ORR      r1,r2,r1,LSL #24
00000e  6041              STR      r1,[r0,#4]
;;;939    }
000010  4770              BX       lr
;;;940    
                          ENDP


                          AREA ||i.USART_SetAutoRetryCount||, CODE, READONLY, ALIGN=1

                  USART_SetAutoRetryCount PROC
;;;1274     */
;;;1275   void USART_SetAutoRetryCount(USART_TypeDef* USARTx, uint8_t USART_AutoCount)
000000  6882              LDR      r2,[r0,#8]
;;;1276   {    
;;;1277     /* Check the parameters */
;;;1278     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1279     assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
;;;1280     /* Clear the USART auto retry count */
;;;1281     USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
000002  f4222260          BIC      r2,r2,#0xe0000
000006  6082              STR      r2,[r0,#8]
;;;1282     /* Set the USART auto retry count*/
;;;1283     USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
000008  6882              LDR      r2,[r0,#8]
00000a  ea424141          ORR      r1,r2,r1,LSL #17
00000e  6081              STR      r1,[r0,#8]
;;;1284   }
000010  4770              BX       lr
;;;1285   
                          ENDP


                          AREA ||i.USART_SetBlockLength||, CODE, READONLY, ALIGN=1

                  USART_SetBlockLength PROC
;;;1291     */
;;;1292   void USART_SetBlockLength(USART_TypeDef* USARTx, uint8_t USART_BlockLength)
000000  6942              LDR      r2,[r0,#0x14]
;;;1293   {    
;;;1294     /* Check the parameters */
;;;1295     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1296   
;;;1297     /* Clear the Smart card block length */
;;;1298     USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
000002  f022427f          BIC      r2,r2,#0xff000000
000006  6142              STR      r2,[r0,#0x14]
;;;1299     /* Set the Smart Card block length */
;;;1300     USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
000008  6942              LDR      r2,[r0,#0x14]
00000a  ea426101          ORR      r1,r2,r1,LSL #24
00000e  6141              STR      r1,[r0,#0x14]
;;;1301   }
000010  4770              BX       lr
;;;1302   
                          ENDP


                          AREA ||i.USART_SetDEAssertionTime||, CODE, READONLY, ALIGN=1

                  USART_SetDEAssertionTime PROC
;;;1470     */
;;;1471   void USART_SetDEAssertionTime(USART_TypeDef* USARTx, uint32_t USART_DEAssertionTime)
000000  6802              LDR      r2,[r0,#0]
;;;1472   {
;;;1473     /* Check the parameters */
;;;1474     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1475     assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 
;;;1476   
;;;1477     /* Clear the DE assertion time */
;;;1478     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
000002  f0227278          BIC      r2,r2,#0x3e00000
000006  6002              STR      r2,[r0,#0]
;;;1479     /* Set the new value for the DE assertion time */
;;;1480     USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
000008  6802              LDR      r2,[r0,#0]
00000a  ea425141          ORR      r1,r2,r1,LSL #21
00000e  6001              STR      r1,[r0,#0]
;;;1481   }
000010  4770              BX       lr
;;;1482   
                          ENDP


                          AREA ||i.USART_SetDEDeassertionTime||, CODE, READONLY, ALIGN=1

                  USART_SetDEDeassertionTime PROC
;;;1489     */
;;;1490   void USART_SetDEDeassertionTime(USART_TypeDef* USARTx, uint32_t USART_DEDeassertionTime)
000000  6802              LDR      r2,[r0,#0]
;;;1491   {
;;;1492     /* Check the parameters */
;;;1493     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1494     assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 
;;;1495   
;;;1496     /* Clear the DE deassertion time */
;;;1497     USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
000002  f42212f8          BIC      r2,r2,#0x1f0000
000006  6002              STR      r2,[r0,#0]
;;;1498     /* Set the new value for the DE deassertion time */
;;;1499     USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
000008  6802              LDR      r2,[r0,#0]
00000a  ea424101          ORR      r1,r2,r1,LSL #16
00000e  6001              STR      r1,[r0,#0]
;;;1500   }
000010  4770              BX       lr
;;;1501   
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;1209     */
;;;1210   void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;1211   {    
;;;1212     /* Check the parameters */
;;;1213     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1214   
;;;1215     /* Clear the USART Guard time */
;;;1216     USARTx->GTPR &= USART_GTPR_PSC;
000002  b2d2              UXTB     r2,r2
000004  8202              STRH     r2,[r0,#0x10]
;;;1217     /* Set the USART guard time */
;;;1218     USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8a02              LDRH     r2,[r0,#0x10]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  8201              STRH     r1,[r0,#0x10]
;;;1219   }
00000e  4770              BX       lr
;;;1220   
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;665      */
;;;666    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;667    { 
;;;668      /* Check the parameters */
;;;669      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;670      
;;;671      /* Clear the USART prescaler */
;;;672      USARTx->GTPR &= USART_GTPR_GT;
000002  f402427f          AND      r2,r2,#0xff00
000006  8202              STRH     r2,[r0,#0x10]
;;;673      /* Set the USART prescaler */
;;;674      USARTx->GTPR |= USART_Prescaler;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;675    }
00000e  4770              BX       lr
;;;676    
                          ENDP


                          AREA ||i.USART_SetReceiverTimeOut||, CODE, READONLY, ALIGN=1

                  USART_SetReceiverTimeOut PROC
;;;644      */
;;;645    void USART_SetReceiverTimeOut(USART_TypeDef* USARTx, uint32_t USART_ReceiverTimeOut)
000000  6942              LDR      r2,[r0,#0x14]
;;;646    {    
;;;647      /* Check the parameters */
;;;648      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;649      assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));
;;;650    
;;;651      /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
;;;652         register  */
;;;653      USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
000002  f002427f          AND      r2,r2,#0xff000000
000006  6142              STR      r2,[r0,#0x14]
;;;654      /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
;;;655         register  */
;;;656      USARTx->RTOR |= USART_ReceiverTimeOut;
000008  6942              LDR      r2,[r0,#0x14]
00000a  430a              ORRS     r2,r2,r1
00000c  6142              STR      r2,[r0,#0x14]
;;;657    }
00000e  4770              BX       lr
;;;658    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;1227     */
;;;1228   void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1229   {
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1232     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1233     if (NewState != DISABLE)
;;;1234     {
;;;1235       /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;1236       USARTx->CR3 |= USART_CR3_SCEN;
;;;1237     }
;;;1238     else
;;;1239     {
;;;1240       /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;1241       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L46.12|
000006  f0410120          ORR      r1,r1,#0x20           ;1236
00000a  e001              B        |L46.16|
                  |L46.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L46.16|
000010  6081              STR      r1,[r0,#8]            ;1236
;;;1242     }
;;;1243   }
000012  4770              BX       lr
;;;1244   
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;1251     */
;;;1252   void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1253   {
;;;1254     /* Check the parameters */
;;;1255     assert_param(IS_USART_ALL_PERIPH(USARTx)); 
;;;1256     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1257     if (NewState != DISABLE)
;;;1258     {
;;;1259       /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;1260       USARTx->CR3 |= USART_CR3_NACK;
;;;1261     }
;;;1262     else
;;;1263     {
;;;1264       /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;1265       USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L47.12|
000006  f0410110          ORR      r1,r1,#0x10           ;1260
00000a  e001              B        |L47.16|
                  |L47.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L47.16|
000010  6081              STR      r1,[r0,#8]            ;1260
;;;1266     }
;;;1267   }
000012  4770              BX       lr
;;;1268   
                          ENDP


                          AREA ||i.USART_StopModeWakeUpSourceConfig||, CODE, READONLY, ALIGN=1

                  USART_StopModeWakeUpSourceConfig PROC
;;;743      */
;;;744    void USART_StopModeWakeUpSourceConfig(USART_TypeDef* USARTx, uint32_t USART_WakeUpSource)
000000  6882              LDR      r2,[r0,#8]
;;;745    {
;;;746      /* Check the parameters */
;;;747      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;748      assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));
;;;749    
;;;750      USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
000002  f4221240          BIC      r2,r2,#0x300000
000006  6082              STR      r2,[r0,#8]
;;;751      USARTx->CR3 |= USART_WakeUpSource;
000008  6882              LDR      r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  6082              STR      r2,[r0,#8]
;;;752    }
00000e  4770              BX       lr
;;;753    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;317      */
;;;318    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;319    {
;;;320      /* USART_InitStruct members default value */
;;;321      USART_InitStruct->USART_BaudRate = 9600;
;;;322      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
;;;323      USART_InitStruct->USART_StopBits = USART_StopBits_1;
000008  6041              STR      r1,[r0,#4]
;;;324      USART_InitStruct->USART_Parity = USART_Parity_No ;
;;;325      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000a  220c              MOVS     r2,#0xc
00000c  6081              STR      r1,[r0,#8]
00000e  e9c01203          STRD     r1,r2,[r0,#0xc]
;;;326      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  6141              STR      r1,[r0,#0x14]
;;;327    }
000014  4770              BX       lr
;;;328    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F37x_StdPeriph_Driver\\src\\stm32f37x_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f37x_usart_c_9565154b____REV16|
#line 138 "D:\\MDK\\install\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f37x_usart_c_9565154b____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f37x_usart_c_9565154b____REVSH|
#line 153
|__asm___17_stm32f37x_usart_c_9565154b____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f37x_usart_c_9565154b____RRX|
#line 328
|__asm___17_stm32f37x_usart_c_9565154b____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
