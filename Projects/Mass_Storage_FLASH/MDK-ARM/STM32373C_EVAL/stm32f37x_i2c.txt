; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32373c_eval\stm32f37x_i2c.o --asm_dir=.\STM32373C_EVAL\ --list_dir=.\STM32373C_EVAL\ --depend=.\stm32373c_eval\stm32f37x_i2c.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32373C_EVAL -IE:\STM32F373_USB_BootLoader\Projects\Mass_Storage_FLASH\MDK-ARM\RTE -ID:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -ID:\MDK\install\ARM\PACK\Keil\STM32F3xx_DFP\1.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F37X -DUSE_STDPERIPH_DRIVER -DSTM32F37X -DUSE_STM32373C_EVAL --omf_browse=.\stm32373c_eval\stm32f37x_i2c.crf ..\..\..\Libraries\STM32F37x_StdPeriph_Driver\src\stm32f37x_i2c.c]
                          THUMB

                          AREA ||i.I2C_10BitAddressHeaderCmd||, CODE, READONLY, ALIGN=1

                  I2C_10BitAddressHeaderCmd PROC
;;;773      */
;;;774    void I2C_10BitAddressHeaderCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;775    {
;;;776      /* Check the parameters */
;;;777      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;778      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;779      
;;;780      if (NewState != DISABLE)
;;;781      {
;;;782        /* Enable 10-bit header only mode */
;;;783        I2Cx->CR2 |= I2C_CR2_HEAD10R;
;;;784      }
;;;785      else
;;;786      {
;;;787        /* Disable 10-bit header only mode */
;;;788        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_HEAD10R);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L1.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;783
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L1.16|
000010  6041              STR      r1,[r0,#4]            ;783
;;;789      }
;;;790    }    
000012  4770              BX       lr
;;;791    
                          ENDP


                          AREA ||i.I2C_10BitAddressingModeCmd||, CODE, READONLY, ALIGN=1

                  I2C_10BitAddressingModeCmd PROC
;;;552      */
;;;553    void I2C_10BitAddressingModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;554    {
;;;555      /* Check the parameters */
;;;556      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;557      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;558      
;;;559      if (NewState != DISABLE)
;;;560      {
;;;561        /* Enable 10-bit addressing mode */
;;;562        I2Cx->CR2 |= I2C_CR2_ADD10;
;;;563      }
;;;564      else
;;;565      {
;;;566        /* Disable 10-bit addressing mode */
;;;567        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_ADD10);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L2.12|
000006  f4416100          ORR      r1,r1,#0x800          ;562
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L2.16|
000010  6041              STR      r1,[r0,#4]            ;562
;;;568      }
;;;569    } 
000012  4770              BX       lr
;;;570    
                          ENDP


                          AREA ||i.I2C_AcknowledgeConfig||, CODE, READONLY, ALIGN=1

                  I2C_AcknowledgeConfig PROC
;;;798      */
;;;799    void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;803      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;804      
;;;805      if (NewState != DISABLE)
;;;806      {
;;;807        /* Enable ACK generation */
;;;808        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Enable NACK generation */
;;;813        I2Cx->CR2 |= I2C_CR2_NACK;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L3.12|
000006  f4214100          BIC      r1,r1,#0x8000         ;808
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f4414100          ORR      r1,r1,#0x8000
                  |L3.16|
000010  6041              STR      r1,[r0,#4]            ;808
;;;814      }
;;;815    }
000012  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||i.I2C_AutoEndCmd||, CODE, READONLY, ALIGN=1

                  I2C_AutoEndCmd PROC
;;;617      */
;;;618    void I2C_AutoEndCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;619    {
;;;620      /* Check the parameters */
;;;621      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;622      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;623      
;;;624      if (NewState != DISABLE)
;;;625      {
;;;626        /* Enable Auto end mode */
;;;627        I2Cx->CR2 |= I2C_CR2_AUTOEND;
;;;628      }
;;;629      else
;;;630      {
;;;631        /* Disable Auto end mode */
;;;632        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_AUTOEND);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L4.12|
000006  f0417100          ORR      r1,r1,#0x2000000      ;627
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f0217100          BIC      r1,r1,#0x2000000
                  |L4.16|
000010  6041              STR      r1,[r0,#4]            ;627
;;;633      }
;;;634    } 
000012  4770              BX       lr
;;;635    
                          ENDP


                          AREA ||i.I2C_CalculatePEC||, CODE, READONLY, ALIGN=1

                  I2C_CalculatePEC PROC
;;;1106     */
;;;1107   void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1108   {
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1111     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1112     
;;;1113     if (NewState != DISABLE)
;;;1114     {
;;;1115       /* Enable PEC calculation */
;;;1116       I2Cx->CR1 |= I2C_CR1_PECEN;   
;;;1117     }
;;;1118     else
;;;1119     {
;;;1120       /* Disable PEC calculation */    
;;;1121       I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PECEN); 
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L5.12|
000006  f4410100          ORR      r1,r1,#0x800000       ;1116
00000a  e001              B        |L5.16|
                  |L5.12|
00000c  f4210100          BIC      r1,r1,#0x800000
                  |L5.16|
000010  6001              STR      r1,[r0,#0]            ;1116
;;;1122     }
;;;1123   }
000012  4770              BX       lr
;;;1124   
                          ENDP


                          AREA ||i.I2C_ClearFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearFlag PROC
;;;1464     */
;;;1465   void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  61c1              STR      r1,[r0,#0x1c]
;;;1466   { 
;;;1467     /* Check the parameters */
;;;1468     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1469     assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
;;;1470   
;;;1471     /* Clear the selected flag */
;;;1472     I2Cx->ICR = I2C_FLAG;
;;;1473     }
000002  4770              BX       lr
;;;1474   
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  I2C_ClearITPendingBit PROC
;;;1558     */
;;;1559   void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  61c1              STR      r1,[r0,#0x1c]
;;;1560   {
;;;1561     /* Check the parameters */
;;;1562     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1563     assert_param(IS_I2C_CLEAR_IT(I2C_IT));
;;;1564   
;;;1565     /* Clear the selected flag */
;;;1566     I2Cx->ICR = I2C_IT;
;;;1567   }
000002  4770              BX       lr
;;;1568   
                          ENDP


                          AREA ||i.I2C_ClockTimeoutCmd||, CODE, READONLY, ALIGN=1

                  I2C_ClockTimeoutCmd PROC
;;;975      */
;;;976    void I2C_ClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;977    {
;;;978      /* Check the parameters */
;;;979      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;980      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;981      
;;;982      if (NewState != DISABLE)
;;;983      {
;;;984        /* Enable Clock Timeout */
;;;985        I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
;;;986      }
;;;987      else
;;;988      {
;;;989        /* Disable Clock Timeout */    
;;;990        I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMOUTEN); 
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L8.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;985
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f4214100          BIC      r1,r1,#0x8000
                  |L8.16|
000010  6141              STR      r1,[r0,#0x14]         ;985
;;;991      }
;;;992    }
000012  4770              BX       lr
;;;993    
                          ENDP


                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=1

                  I2C_Cmd PROC
;;;278      */
;;;279    void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;280    {
;;;281      /* Check the parameters */
;;;282      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;283      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;284      if (NewState != DISABLE)
;;;285      {
;;;286        /* Enable the selected I2C peripheral */
;;;287        I2Cx->CR1 |= I2C_CR1_PE;
;;;288      }
;;;289      else
;;;290      {
;;;291        /* Disable the selected I2C peripheral */
;;;292        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L9.12|
000006  f0410101          ORR      r1,r1,#1              ;287
00000a  e001              B        |L9.16|
                  |L9.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L9.16|
000010  6001              STR      r1,[r0,#0]            ;287
;;;293      }
;;;294    }
000012  4770              BX       lr
;;;295    
                          ENDP


                          AREA ||i.I2C_DMACmd||, CODE, READONLY, ALIGN=1

                  I2C_DMACmd PROC
;;;1300     */
;;;1301   void I2C_DMACmd(I2C_TypeDef* I2Cx, uint32_t I2C_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1302   {
;;;1303     /* Check the parameters */
;;;1304     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1305     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1306     assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));
;;;1307   
;;;1308     if (NewState != DISABLE)
;;;1309     {
;;;1310       /* Enable the selected I2C DMA requests */
;;;1311       I2Cx->CR1 |= I2C_DMAReq;
;;;1312     }
;;;1313     else
;;;1314     {
;;;1315       /* Disable the selected I2C DMA requests */
;;;1316       I2Cx->CR1 &= (uint32_t)~I2C_DMAReq;
000002  6802              LDR      r2,[r0,#0]
000004  d001              BEQ      |L10.10|
000006  430a              ORRS     r2,r2,r1              ;1311
000008  e000              B        |L10.12|
                  |L10.10|
00000a  438a              BICS     r2,r2,r1
                  |L10.12|
00000c  6002              STR      r2,[r0,#0]            ;1311
;;;1317     }
;;;1318   }
00000e  4770              BX       lr
;;;1319   /**
                          ENDP


                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;144      */
;;;145    void I2C_DeInit(I2C_TypeDef* I2Cx)
000000  4909              LDR      r1,|L11.40|
;;;146    {
000002  b510              PUSH     {r4,lr}
;;;147      /* Check the parameters */
;;;148      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;149    
;;;150      if (I2Cx == I2C1)
000004  4288              CMP      r0,r1
;;;151      {
;;;152        /* Enable I2C1 reset state */
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
;;;154        /* Release I2C1 from reset state */
;;;155        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
;;;156      }
;;;157      else
;;;158      {
;;;159        /* Enable I2C2 reset state */
;;;160        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
000006  f04f0101          MOV      r1,#1
00000a  d101              BNE      |L11.16|
00000c  054c              LSLS     r4,r1,#21             ;153
00000e  e001              B        |L11.20|
                  |L11.16|
000010  f44f0480          MOV      r4,#0x400000
                  |L11.20|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;161        /* Release I2C2 from reset state */
;;;162        RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
00001a  4620              MOV      r0,r4
00001c  e8bd4010          POP      {r4,lr}
000020  2100              MOVS     r1,#0
000022  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;163      }
;;;164    }
;;;165    
                          ENDP

000026  0000              DCW      0x0000
                  |L11.40|
                          DCD      0x40005400

                          AREA ||i.I2C_DualAddressCmd||, CODE, READONLY, ALIGN=1

                  I2C_DualAddressCmd PROC
;;;409      */
;;;410    void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;411    {
;;;412      /* Check the parameters */
;;;413      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;414      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;415      
;;;416      if (NewState != DISABLE)
;;;417      {
;;;418        /* Enable own address 2 */
;;;419        I2Cx->OAR2 |= I2C_OAR2_OA2EN;
;;;420      }
;;;421      else
;;;422      {
;;;423        /* Disable own address 2 */
;;;424        I2Cx->OAR2 &= (uint32_t)~((uint32_t)I2C_OAR2_OA2EN);
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L12.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;419
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  f4214100          BIC      r1,r1,#0x8000
                  |L12.16|
000010  60c1              STR      r1,[r0,#0xc]          ;419
;;;425      }
;;;426    }    
000012  4770              BX       lr
;;;427    
                          ENDP


                          AREA ||i.I2C_ExtendedClockTimeoutCmd||, CODE, READONLY, ALIGN=1

                  I2C_ExtendedClockTimeoutCmd PROC
;;;1000     */
;;;1001   void I2C_ExtendedClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1002   {
;;;1003     /* Check the parameters */
;;;1004     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1005     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1006     
;;;1007     if (NewState != DISABLE)
;;;1008     {
;;;1009       /* Enable Clock Timeout */
;;;1010       I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
;;;1011     }
;;;1012     else
;;;1013     {
;;;1014       /* Disable Clock Timeout */    
;;;1015       I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TEXTEN); 
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L13.12|
000006  f0414100          ORR      r1,r1,#0x80000000     ;1010
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0214100          BIC      r1,r1,#0x80000000
                  |L13.16|
000010  6141              STR      r1,[r0,#0x14]         ;1010
;;;1016     }
;;;1017   }
000012  4770              BX       lr
;;;1018   
                          ENDP


                          AREA ||i.I2C_GeneralCallCmd||, CODE, READONLY, ALIGN=1

                  I2C_GeneralCallCmd PROC
;;;473      */
;;;474    void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;475    {
;;;476      /* Check the parameters */
;;;477      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;478      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;479      
;;;480      if (NewState != DISABLE)
;;;481      {
;;;482        /* Enable general call mode */
;;;483        I2Cx->CR1 |= I2C_CR1_GCEN;
;;;484      }
;;;485      else
;;;486      {
;;;487        /* Disable general call mode */
;;;488        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_GCEN);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L14.12|
000006  f4412100          ORR      r1,r1,#0x80000        ;483
00000a  e001              B        |L14.16|
                  |L14.12|
00000c  f4212100          BIC      r1,r1,#0x80000
                  |L14.16|
000010  6001              STR      r1,[r0,#0]            ;483
;;;489      }
;;;490    } 
000012  4770              BX       lr
;;;491    
                          ENDP


                          AREA ||i.I2C_GenerateSTART||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTART PROC
;;;721      */
;;;722    void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;723    {
;;;724      /* Check the parameters */
;;;725      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;726      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;727      
;;;728      if (NewState != DISABLE)
;;;729      {
;;;730        /* Generate a START condition */
;;;731        I2Cx->CR2 |= I2C_CR2_START;
;;;732      }
;;;733      else
;;;734      {
;;;735        /* Disable the START condition generation */
;;;736        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_START);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L15.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;731
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f4215100          BIC      r1,r1,#0x2000
                  |L15.16|
000010  6041              STR      r1,[r0,#4]            ;731
;;;737      }
;;;738    }  
000012  4770              BX       lr
;;;739      
                          ENDP


                          AREA ||i.I2C_GenerateSTOP||, CODE, READONLY, ALIGN=1

                  I2C_GenerateSTOP PROC
;;;746      */
;;;747    void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;748    {
;;;749      /* Check the parameters */
;;;750      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;751      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;752      
;;;753      if (NewState != DISABLE)
;;;754      {
;;;755        /* Generate a STOP condition */
;;;756        I2Cx->CR2 |= I2C_CR2_STOP;
;;;757      }
;;;758      else
;;;759      {
;;;760        /* Disable the STOP condition generation */
;;;761        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L16.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;756
00000a  e001              B        |L16.16|
                  |L16.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L16.16|
000010  6041              STR      r1,[r0,#4]            ;756
;;;762      }
;;;763    }  
000012  4770              BX       lr
;;;764    
                          ENDP


                          AREA ||i.I2C_GetAddressMatched||, CODE, READONLY, ALIGN=1

                  I2C_GetAddressMatched PROC
;;;821      */
;;;822    uint8_t I2C_GetAddressMatched(I2C_TypeDef* I2Cx)
000000  6980              LDR      r0,[r0,#0x18]
;;;823    {
;;;824      /* Check the parameters */
;;;825      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;826      
;;;827      /* Return the slave matched address in the SR1 register */
;;;828      return (uint8_t)(((uint32_t)I2Cx->ISR & I2C_ISR_ADDCODE) >> 16) ;
000002  21fe              MOVS     r1,#0xfe
000004  ea014010          AND      r0,r1,r0,LSR #16
;;;829    }
000008  4770              BX       lr
;;;830    
                          ENDP


                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;1420     */
;;;1421   FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
000000  4602              MOV      r2,r0
;;;1422   {
;;;1423     uint32_t tmpreg = 0;
;;;1424     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1425     
;;;1426     /* Check the parameters */
;;;1427     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1428     assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
;;;1429     
;;;1430     /* Get the ISR register value */
;;;1431     tmpreg = I2Cx->ISR;
000004  6992              LDR      r2,[r2,#0x18]
;;;1432     
;;;1433     /* Get flag status */
;;;1434     tmpreg &= I2C_FLAG;
000006  420a              TST      r2,r1
000008  d000              BEQ      |L18.12|
;;;1435     
;;;1436     if(tmpreg != 0)
;;;1437     {
;;;1438       /* I2C_FLAG is set */
;;;1439       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L18.12|
;;;1440     }
;;;1441     else
;;;1442     {
;;;1443       /* I2C_FLAG is reset */
;;;1444       bitstatus = RESET;
;;;1445     }
;;;1446     return bitstatus;
;;;1447   } 
00000c  4770              BX       lr
;;;1448   
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetITStatus PROC
;;;1494     */
;;;1495   ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
000000  2300              MOVS     r3,#0
;;;1496   {
;;;1497     uint32_t tmpreg = 0;
;;;1498     ITStatus bitstatus = RESET;
;;;1499     uint32_t enablestatus = 0;
;;;1500   
;;;1501     /* Check the parameters */
;;;1502     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1503     assert_param(IS_I2C_GET_IT(I2C_IT));
;;;1504   
;;;1505     /* Check if the interrupt source is enabled or not */
;;;1506     /* If Error interrupt */
;;;1507     if ((uint32_t)(I2C_IT & ERROR_IT_MASK))
000002  f4115f7c          TST      r1,#0x3f00
000006  d003              BEQ      |L19.16|
;;;1508     {
;;;1509       enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
000008  6802              LDR      r2,[r0,#0]
00000a  f0020280          AND      r2,r2,#0x80
00000e  e007              B        |L19.32|
                  |L19.16|
;;;1510     }
;;;1511     /* If TC interrupt */
;;;1512     else if ((uint32_t)(I2C_IT & TC_IT_MASK))
;;;1513     {
;;;1514       enablestatus = (uint32_t)((I2C_CR1_TCIE) & (I2Cx->CR1));
;;;1515     }
;;;1516     else
;;;1517     {
;;;1518       enablestatus = (uint32_t)((I2C_IT) & (I2Cx->CR1));
000010  6802              LDR      r2,[r0,#0]
000012  f0110fc0          TST      r1,#0xc0              ;1512
000016  d002              BEQ      |L19.30|
000018  f0020240          AND      r2,r2,#0x40           ;1514
00001c  e000              B        |L19.32|
                  |L19.30|
00001e  400a              ANDS     r2,r2,r1
                  |L19.32|
;;;1519     }
;;;1520     
;;;1521     /* Get the ISR register value */
;;;1522     tmpreg = I2Cx->ISR;
000020  6980              LDR      r0,[r0,#0x18]
;;;1523   
;;;1524     /* Get flag status */
;;;1525     tmpreg &= I2C_IT;
000022  4208              TST      r0,r1
;;;1526   
;;;1527     /* Check the status of the specified I2C flag */
;;;1528     if((tmpreg != RESET) && enablestatus)
000024  d001              BEQ      |L19.42|
000026  b102              CBZ      r2,|L19.42|
;;;1529     {
;;;1530       /* I2C_IT is set */
;;;1531       bitstatus = SET;
000028  2301              MOVS     r3,#1
                  |L19.42|
;;;1532     }
;;;1533     else
;;;1534     {
;;;1535       /* I2C_IT is reset */
;;;1536       bitstatus = RESET;
;;;1537     }
;;;1538   
;;;1539     /* Return the I2C_IT status */
;;;1540     return bitstatus;
00002a  4618              MOV      r0,r3
;;;1541   }
00002c  4770              BX       lr
;;;1542   
                          ENDP


                          AREA ||i.I2C_GetPEC||, CODE, READONLY, ALIGN=1

                  I2C_GetPEC PROC
;;;1154     */
;;;1155   uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)
000000  6a00              LDR      r0,[r0,#0x20]
;;;1156   {
;;;1157     /* Check the parameters */
;;;1158     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1159     
;;;1160     /* Return the slave matched address in the SR1 register */
;;;1161     return (uint8_t)((uint32_t)I2Cx->PECR & I2C_PECR_PEC);
000002  b2c0              UXTB     r0,r0
;;;1162   }
000004  4770              BX       lr
;;;1163   
                          ENDP


                          AREA ||i.I2C_GetTransferDirection||, CODE, READONLY, ALIGN=1

                  I2C_GetTransferDirection PROC
;;;835      */
;;;836    uint16_t I2C_GetTransferDirection(I2C_TypeDef* I2Cx)
000000  4601              MOV      r1,r0
;;;837    {
;;;838      uint32_t tmpreg = 0;
;;;839      uint16_t direction = 0;
000002  2000              MOVS     r0,#0
;;;840      
;;;841      /* Check the parameters */
;;;842      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;843      
;;;844      /* Return the slave matched address in the SR1 register */
;;;845      tmpreg = (uint32_t)(I2Cx->ISR & I2C_ISR_DIR);
000004  6989              LDR      r1,[r1,#0x18]
000006  f4113f80          TST      r1,#0x10000
00000a  d001              BEQ      |L21.16|
;;;846      
;;;847      /* If write transfer is requested */
;;;848      if (tmpreg == 0)
;;;849      {
;;;850        /* write transfer is requested */
;;;851        direction = I2C_Direction_Transmitter;
;;;852      }
;;;853      else
;;;854      {
;;;855        /* Read transfer is requested */
;;;856        direction = I2C_Direction_Receiver;
00000c  f44f6080          MOV      r0,#0x400
                  |L21.16|
;;;857      }  
;;;858      return direction;
;;;859    }
000010  4770              BX       lr
;;;860    
                          ENDP


                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=1

                  I2C_ITConfig PROC
;;;333      */
;;;334    void I2C_ITConfig(I2C_TypeDef* I2Cx, uint32_t I2C_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;335    {
;;;336      /* Check the parameters */
;;;337      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;338      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;339      assert_param(IS_I2C_CONFIG_IT(I2C_IT));
;;;340      
;;;341      if (NewState != DISABLE)
;;;342      {
;;;343        /* Enable the selected I2C interrupts */
;;;344        I2Cx->CR1 |= I2C_IT;
;;;345      }
;;;346      else
;;;347      {
;;;348        /* Disable the selected I2C interrupts */
;;;349        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_IT);
000002  6802              LDR      r2,[r0,#0]
000004  d001              BEQ      |L22.10|
000006  430a              ORRS     r2,r2,r1              ;344
000008  e000              B        |L22.12|
                  |L22.10|
00000a  438a              BICS     r2,r2,r1
                  |L22.12|
00000c  6002              STR      r2,[r0,#0]            ;344
;;;350      }
;;;351    }
00000e  4770              BX       lr
;;;352    
                          ENDP


                          AREA ||i.I2C_IdleClockTimeoutCmd||, CODE, READONLY, ALIGN=1

                  I2C_IdleClockTimeoutCmd PROC
;;;1026     */
;;;1027   void I2C_IdleClockTimeoutCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1028   {
;;;1029     /* Check the parameters */
;;;1030     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1031     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1032     
;;;1033     if (NewState != DISABLE)
;;;1034     {
;;;1035       /* Enable Clock Timeout */
;;;1036       I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
;;;1037     }
;;;1038     else
;;;1039     {
;;;1040       /* Disable Clock Timeout */    
;;;1041       I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIDLE); 
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L23.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;1036
00000a  e001              B        |L23.16|
                  |L23.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L23.16|
000010  6141              STR      r1,[r0,#0x14]         ;1036
;;;1042     }
;;;1043   }
000012  4770              BX       lr
;;;1044   
                          ENDP


                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;173      */
;;;174    void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;175    {
;;;176      uint32_t tmpreg = 0;
;;;177    
;;;178      /* Check the parameters */
;;;179      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;180      assert_param(IS_I2C_ANALOG_FILTER(I2C_InitStruct->I2C_AnalogFilter));
;;;181      assert_param(IS_I2C_DIGITAL_FILTER(I2C_InitStruct->I2C_DigitalFilter));
;;;182      assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));
;;;183      assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
;;;184      assert_param(IS_I2C_ACK(I2C_InitStruct->I2C_Ack));
;;;185      assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));
;;;186    
;;;187      /* Disable I2Cx Peripheral */
;;;188      I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
000002  6802              LDR      r2,[r0,#0]
000004  f0220201          BIC      r2,r2,#1
000008  6002              STR      r2,[r0,#0]
;;;189    
;;;190      /*---------------------------- I2Cx FILTERS Configuration ------------------*/
;;;191      /* Get the I2Cx CR1 value */
;;;192      tmpreg = I2Cx->CR1;
00000a  6802              LDR      r2,[r0,#0]
;;;193      /* Clear I2Cx CR1 register */
;;;194      tmpreg &= CR1_CLEAR_MASK;
00000c  4b12              LDR      r3,|L24.88|
00000e  401a              ANDS     r2,r2,r3
000010  e9d13401          LDRD     r3,r4,[r1,#4]
;;;195      /* Configure I2Cx: analog and digital filter */
;;;196      /* Set ANFOFF bit according to I2C_AnalogFilter value */
;;;197      /* Set DFN bits according to I2C_DigitalFilter value */
;;;198      tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
000014  ea422204          ORR      r2,r2,r4,LSL #8
000018  4313              ORRS     r3,r3,r2
;;;199      
;;;200      /* Write to I2Cx CR1 */
;;;201      I2Cx->CR1 = tmpreg;
00001a  6003              STR      r3,[r0,#0]
;;;202    
;;;203      /*---------------------------- I2Cx TIMING Configuration -------------------*/
;;;204      /* Configure I2Cx: Timing */
;;;205      /* Set TIMINGR bits according to I2C_Timing */
;;;206      /* Write to I2Cx TIMING */
;;;207      I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
00001c  680a              LDR      r2,[r1,#0]
00001e  f0226270          BIC      r2,r2,#0xf000000
000022  6102              STR      r2,[r0,#0x10]
;;;208    
;;;209      /* Enable I2Cx Peripheral */
;;;210      I2Cx->CR1 |= I2C_CR1_PE;
000024  6802              LDR      r2,[r0,#0]
000026  f0420201          ORR      r2,r2,#1
00002a  6002              STR      r2,[r0,#0]
;;;211    
;;;212      /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
;;;213      /* Clear tmpreg local variable */
;;;214      tmpreg = 0;
00002c  2200              MOVS     r2,#0
;;;215      /* Clear OAR1 register */
;;;216      I2Cx->OAR1 = (uint32_t)tmpreg;
00002e  6082              STR      r2,[r0,#8]
;;;217      /* Clear OAR2 register */
;;;218      I2Cx->OAR2 = (uint32_t)tmpreg;
000030  60c2              STR      r2,[r0,#0xc]
;;;219      /* Configure I2Cx: Own Address1 and acknowledged address */
;;;220      /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
;;;221      /* Set OA1 bits according to I2C_OwnAddress1 value */
;;;222      tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
000032  690b              LDR      r3,[r1,#0x10]
000034  698a              LDR      r2,[r1,#0x18]
000036  431a              ORRS     r2,r2,r3
;;;223                          (uint32_t)I2C_InitStruct->I2C_OwnAddress1);
;;;224      /* Write to I2Cx OAR1 */
;;;225      I2Cx->OAR1 = tmpreg;
000038  6082              STR      r2,[r0,#8]
;;;226      /* Enable Own Address1 acknowledgement */
;;;227      I2Cx->OAR1 |= I2C_OAR1_OA1EN;
00003a  6882              LDR      r2,[r0,#8]
00003c  f4424200          ORR      r2,r2,#0x8000
000040  6082              STR      r2,[r0,#8]
;;;228    
;;;229      /*---------------------------- I2Cx MODE Configuration ---------------------*/
;;;230      /* Configure I2Cx: mode */
;;;231      /* Set SMBDEN and SMBHEN bits according to I2C_Mode value */
;;;232      tmpreg = I2C_InitStruct->I2C_Mode;
;;;233      /* Write to I2Cx CR1 */
;;;234      I2Cx->CR1 |= tmpreg;
000042  68ca              LDR      r2,[r1,#0xc]
000044  6803              LDR      r3,[r0,#0]
000046  4313              ORRS     r3,r3,r2
000048  6003              STR      r3,[r0,#0]
;;;235    
;;;236      /*---------------------------- I2Cx ACK Configuration ----------------------*/
;;;237      /* Get the I2Cx CR2 value */
;;;238      tmpreg = I2Cx->CR2;
00004a  6842              LDR      r2,[r0,#4]
;;;239      /* Clear I2Cx CR2 register */
;;;240      tmpreg &= CR2_CLEAR_MASK;
00004c  4b03              LDR      r3,|L24.92|
;;;241      /* Configure I2Cx: acknowledgement */
;;;242      /* Set NACK bit according to I2C_Ack value */
;;;243      tmpreg |= I2C_InitStruct->I2C_Ack;
00004e  6949              LDR      r1,[r1,#0x14]
000050  401a              ANDS     r2,r2,r3              ;240
000052  4311              ORRS     r1,r1,r2
;;;244      /* Write to I2Cx CR2 */
;;;245      I2Cx->CR2 = tmpreg;
000054  6041              STR      r1,[r0,#4]
;;;246    }
000056  bd10              POP      {r4,pc}
;;;247    
                          ENDP

                  |L24.88|
                          DCD      0x00cfe0ff
                  |L24.92|
                          DCD      0x07ff7fff

                          AREA ||i.I2C_MasterRequestConfig||, CODE, READONLY, ALIGN=1

                  I2C_MasterRequestConfig PROC
;;;695      */
;;;696    void I2C_MasterRequestConfig(I2C_TypeDef* I2Cx, uint16_t I2C_Direction)
000000  2900              CMP      r1,#0
;;;697    {
;;;698    /* Check the parameters */
;;;699      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;700      assert_param(IS_I2C_DIRECTION(I2C_Direction));
;;;701      
;;;702      /* Test on the direction to set/reset the read/write bit */
;;;703      if (I2C_Direction == I2C_Direction_Transmitter)
;;;704      {
;;;705        /* Request a write Transfer */
;;;706        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
;;;707      }
;;;708      else
;;;709      {
;;;710        /* Request a read Transfer */
;;;711        I2Cx->CR2 |= I2C_CR2_RD_WRN;
000002  6841              LDR      r1,[r0,#4]
000004  d003              BEQ      |L25.14|
000006  f4416180          ORR      r1,r1,#0x400
                  |L25.10|
00000a  6041              STR      r1,[r0,#4]            ;706
;;;712      }
;;;713    }  
00000c  4770              BX       lr
                  |L25.14|
00000e  f4216180          BIC      r1,r1,#0x400          ;706
000012  e7fa              B        |L25.10|
;;;714      
                          ENDP


                          AREA ||i.I2C_NumberOfBytesConfig||, CODE, READONLY, ALIGN=1

                  I2C_NumberOfBytesConfig PROC
;;;666      */
;;;667    void I2C_NumberOfBytesConfig(I2C_TypeDef* I2Cx, uint8_t Number_Bytes)
000000  6842              LDR      r2,[r0,#4]
;;;668    {
;;;669      uint32_t tmpreg = 0;
;;;670    
;;;671      /* Check the parameters */
;;;672      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;673    
;;;674      /* Get the old register value */
;;;675      tmpreg = I2Cx->CR2;
;;;676    
;;;677      /* Reset I2Cx Nbytes bit [7:0] */
;;;678      tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_NBYTES);
000002  f422027f          BIC      r2,r2,#0xff0000
;;;679    
;;;680      /* Set I2Cx Nbytes */
;;;681      tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES);
000006  ea424101          ORR      r1,r2,r1,LSL #16
;;;682    
;;;683      /* Store the new register value */
;;;684      I2Cx->CR2 = tmpreg;
00000a  6041              STR      r1,[r0,#4]
;;;685    }  
00000c  4770              BX       lr
;;;686      
                          ENDP


                          AREA ||i.I2C_OwnAddress2Config||, CODE, READONLY, ALIGN=1

                  I2C_OwnAddress2Config PROC
;;;443      */
;;;444    void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Mask)
000000  b510              PUSH     {r4,lr}
;;;445    {
;;;446      uint32_t tmpreg = 0;
;;;447    
;;;448      /* Check the parameters */
;;;449      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;450      assert_param(IS_I2C_OWN_ADDRESS2(Address));
;;;451      assert_param(IS_I2C_OWN_ADDRESS2_MASK(Mask));
;;;452      
;;;453      /* Get the old register value */
;;;454      tmpreg = I2Cx->OAR2;
000002  68c3              LDR      r3,[r0,#0xc]
;;;455    
;;;456      /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
;;;457      tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));
000004  f24074fe          MOV      r4,#0x7fe
000008  43a3              BICS     r3,r3,r4
;;;458    
;;;459      /* Set I2Cx SADD */
;;;460      tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
00000a  f44f64e0          MOV      r4,#0x700
00000e  f00101fe          AND      r1,r1,#0xfe
000012  ea042202          AND      r2,r4,r2,LSL #8
000016  4311              ORRS     r1,r1,r2
000018  4319              ORRS     r1,r1,r3
;;;461                (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
;;;462    
;;;463      /* Store the new register value */
;;;464      I2Cx->OAR2 = tmpreg;
00001a  60c1              STR      r1,[r0,#0xc]
;;;465    }
00001c  bd10              POP      {r4,pc}
;;;466    
                          ENDP


                          AREA ||i.I2C_PECRequestCmd||, CODE, READONLY, ALIGN=1

                  I2C_PECRequestCmd PROC
;;;1131     */
;;;1132   void I2C_PECRequestCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1133   {
;;;1134     /* Check the parameters */
;;;1135     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1136     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1137     
;;;1138     if (NewState != DISABLE)
;;;1139     {
;;;1140       /* Enable PEC transmission/reception request */
;;;1141       I2Cx->CR1 |= I2C_CR2_PECBYTE;   
;;;1142     }
;;;1143     else
;;;1144     {
;;;1145       /* Disable PEC transmission/reception request */    
;;;1146       I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR2_PECBYTE); 
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L28.12|
000006  f0416180          ORR      r1,r1,#0x4000000      ;1141
00000a  e001              B        |L28.16|
                  |L28.12|
00000c  f0216180          BIC      r1,r1,#0x4000000
                  |L28.16|
000010  6001              STR      r1,[r0,#0]            ;1141
;;;1147     }
;;;1148   }
000012  4770              BX       lr
;;;1149   
                          ENDP


                          AREA ||i.I2C_ReadRegister||, CODE, READONLY, ALIGN=1

                  I2C_ReadRegister PROC
;;;1200     */
;;;1201   uint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
000000  b508              PUSH     {r3,lr}
;;;1202   {
;;;1203     __IO uint32_t tmp = 0;
;;;1204   
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1207     assert_param(IS_I2C_REGISTER(I2C_Register));
;;;1208   
;;;1209     tmp = (uint32_t)I2Cx;
;;;1210     tmp += I2C_Register;
000002  4408              ADD      r0,r0,r1
;;;1211   
;;;1212     /* Return the selected register value */
;;;1213     return (*(__IO uint32_t *) tmp);
000004  9000              STR      r0,[sp,#0]
000006  6800              LDR      r0,[r0,#0]
;;;1214   }
000008  bd08              POP      {r3,pc}
;;;1215   
                          ENDP


                          AREA ||i.I2C_ReceiveData||, CODE, READONLY, ALIGN=1

                  I2C_ReceiveData PROC
;;;1257     */
;;;1258   uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
000000  6a40              LDR      r0,[r0,#0x24]
;;;1259   {
;;;1260     /* Check the parameters */
;;;1261     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1262     
;;;1263     /* Return the data in the DR register */
;;;1264     return (uint8_t)I2Cx->RXDR;
000002  b2c0              UXTB     r0,r0
;;;1265   }  
000004  4770              BX       lr
;;;1266   
                          ENDP


                          AREA ||i.I2C_ReloadCmd||, CODE, READONLY, ALIGN=1

                  I2C_ReloadCmd PROC
;;;642      */
;;;643    void I2C_ReloadCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;644    {
;;;645      /* Check the parameters */
;;;646      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;647      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;648      
;;;649      if (NewState != DISABLE)
;;;650      {
;;;651        /* Enable Auto Reload mode */
;;;652        I2Cx->CR2 |= I2C_CR2_RELOAD;
;;;653      }
;;;654      else
;;;655      {
;;;656        /* Disable Auto Reload mode */
;;;657        I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RELOAD);
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L31.12|
000006  f0417180          ORR      r1,r1,#0x1000000      ;652
00000a  e001              B        |L31.16|
                  |L31.12|
00000c  f0217180          BIC      r1,r1,#0x1000000
                  |L31.16|
000010  6041              STR      r1,[r0,#4]            ;652
;;;658      }
;;;659    }
000012  4770              BX       lr
;;;660    
                          ENDP


                          AREA ||i.I2C_SMBusAlertCmd||, CODE, READONLY, ALIGN=1

                  I2C_SMBusAlertCmd PROC
;;;950      */
;;;951    void I2C_SMBusAlertCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;952    {
;;;953      /* Check the parameters */
;;;954      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;955      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;956      
;;;957      if (NewState != DISABLE)
;;;958      {
;;;959        /* Enable SMBus alert */
;;;960        I2Cx->CR1 |= I2C_CR1_ALERTEN;   
;;;961      }
;;;962      else
;;;963      {
;;;964        /* Disable SMBus alert */    
;;;965        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_ALERTEN); 
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L32.12|
000006  f4410180          ORR      r1,r1,#0x400000       ;960
00000a  e001              B        |L32.16|
                  |L32.12|
00000c  f4210180          BIC      r1,r1,#0x400000
                  |L32.16|
000010  6001              STR      r1,[r0,#0]            ;960
;;;966      }
;;;967    }
000012  4770              BX       lr
;;;968    
                          ENDP


                          AREA ||i.I2C_SendData||, CODE, READONLY, ALIGN=1

                  I2C_SendData PROC
;;;1243     */
;;;1244   void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
000000  6281              STR      r1,[r0,#0x28]
;;;1245   {
;;;1246     /* Check the parameters */
;;;1247     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1248     
;;;1249     /* Write in the DR register the data to be sent */
;;;1250     I2Cx->TXDR = (uint8_t)Data;
;;;1251   }
000002  4770              BX       lr
;;;1252   
                          ENDP


                          AREA ||i.I2C_SlaveAddressConfig||, CODE, READONLY, ALIGN=1

                  I2C_SlaveAddressConfig PROC
;;;523      */
;;;524    void I2C_SlaveAddressConfig(I2C_TypeDef* I2Cx, uint16_t Address)
000000  6842              LDR      r2,[r0,#4]
;;;525    {
;;;526      uint32_t tmpreg = 0;
;;;527    
;;;528      /* Check the parameters */
;;;529      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;530      assert_param(IS_I2C_SLAVE_ADDRESS(Address));
;;;531                   
;;;532      /* Get the old register value */
;;;533      tmpreg = I2Cx->CR2;
;;;534    
;;;535      /* Reset I2Cx SADD bit [9:0] */
;;;536      tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);
;;;537    
;;;538      /* Set I2Cx SADD */
;;;539      tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
000002  f3c10109          UBFX     r1,r1,#0,#10
000006  f36f0209          BFC      r2,#0,#10             ;536
00000a  4311              ORRS     r1,r1,r2
;;;540    
;;;541      /* Store the new register value */
;;;542      I2Cx->CR2 = tmpreg;
00000c  6041              STR      r1,[r0,#4]
;;;543    }
00000e  4770              BX       lr
;;;544      
                          ENDP


                          AREA ||i.I2C_SlaveByteControlCmd||, CODE, READONLY, ALIGN=1

                  I2C_SlaveByteControlCmd PROC
;;;498      */
;;;499    void I2C_SlaveByteControlCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;500    {
;;;501      /* Check the parameters */
;;;502      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;503      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;504      
;;;505      if (NewState != DISABLE)
;;;506      {
;;;507        /* Enable slave byte control */
;;;508        I2Cx->CR1 |= I2C_CR1_SBC;
;;;509      }
;;;510      else
;;;511      {
;;;512        /* Disable slave byte control */
;;;513        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_SBC);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L35.12|
000006  f4413180          ORR      r1,r1,#0x10000        ;508
00000a  e001              B        |L35.16|
                  |L35.12|
00000c  f4213180          BIC      r1,r1,#0x10000
                  |L35.16|
000010  6001              STR      r1,[r0,#0]            ;508
;;;514      }
;;;515    }
000012  4770              BX       lr
;;;516    
                          ENDP


                          AREA ||i.I2C_SoftwareResetCmd||, CODE, READONLY, ALIGN=1

                  I2C_SoftwareResetCmd PROC
;;;301      */
;;;302    void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx)
000000  6801              LDR      r1,[r0,#0]
;;;303    {
;;;304      /* Check the parameters */
;;;305      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;306    
;;;307      /* Disable peripheral */
;;;308      I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;309    
;;;310      /* Perform a dummy read to delay the disable of peripheral for minimum
;;;311         3 APB clock cycles to perform the software reset functionality */
;;;312      *(__IO uint32_t *)(uint32_t)I2Cx; 
000008  6801              LDR      r1,[r0,#0]
;;;313    
;;;314      /* Enable peripheral */
;;;315      I2Cx->CR1 |= I2C_CR1_PE;
00000a  6801              LDR      r1,[r0,#0]
00000c  f0410101          ORR      r1,r1,#1
000010  6001              STR      r1,[r0,#0]
;;;316    }
000012  4770              BX       lr
;;;317    
                          ENDP


                          AREA ||i.I2C_StopModeCmd||, CODE, READONLY, ALIGN=1

                  I2C_StopModeCmd PROC
;;;384      */
;;;385    void I2C_StopModeCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;386    {
;;;387      /* Check the parameters */
;;;388      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;389      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;390      
;;;391      if (NewState != DISABLE)
;;;392      {
;;;393        /* Enable wakeup from stop mode */
;;;394        I2Cx->CR1 |= I2C_CR1_WUPEN;   
;;;395      }
;;;396      else
;;;397      {
;;;398        /* Disable wakeup from stop mode */    
;;;399        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_WUPEN); 
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L37.12|
000006  f4412180          ORR      r1,r1,#0x40000        ;394
00000a  e001              B        |L37.16|
                  |L37.12|
00000c  f4212180          BIC      r1,r1,#0x40000
                  |L37.16|
000010  6001              STR      r1,[r0,#0]            ;394
;;;400      }
;;;401    }
000012  4770              BX       lr
;;;402    
                          ENDP


                          AREA ||i.I2C_StretchClockCmd||, CODE, READONLY, ALIGN=1

                  I2C_StretchClockCmd PROC
;;;359      */
;;;360    void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;361    {
;;;362      /* Check the parameters */
;;;363      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;364      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;365      
;;;366      if (NewState != DISABLE)
;;;367      {
;;;368        /* Enable clock stretching */
;;;369        I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
;;;370      }
;;;371      else
;;;372      {
;;;373        /* Disable clock stretching  */
;;;374        I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L38.12|
000006  f4213100          BIC      r1,r1,#0x20000        ;369
00000a  e001              B        |L38.16|
                  |L38.12|
00000c  f4413100          ORR      r1,r1,#0x20000
                  |L38.16|
000010  6001              STR      r1,[r0,#0]            ;369
;;;375      }
;;;376    }
000012  4770              BX       lr
;;;377    
                          ENDP


                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;252      */
;;;253    void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  2100              MOVS     r1,#0
;;;254    {
;;;255      /*---------------- Reset I2C init structure parameters values --------------*/
;;;256      /* Initialize the I2C_Timing member */
;;;257      I2C_InitStruct->I2C_Timing = 0;
;;;258      /* Initialize the I2C_AnalogFilter member */
;;;259      I2C_InitStruct->I2C_AnalogFilter = I2C_AnalogFilter_Enable;
000002  6001              STR      r1,[r0,#0]
;;;260      /* Initialize the I2C_DigitalFilter member */
;;;261      I2C_InitStruct->I2C_DigitalFilter = 0;
000004  6041              STR      r1,[r0,#4]
;;;262      /* Initialize the I2C_Mode member */
;;;263      I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
000006  6081              STR      r1,[r0,#8]
;;;264      /* Initialize the I2C_OwnAddress1 member */
;;;265      I2C_InitStruct->I2C_OwnAddress1 = 0;
;;;266      /* Initialize the I2C_Ack member */
;;;267      I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
000008  f44f4200          MOV      r2,#0x8000
00000c  60c1              STR      r1,[r0,#0xc]
00000e  e9c01204          STRD     r1,r2,[r0,#0x10]
;;;268      /* Initialize the I2C_AcknowledgedAddress member */
;;;269      I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
000012  6181              STR      r1,[r0,#0x18]
;;;270    }
000014  4770              BX       lr
;;;271    
                          ENDP


                          AREA ||i.I2C_TimeoutAConfig||, CODE, READONLY, ALIGN=1

                  I2C_TimeoutAConfig PROC
;;;1051     */
;;;1052   void I2C_TimeoutAConfig(I2C_TypeDef* I2Cx, uint16_t Timeout)
000000  6942              LDR      r2,[r0,#0x14]
;;;1053   {
;;;1054     uint32_t tmpreg = 0;
;;;1055   
;;;1056     /* Check the parameters */
;;;1057     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1058     assert_param(IS_I2C_TIMEOUT(Timeout));
;;;1059       
;;;1060     /* Get the old register value */
;;;1061     tmpreg = I2Cx->TIMEOUTR;
;;;1062   
;;;1063     /* Reset I2Cx TIMEOUTA bit [11:0] */
;;;1064     tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);
;;;1065   
;;;1066     /* Set I2Cx TIMEOUTA */
;;;1067     tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
000002  f3c1010b          UBFX     r1,r1,#0,#12
000006  f36f020b          BFC      r2,#0,#12             ;1064
00000a  4311              ORRS     r1,r1,r2
;;;1068   
;;;1069     /* Store the new register value */
;;;1070     I2Cx->TIMEOUTR = tmpreg;
00000c  6141              STR      r1,[r0,#0x14]
;;;1071   }
00000e  4770              BX       lr
;;;1072   
                          ENDP


                          AREA ||i.I2C_TimeoutBConfig||, CODE, READONLY, ALIGN=2

                  I2C_TimeoutBConfig PROC
;;;1078     */
;;;1079   void I2C_TimeoutBConfig(I2C_TypeDef* I2Cx, uint16_t Timeout)
000000  6942              LDR      r2,[r0,#0x14]
;;;1080   {
;;;1081     uint32_t tmpreg = 0;
;;;1082   
;;;1083     /* Check the parameters */
;;;1084     assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;1085     assert_param(IS_I2C_TIMEOUT(Timeout));
;;;1086   
;;;1087     /* Get the old register value */
;;;1088     tmpreg = I2Cx->TIMEOUTR;
;;;1089   
;;;1090     /* Reset I2Cx TIMEOUTB bit [11:0] */
;;;1091     tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);
000002  4b04              LDR      r3,|L41.20|
000004  401a              ANDS     r2,r2,r3
;;;1092   
;;;1093     /* Set I2Cx TIMEOUTB */
;;;1094     tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
000006  f06f4370          MVN      r3,#0xf0000000
00000a  ea034101          AND      r1,r3,r1,LSL #16
00000e  4311              ORRS     r1,r1,r2
;;;1095   
;;;1096     /* Store the new register value */
;;;1097     I2Cx->TIMEOUTR = tmpreg;
000010  6141              STR      r1,[r0,#0x14]
;;;1098   }
000012  4770              BX       lr
;;;1099   
                          ENDP

                  |L41.20|
                          DCD      0xf000ffff

                          AREA ||i.I2C_TransferHandling||, CODE, READONLY, ALIGN=2

                  I2C_TransferHandling PROC
;;;879      */
;;;880    void I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode)
000000  b570              PUSH     {r4-r6,lr}
;;;881    {
;;;882      uint32_t tmpreg = 0;
;;;883      
;;;884      /* Check the parameters */
;;;885      assert_param(IS_I2C_ALL_PERIPH(I2Cx));
;;;886      assert_param(IS_I2C_SLAVE_ADDRESS(Address));  
;;;887      assert_param(IS_RELOAD_END_MODE(ReloadEndMode));
;;;888      assert_param(IS_START_STOP_MODE(StartStopMode));
;;;889        
;;;890      /* Get the CR2 register value */
;;;891      tmpreg = I2Cx->CR2;
000002  6844              LDR      r4,[r0,#4]
000004  9d04              LDR      r5,[sp,#0x10]
;;;892      
;;;893      /* clear tmpreg specific bits */
;;;894      tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
;;;895      
;;;896      /* update tmpreg */
;;;897      tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
000006  f3c10109          UBFX     r1,r1,#0,#10
00000a  4e04              LDR      r6,|L42.28|
00000c  ea414102          ORR      r1,r1,r2,LSL #16
000010  4319              ORRS     r1,r1,r3
000012  4034              ANDS     r4,r4,r6              ;894
000014  4329              ORRS     r1,r1,r5
000016  4321              ORRS     r1,r1,r4
;;;898                (uint32_t)ReloadEndMode | (uint32_t)StartStopMode);
;;;899      
;;;900      /* update CR2 register */
;;;901      I2Cx->CR2 = tmpreg;  
000018  6041              STR      r1,[r0,#4]
;;;902    }  
00001a  bd70              POP      {r4-r6,pc}
;;;903    
                          ENDP

                  |L42.28|
                          DCD      0xfc009800

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F37x_StdPeriph_Driver\\src\\stm32f37x_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f37x_i2c_c_7174d409____REV16|
#line 138 "D:\\MDK\\install\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f37x_i2c_c_7174d409____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f37x_i2c_c_7174d409____REVSH|
#line 153
|__asm___15_stm32f37x_i2c_c_7174d409____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f37x_i2c_c_7174d409____RRX|
#line 328
|__asm___15_stm32f37x_i2c_c_7174d409____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
