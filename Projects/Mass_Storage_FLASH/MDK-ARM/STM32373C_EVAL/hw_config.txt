; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32373c_eval\hw_config.o --asm_dir=.\STM32373C_EVAL\ --list_dir=.\STM32373C_EVAL\ --depend=.\stm32373c_eval\hw_config.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32373C_EVAL -IE:\STM32F373_USB_BootLoader\Projects\Mass_Storage_FLASH\MDK-ARM\RTE -ID:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -ID:\MDK\install\ARM\PACK\Keil\STM32F3xx_DFP\1.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F37X -DUSE_STDPERIPH_DRIVER -DSTM32F37X -DUSE_STM32373C_EVAL --omf_browse=.\stm32373c_eval\hw_config.crf ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;127    *******************************************************************************/
;;;128    void Enter_LowPowerMode(void)
000000  4901              LDR      r1,|L1.8|
;;;129    {
;;;130    	/* Set the device state to suspend */
;;;131    	bDeviceState = SUSPENDED;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;132    }
000006  4770              BX       lr
;;;133    
                          ENDP

                  |L1.8|
                          DCD      bDeviceState

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;275    *******************************************************************************/
;;;276    void Get_SerialNum(void)
000000  480a              LDR      r0,|L2.44|
;;;277    {
000002  b510              PUSH     {r4,lr}
;;;278      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;279    
;;;280      Device_Serial0 = *(uint32_t*)ID1;
;;;281      Device_Serial1 = *(uint32_t*)ID2;
000004  6801              LDR      r1,[r0,#0]
000006  1d00              ADDS     r0,r0,#4
;;;282      Device_Serial2 = *(uint32_t*)ID3;
000008  6804              LDR      r4,[r0,#0]
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
;;;283    
;;;284      Device_Serial0 += Device_Serial2;
00000e  1808              ADDS     r0,r1,r0
000010  d00b              BEQ      |L2.42|
;;;285    
;;;286      if (Device_Serial0 != 0)
;;;287      {
;;;288        IntToUnicode (Device_Serial0, &MASS_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L2.48|
000016  f7fffffe          BL       IntToUnicode
;;;289        IntToUnicode (Device_Serial1, &MASS_StringSerial[18], 4);
00001a  4905              LDR      r1,|L2.48|
00001c  4620              MOV      r0,r4
00001e  2204              MOVS     r2,#4
000020  e8bd4010          POP      {r4,lr}
000024  3110              ADDS     r1,r1,#0x10
000026  f7ffbffe          B.W      IntToUnicode
                  |L2.42|
;;;290      }
;;;291    }
00002a  bd10              POP      {r4,pc}
;;;292    
                          ENDP

                  |L2.44|
                          DCD      0x1ffff7ac
                  |L2.48|
                          DCD      MASS_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;299    *******************************************************************************/
;;;300    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;301    {
;;;302      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;303      
;;;304      for( idx = 0 ; idx < len ; idx ++)
;;;305      {
;;;306        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;307        {
;;;308          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;309        }
;;;310        else
;;;311        {
;;;312          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L3.50|
00000e  bf00              NOP                            ;306
                  |L3.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;306
000014  d902              BLS      |L3.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;308
00001a  e001              B        |L3.32|
                  |L3.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L3.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;313        }
;;;314        
;;;315        value = value << 4;
;;;316        
;;;317        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;315
00002a  1c5b              ADDS     r3,r3,#1
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;304
                  |L3.50|
000032  4293              CMP      r3,r2                 ;304
000034  d3ec              BCC      |L3.16|
;;;318      }
;;;319    }
000036  bdf0              POP      {r4-r7,pc}
;;;320    
                          ENDP


                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;139    *******************************************************************************/
;;;140    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L4.20|
;;;141    {
;;;142      DEVICE_INFO *pInfo = &Device_Info;
;;;143    
;;;144      /* Set the device state to the correct state */
;;;145      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;146      {
;;;147        /* Device configured */
;;;148        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L4.24|
000006  b109              CBZ      r1,|L4.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L4.14|
                  |L4.12|
;;;149      }
;;;150      else
;;;151      {
;;;152        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L4.14|
00000e  6001              STR      r1,[r0,#0]            ;148  ; bDeviceState
;;;153      }
;;;154    //  /*Enable SystemCoreClock*/
;;;155    //  SystemInit(); 
;;;156    }
000010  4770              BX       lr
;;;157    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      Device_Info
                  |L4.24|
                          DCD      bDeviceState

                          AREA ||i.Led_Config||, CODE, READONLY, ALIGN=1

                  Led_Config PROC
;;;191    *******************************************************************************/
;;;192    void Led_Config(void)
000000  b510              PUSH     {r4,lr}
;;;193    {
;;;194    	/* Configure the LEDs */
;;;195    	STM_EVAL_LEDInit(LED1);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       STM_EVAL_LEDInit
;;;196    	STM_EVAL_LEDInit(LED2);
000008  e8bd4010          POP      {r4,lr}
00000c  2001              MOVS     r0,#1
00000e  f7ffbffe          B.W      STM_EVAL_LEDInit
;;;197    }
;;;198    
                          ENDP


                          AREA ||i.Led_RW_OFF||, CODE, READONLY, ALIGN=1

                  Led_RW_OFF PROC
;;;217    *******************************************************************************/
;;;218    void Led_RW_OFF(void)
000000  2001              MOVS     r0,#1
;;;219    {
;;;220    	STM_EVAL_LEDOff(LED2);
000002  f7ffbffe          B.W      STM_EVAL_LEDOff
;;;221    }
;;;222    /*******************************************************************************
                          ENDP


                          AREA ||i.Led_RW_ON||, CODE, READONLY, ALIGN=1

                  Led_RW_ON PROC
;;;205    *******************************************************************************/
;;;206    void Led_RW_ON(void)
000000  2001              MOVS     r0,#1
;;;207    {
;;;208    	STM_EVAL_LEDOn(LED2);
000002  f7ffbffe          B.W      STM_EVAL_LEDOn
;;;209    }
;;;210    
                          ENDP


                          AREA ||i.MAL_Config||, CODE, READONLY, ALIGN=1

                  MAL_Config PROC
;;;326    *******************************************************************************/
;;;327    void MAL_Config(void)
000000  2000              MOVS     r0,#0
;;;328    {
;;;329      MAL_Init(0);
000002  f7ffbffe          B.W      MAL_Init
;;;330    }
;;;331    
                          ENDP


                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;57     *******************************************************************************/
;;;58     void Set_System(void)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;59     {
;;;60     	GPIO_InitTypeDef GPIO_InitStructure;
;;;61     
;;;62     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000004  2101              MOVS     r1,#1
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;63     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
00000c  f44f3800          MOV      r8,#0x20000
000010  2101              MOVS     r1,#1
000012  4640              MOV      r0,r8
000014  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;64     
;;;65     	/* USB_DISCONNECT used as USB pull-up */
;;;66     	GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;67     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000018  2501              MOVS     r5,#1
00001a  f88d5004          STRB     r5,[sp,#4]
;;;68     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
00001e  2602              MOVS     r6,#2
000020  f88d6005          STRB     r6,[sp,#5]
;;;69     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000024  2400              MOVS     r4,#0
000026  f44f6780          MOV      r7,#0x400             ;66
00002a  f88d4006          STRB     r4,[sp,#6]
;;;70     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;71     	GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
00002e  f04f4990          MOV      r9,#0x48000000
000032  9700              STR      r7,[sp,#0]            ;67
000034  f88d4007          STRB     r4,[sp,#7]            ;70
000038  4669              MOV      r1,sp
00003a  4648              MOV      r0,r9
00003c  f7fffffe          BL       GPIO_Init
;;;72     
;;;73     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
000040  2101              MOVS     r1,#1
000042  4640              MOV      r0,r8
000044  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;74     
;;;75     	/*Set PA11,12 as IN - USB_DM,DP*/
;;;76     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
000048  2101              MOVS     r1,#1
00004a  4640              MOV      r0,r8
00004c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;77     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
000050  f44f50c0          MOV      r0,#0x1800
;;;78     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000054  9000              STR      r0,[sp,#0]
000056  2003              MOVS     r0,#3
000058  f88d0005          STRB     r0,[sp,#5]
;;;79     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00005c  f88d6004          STRB     r6,[sp,#4]
;;;80     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000060  f88d4006          STRB     r4,[sp,#6]
;;;81     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000064  f88d4007          STRB     r4,[sp,#7]
;;;82     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000068  4669              MOV      r1,sp
00006a  4648              MOV      r0,r9
00006c  f7fffffe          BL       GPIO_Init
;;;83     
;;;84     	/*SET PA11,12 for USB: USB_DM,DP*/
;;;85     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
000070  220e              MOVS     r2,#0xe
000072  210b              MOVS     r1,#0xb
000074  4648              MOV      r0,r9
000076  f7fffffe          BL       GPIO_PinAFConfig
;;;86     	GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
00007a  220e              MOVS     r2,#0xe
00007c  210c              MOVS     r1,#0xc
00007e  4648              MOV      r0,r9
000080  f7fffffe          BL       GPIO_PinAFConfig
;;;87     
;;;88     	/* USB_DISCONNECT used as USB pull-up */
;;;89     	GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;90     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000084  f88d6005          STRB     r6,[sp,#5]
;;;91     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000088  f88d5004          STRB     r5,[sp,#4]
;;;92     	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00008c  f88d4006          STRB     r4,[sp,#6]
000090  9700              STR      r7,[sp,#0]            ;90
;;;93     	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
000092  f88d4007          STRB     r4,[sp,#7]
;;;94     	GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
000096  4669              MOV      r1,sp
000098  4648              MOV      r0,r9
00009a  f7fffffe          BL       GPIO_Init
;;;95     
;;;96     	/* Configure the EXTI line 18 connected internally to the USB IP */
;;;97     	EXTI_ClearITPendingBit(EXTI_Line18);
00009e  04ac              LSLS     r4,r5,#18
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       EXTI_ClearITPendingBit
;;;98     	EXTI_InitStructure.EXTI_Line = EXTI_Line18; 
0000a6  4905              LDR      r1,|L9.188|
;;;99     	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
0000a8  2008              MOVS     r0,#8
0000aa  600c              STR      r4,[r1,#0]  ; EXTI_InitStructure
0000ac  7148              STRB     r0,[r1,#5]
;;;100    	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
0000ae  718d              STRB     r5,[r1,#6]
;;;101    	EXTI_Init(&EXTI_InitStructure);
0000b0  4608              MOV      r0,r1
0000b2  f7fffffe          BL       EXTI_Init
;;;102    
;;;103    //	/* MAL configuration */
;;;104    //	MAL_Config();
;;;105    }
0000b6  e8bd87fc          POP      {r2-r10,pc}
;;;106    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L9.188|
                          DCD      ||area_number.18||

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;112    *******************************************************************************/
;;;113    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;114    {
;;;115    	/* Select USBCLK source */
;;;116    	RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;117    
;;;118    	/* Enable the USB clock */
;;;119    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;120    }
;;;121    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=1

                  USB_Cable_Config PROC
;;;251    *******************************************************************************/
;;;252    void USB_Cable_Config (FunctionalState NewState)
000000  b51c              PUSH     {r2-r4,lr}
;;;253    {
;;;254    	GPIO_InitTypeDef  GPIO_InitStructure;
;;;255    	if (NewState != DISABLE)
;;;256    	{
;;;257    		GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000002  f44f6180          MOV      r1,#0x400
000006  f04f4290          MOV      r2,#0x48000000
00000a  b118              CBZ      r0,|L11.20|
00000c  4610              MOV      r0,r2
00000e  f7fffffe          BL       GPIO_SetBits
;;;258    	}
;;;259    	else
;;;260    	{
;;;261    		GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;262    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;263    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;264    		GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;265    		GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;266    	}
;;;267    }
000012  bd1c              POP      {r2-r4,pc}
                  |L11.20|
000014  2000              MOVS     r0,#0                 ;262
000016  9100              STR      r1,[sp,#0]            ;262
000018  f88d0004          STRB     r0,[sp,#4]            ;262
00001c  2102              MOVS     r1,#2                 ;263
00001e  f88d1005          STRB     r1,[sp,#5]            ;263
000022  f88d0007          STRB     r0,[sp,#7]            ;264
000026  4669              MOV      r1,sp                 ;265
000028  4610              MOV      r0,r2                 ;265
00002a  f7fffffe          BL       GPIO_Init
00002e  bd1c              POP      {r2-r4,pc}
;;;268    
                          ENDP


                          AREA ||i.USB_Configured_LED||, CODE, READONLY, ALIGN=1

                  USB_Configured_LED PROC
;;;228    *******************************************************************************/
;;;229    void USB_Configured_LED(void)
000000  2000              MOVS     r0,#0
;;;230    {
;;;231    	STM_EVAL_LEDOn(LED1);
000002  f7ffbffe          B.W      STM_EVAL_LEDOn
;;;232    }
;;;233    
                          ENDP


                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;163    *******************************************************************************/
;;;164    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;165    {
;;;166    	NVIC_InitTypeDef NVIC_InitStructure; 
;;;167    
;;;168    	/* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;169    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);  
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;170    
;;;171    	/* Enable the USB interrupt */
;;;172    	NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
00000a  204b              MOVS     r0,#0x4b
00000c  f88d0000          STRB     r0,[sp,#0]
;;;173    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;174    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;175    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;176    	NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;177    
;;;178    	/* Enable the USB Wake-up interrupt */
;;;179    	NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  204c              MOVS     r0,#0x4c
00002a  f88d0000          STRB     r0,[sp,#0]
;;;180    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002e  f88d4001          STRB     r4,[sp,#1]
;;;181    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000032  f88d5003          STRB     r5,[sp,#3]
;;;182    	NVIC_Init(&NVIC_InitStructure);
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       NVIC_Init
;;;183    }
00003c  bd38              POP      {r3-r5,pc}
;;;184    
                          ENDP


                          AREA ||i.USB_NotConfigured_LED||, CODE, READONLY, ALIGN=1

                  USB_NotConfigured_LED PROC
;;;240    *******************************************************************************/
;;;241    void USB_NotConfigured_LED(void)
000000  2000              MOVS     r0,#0
;;;242    {
;;;243    	STM_EVAL_LEDOff(LED1);
000002  f7ffbffe          B.W      STM_EVAL_LEDOff
;;;244    }
;;;245    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 138 "D:\\MDK\\install\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 153
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____RRX|
#line 328
|__asm___11_hw_config_c_25f922fc____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
