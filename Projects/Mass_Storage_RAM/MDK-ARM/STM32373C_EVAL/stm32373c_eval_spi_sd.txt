; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32373c_eval\stm32373c_eval_spi_sd.o --asm_dir=.\STM32373C_EVAL\ --list_dir=.\STM32373C_EVAL\ --depend=.\stm32373c_eval\stm32373c_eval_spi_sd.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32373C_EVAL -IE:\STM32F373_USB_BootLoader\Projects\Mass_Storage\MDK-ARM\RTE -ID:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -ID:\MDK\install\ARM\PACK\Keil\STM32F3xx_DFP\1.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F37X -DUSE_STDPERIPH_DRIVER -DSTM32F37X -DUSE_STM32373C_EVAL --omf_browse=.\stm32373c_eval\stm32373c_eval_spi_sd.crf ..\..\..\Utilities\STM32_EVAL\STM32373C_EVAL\stm32373c_eval_spi_sd.c]
                          THUMB

                          AREA ||i.SD_DeInit||, CODE, READONLY, ALIGN=1

                  SD_DeInit PROC
;;;119      */
;;;120    void SD_DeInit(void)
000000  f7ffbffe          B.W      SD_LowLevel_DeInit
;;;121    {
;;;122      SD_LowLevel_DeInit();
;;;123    }
;;;124    
                          ENDP


                          AREA ||i.SD_Detect||, CODE, READONLY, ALIGN=2

                  SD_Detect PROC
;;;159     */
;;;160    uint8_t SD_Detect(void)
000000  b508              PUSH     {r3,lr}
;;;161    {
;;;162      __IO uint8_t status = SD_PRESENT;
000002  2001              MOVS     r0,#1
000004  f88d0000          STRB     r0,[sp,#0]
;;;163    
;;;164      /*!< Check GPIO to detect SD */
;;;165      if (GPIO_ReadInputData(SD_DETECT_GPIO_PORT) & SD_DETECT_PIN)
000008  4805              LDR      r0,|L2.32|
00000a  f7fffffe          BL       GPIO_ReadInputData
00000e  0700              LSLS     r0,r0,#28
000010  d502              BPL      |L2.24|
;;;166      {
;;;167        status = SD_NOT_PRESENT;
000012  2000              MOVS     r0,#0
000014  f88d0000          STRB     r0,[sp,#0]
                  |L2.24|
;;;168      }
;;;169      return status;
000018  f89d0000          LDRB     r0,[sp,#0]
;;;170    }
00001c  bd08              POP      {r3,pc}
;;;171    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x48001000

                          AREA ||i.SD_GetCIDRegister||, CODE, READONLY, ALIGN=2

                  SD_GetCIDRegister PROC
;;;560      */
;;;561    SD_Error SD_GetCIDRegister(SD_CID* SD_cid)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;562    {
;;;563      uint32_t i = 0;
;;;564      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;565      uint8_t CID_Tab[16];
;;;566      
;;;567      /*!< SD chip select low */
;;;568      SD_CS_LOW();
000004  4f3e              LDR      r7,|L3.256|
000006  4604              MOV      r4,r0                 ;562
000008  2500              MOVS     r5,#0                 ;563
00000a  26ff              MOVS     r6,#0xff              ;564
00000c  2104              MOVS     r1,#4
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       GPIO_ResetBits
;;;569      
;;;570      /*!< Send CMD10 (CID register) */
;;;571      SD_SendCmd(SD_CMD_SEND_CID, 0, 0xFF);
000014  22ff              MOVS     r2,#0xff
000016  2100              MOVS     r1,#0
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       SD_SendCmd
;;;572      
;;;573      /*!< Wait for response in the R1 format (0x00 is no errors) */
;;;574      if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       SD_GetResponse
000024  b988              CBNZ     r0,|L3.74|
;;;575      {
;;;576        if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
000026  20fe              MOVS     r0,#0xfe
000028  f7fffffe          BL       SD_GetResponse
00002c  b930              CBNZ     r0,|L3.60|
00002e  466e              MOV      r6,sp                 ;565
                  |L3.48|
;;;577        {
;;;578          /*!< Store CID register value on CID_Tab */
;;;579          for (i = 0; i < 16; i++)
;;;580          {
;;;581            CID_Tab[i] = SD_ReadByte();
000030  f7fffffe          BL       SD_ReadByte
000034  5570              STRB     r0,[r6,r5]
000036  1c6d              ADDS     r5,r5,#1
000038  2d10              CMP      r5,#0x10              ;579
00003a  d3f9              BCC      |L3.48|
                  |L3.60|
;;;582          }
;;;583        }
;;;584        /*!< Get CRC bytes (not really needed by us, but required by SD) */
;;;585        SD_WriteByte(SD_DUMMY_BYTE);
00003c  20ff              MOVS     r0,#0xff
00003e  f7fffffe          BL       SD_WriteByte
;;;586        SD_WriteByte(SD_DUMMY_BYTE);
000042  20ff              MOVS     r0,#0xff
000044  f7fffffe          BL       SD_WriteByte
;;;587        /*!< Set response value to success */
;;;588        rvalue = SD_RESPONSE_NO_ERROR;
000048  2600              MOVS     r6,#0
                  |L3.74|
;;;589      }
;;;590      /*!< SD chip select high */
;;;591      SD_CS_HIGH();
00004a  2104              MOVS     r1,#4
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       GPIO_SetBits
;;;592      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;593      SD_WriteByte(SD_DUMMY_BYTE);
000052  20ff              MOVS     r0,#0xff
000054  f7fffffe          BL       SD_WriteByte
;;;594    
;;;595      /*!< Byte 0 */
;;;596      SD_cid->ManufacturerID = CID_Tab[0];
000058  f89d0000          LDRB     r0,[sp,#0]
00005c  7020              STRB     r0,[r4,#0]
;;;597    
;;;598      /*!< Byte 1 */
;;;599      SD_cid->OEM_AppliID = CID_Tab[1] << 8;
00005e  f89d0001          LDRB     r0,[sp,#1]
000062  0200              LSLS     r0,r0,#8
000064  8060              STRH     r0,[r4,#2]
;;;600    
;;;601      /*!< Byte 2 */
;;;602      SD_cid->OEM_AppliID |= CID_Tab[2];
000066  8860              LDRH     r0,[r4,#2]
000068  f89d1002          LDRB     r1,[sp,#2]
00006c  4308              ORRS     r0,r0,r1
00006e  8060              STRH     r0,[r4,#2]
;;;603    
;;;604      /*!< Byte 3 */
;;;605      SD_cid->ProdName1 = CID_Tab[3] << 24;
000070  f89d0003          LDRB     r0,[sp,#3]
000074  0600              LSLS     r0,r0,#24
000076  6060              STR      r0,[r4,#4]
;;;606    
;;;607      /*!< Byte 4 */
;;;608      SD_cid->ProdName1 |= CID_Tab[4] << 16;
000078  6860              LDR      r0,[r4,#4]
00007a  f89d1004          LDRB     r1,[sp,#4]
00007e  ea404001          ORR      r0,r0,r1,LSL #16
000082  6060              STR      r0,[r4,#4]
;;;609    
;;;610      /*!< Byte 5 */
;;;611      SD_cid->ProdName1 |= CID_Tab[5] << 8;
000084  6860              LDR      r0,[r4,#4]
000086  f89d1005          LDRB     r1,[sp,#5]
00008a  ea402001          ORR      r0,r0,r1,LSL #8
00008e  6060              STR      r0,[r4,#4]
;;;612    
;;;613      /*!< Byte 6 */
;;;614      SD_cid->ProdName1 |= CID_Tab[6];
000090  6860              LDR      r0,[r4,#4]
000092  f89d1006          LDRB     r1,[sp,#6]
000096  4308              ORRS     r0,r0,r1
000098  6060              STR      r0,[r4,#4]
;;;615    
;;;616      /*!< Byte 7 */
;;;617      SD_cid->ProdName2 = CID_Tab[7];
00009a  f89d0007          LDRB     r0,[sp,#7]
00009e  7220              STRB     r0,[r4,#8]
;;;618    
;;;619      /*!< Byte 8 */
;;;620      SD_cid->ProdRev = CID_Tab[8];
0000a0  f89d0008          LDRB     r0,[sp,#8]
0000a4  7260              STRB     r0,[r4,#9]
;;;621    
;;;622      /*!< Byte 9 */
;;;623      SD_cid->ProdSN = CID_Tab[9] << 24;
0000a6  f89d0009          LDRB     r0,[sp,#9]
0000aa  0600              LSLS     r0,r0,#24
0000ac  60e0              STR      r0,[r4,#0xc]
;;;624    
;;;625      /*!< Byte 10 */
;;;626      SD_cid->ProdSN |= CID_Tab[10] << 16;
0000ae  68e0              LDR      r0,[r4,#0xc]
0000b0  f89d100a          LDRB     r1,[sp,#0xa]
0000b4  ea404001          ORR      r0,r0,r1,LSL #16
0000b8  60e0              STR      r0,[r4,#0xc]
;;;627    
;;;628      /*!< Byte 11 */
;;;629      SD_cid->ProdSN |= CID_Tab[11] << 8;
0000ba  68e0              LDR      r0,[r4,#0xc]
0000bc  f89d100b          LDRB     r1,[sp,#0xb]
0000c0  ea402001          ORR      r0,r0,r1,LSL #8
0000c4  60e0              STR      r0,[r4,#0xc]
;;;630    
;;;631      /*!< Byte 12 */
;;;632      SD_cid->ProdSN |= CID_Tab[12];
0000c6  68e0              LDR      r0,[r4,#0xc]
0000c8  f89d100c          LDRB     r1,[sp,#0xc]
0000cc  4308              ORRS     r0,r0,r1
0000ce  60e0              STR      r0,[r4,#0xc]
;;;633    
;;;634      /*!< Byte 13 */
;;;635      SD_cid->Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
0000d0  7c21              LDRB     r1,[r4,#0x10]
0000d2  f89d000d          LDRB     r0,[sp,#0xd]
0000d6  ea411110          ORR      r1,r1,r0,LSR #4
0000da  7421              STRB     r1,[r4,#0x10]
;;;636      SD_cid->ManufactDate = (CID_Tab[13] & 0x0F) << 8;
0000dc  0700              LSLS     r0,r0,#28
0000de  0d00              LSRS     r0,r0,#20
0000e0  8260              STRH     r0,[r4,#0x12]
;;;637    
;;;638      /*!< Byte 14 */
;;;639      SD_cid->ManufactDate |= CID_Tab[14];
0000e2  8a60              LDRH     r0,[r4,#0x12]
0000e4  f89d100e          LDRB     r1,[sp,#0xe]
0000e8  4308              ORRS     r0,r0,r1
0000ea  8260              STRH     r0,[r4,#0x12]
;;;640    
;;;641      /*!< Byte 15 */
;;;642      SD_cid->CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
0000ec  f89d000f          LDRB     r0,[sp,#0xf]
0000f0  0840              LSRS     r0,r0,#1
0000f2  7520              STRB     r0,[r4,#0x14]
;;;643      SD_cid->Reserved2 = 1;
0000f4  2001              MOVS     r0,#1
0000f6  7560              STRB     r0,[r4,#0x15]
;;;644    
;;;645      /*!< Return the reponse */
;;;646      return rvalue;
;;;647    }
0000f8  b004              ADD      sp,sp,#0x10
0000fa  4630              MOV      r0,r6                 ;646
0000fc  e8bd81f0          POP      {r4-r8,pc}
;;;648    
                          ENDP

                  |L3.256|
                          DCD      0x48001000

                          AREA ||i.SD_GetCSDRegister||, CODE, READONLY, ALIGN=2

                  SD_GetCSDRegister PROC
;;;438      */
;;;439    SD_Error SD_GetCSDRegister(SD_CSD* SD_csd)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;440    {
;;;441      uint32_t i = 0;
;;;442      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;443      uint8_t CSD_Tab[16];
;;;444    
;;;445      /*!< SD chip select low */
;;;446      SD_CS_LOW();
000004  4f67              LDR      r7,|L4.420|
000006  4604              MOV      r4,r0                 ;440
000008  2600              MOVS     r6,#0                 ;441
00000a  25ff              MOVS     r5,#0xff              ;442
00000c  2104              MOVS     r1,#4
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       GPIO_ResetBits
;;;447      /*!< Send CMD9 (CSD register) or CMD10(CSD register) */
;;;448      SD_SendCmd(SD_CMD_SEND_CSD, 0, 0xFF);
000014  22ff              MOVS     r2,#0xff
000016  2100              MOVS     r1,#0
000018  2009              MOVS     r0,#9
00001a  f7fffffe          BL       SD_SendCmd
;;;449      /*!< Wait for response in the R1 format (0x00 is no errors) */
;;;450      if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       SD_GetResponse
000024  b988              CBNZ     r0,|L4.74|
;;;451      {
;;;452        if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
000026  20fe              MOVS     r0,#0xfe
000028  f7fffffe          BL       SD_GetResponse
00002c  b930              CBNZ     r0,|L4.60|
00002e  466d              MOV      r5,sp                 ;443
                  |L4.48|
;;;453        {
;;;454          for (i = 0; i < 16; i++)
;;;455          {
;;;456            /*!< Store CSD register value on CSD_Tab */
;;;457            CSD_Tab[i] = SD_ReadByte();
000030  f7fffffe          BL       SD_ReadByte
000034  55a8              STRB     r0,[r5,r6]
000036  1c76              ADDS     r6,r6,#1
000038  2e10              CMP      r6,#0x10              ;454
00003a  d3f9              BCC      |L4.48|
                  |L4.60|
;;;458          }
;;;459        }
;;;460        /*!< Get CRC bytes (not really needed by us, but required by SD) */
;;;461        SD_WriteByte(SD_DUMMY_BYTE);
00003c  20ff              MOVS     r0,#0xff
00003e  f7fffffe          BL       SD_WriteByte
;;;462        SD_WriteByte(SD_DUMMY_BYTE);
000042  20ff              MOVS     r0,#0xff
000044  f7fffffe          BL       SD_WriteByte
;;;463        /*!< Set response value to success */
;;;464        rvalue = SD_RESPONSE_NO_ERROR;
000048  2500              MOVS     r5,#0
                  |L4.74|
;;;465      }
;;;466      /*!< SD chip select high */
;;;467      SD_CS_HIGH();
00004a  2104              MOVS     r1,#4
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       GPIO_SetBits
;;;468      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;469      SD_WriteByte(SD_DUMMY_BYTE);
000052  20ff              MOVS     r0,#0xff
000054  f7fffffe          BL       SD_WriteByte
;;;470    
;;;471      /*!< Byte 0 */
;;;472      SD_csd->CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
000058  f89d0000          LDRB     r0,[sp,#0]
00005c  0981              LSRS     r1,r0,#6
00005e  7021              STRB     r1,[r4,#0]
;;;473      SD_csd->SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
000060  f3c00183          UBFX     r1,r0,#2,#4
000064  7061              STRB     r1,[r4,#1]
;;;474      SD_csd->Reserved1 = CSD_Tab[0] & 0x03;
000066  f0000003          AND      r0,r0,#3
00006a  70a0              STRB     r0,[r4,#2]
;;;475    
;;;476      /*!< Byte 1 */
;;;477      SD_csd->TAAC = CSD_Tab[1];
00006c  f89d0001          LDRB     r0,[sp,#1]
000070  70e0              STRB     r0,[r4,#3]
;;;478    
;;;479      /*!< Byte 2 */
;;;480      SD_csd->NSAC = CSD_Tab[2];
000072  f89d0002          LDRB     r0,[sp,#2]
000076  7120              STRB     r0,[r4,#4]
;;;481    
;;;482      /*!< Byte 3 */
;;;483      SD_csd->MaxBusClkFrec = CSD_Tab[3];
000078  f89d0003          LDRB     r0,[sp,#3]
00007c  7160              STRB     r0,[r4,#5]
;;;484    
;;;485      /*!< Byte 4 */
;;;486      SD_csd->CardComdClasses = CSD_Tab[4] << 4;
00007e  f89d0004          LDRB     r0,[sp,#4]
000082  0100              LSLS     r0,r0,#4
000084  80e0              STRH     r0,[r4,#6]
;;;487    
;;;488      /*!< Byte 5 */
;;;489      SD_csd->CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
000086  88e1              LDRH     r1,[r4,#6]
000088  f89d0005          LDRB     r0,[sp,#5]
00008c  ea411110          ORR      r1,r1,r0,LSR #4
000090  80e1              STRH     r1,[r4,#6]
;;;490      SD_csd->RdBlockLen = CSD_Tab[5] & 0x0F;
000092  f000000f          AND      r0,r0,#0xf
000096  7220              STRB     r0,[r4,#8]
;;;491    
;;;492      /*!< Byte 6 */
;;;493      SD_csd->PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
000098  f89d0006          LDRB     r0,[sp,#6]
00009c  09c1              LSRS     r1,r0,#7
00009e  7261              STRB     r1,[r4,#9]
;;;494      SD_csd->WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
0000a0  f3c01180          UBFX     r1,r0,#6,#1
0000a4  72a1              STRB     r1,[r4,#0xa]
;;;495      SD_csd->RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
0000a6  f3c01140          UBFX     r1,r0,#5,#1
0000aa  72e1              STRB     r1,[r4,#0xb]
;;;496      SD_csd->DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
0000ac  f3c01100          UBFX     r1,r0,#4,#1
0000b0  7321              STRB     r1,[r4,#0xc]
;;;497      SD_csd->Reserved2 = 0; /*!< Reserved */
0000b2  2100              MOVS     r1,#0
0000b4  7361              STRB     r1,[r4,#0xd]
;;;498    
;;;499      SD_csd->DeviceSize = (CSD_Tab[6] & 0x03) << 10;
0000b6  0780              LSLS     r0,r0,#30
0000b8  0d00              LSRS     r0,r0,#20
0000ba  6120              STR      r0,[r4,#0x10]
;;;500    
;;;501      /*!< Byte 7 */
;;;502      SD_csd->DeviceSize |= (CSD_Tab[7]) << 2;
0000bc  6920              LDR      r0,[r4,#0x10]
0000be  f89d2007          LDRB     r2,[sp,#7]
0000c2  ea400082          ORR      r0,r0,r2,LSL #2
0000c6  6120              STR      r0,[r4,#0x10]
;;;503    
;;;504      /*!< Byte 8 */
;;;505      SD_csd->DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
0000c8  6922              LDR      r2,[r4,#0x10]
0000ca  f89d0008          LDRB     r0,[sp,#8]
0000ce  ea421290          ORR      r2,r2,r0,LSR #6
0000d2  6122              STR      r2,[r4,#0x10]
;;;506    
;;;507      SD_csd->MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
0000d4  f3c002c2          UBFX     r2,r0,#3,#3
0000d8  7522              STRB     r2,[r4,#0x14]
;;;508      SD_csd->MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
0000da  f0000007          AND      r0,r0,#7
0000de  7560              STRB     r0,[r4,#0x15]
;;;509    
;;;510      /*!< Byte 9 */
;;;511      SD_csd->MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
0000e0  f89d0009          LDRB     r0,[sp,#9]
0000e4  0942              LSRS     r2,r0,#5
0000e6  75a2              STRB     r2,[r4,#0x16]
;;;512      SD_csd->MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
0000e8  f3c00282          UBFX     r2,r0,#2,#3
0000ec  75e2              STRB     r2,[r4,#0x17]
;;;513      SD_csd->DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
0000ee  0780              LSLS     r0,r0,#30
0000f0  0f40              LSRS     r0,r0,#29
0000f2  7620              STRB     r0,[r4,#0x18]
;;;514      /*!< Byte 10 */
;;;515      SD_csd->DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
0000f4  7e22              LDRB     r2,[r4,#0x18]
0000f6  f89d000a          LDRB     r0,[sp,#0xa]
0000fa  ea4212d0          ORR      r2,r2,r0,LSR #7
0000fe  7622              STRB     r2,[r4,#0x18]
;;;516        
;;;517      SD_csd->EraseGrSize = (CSD_Tab[10] & 0x40) >> 6;
000100  f3c01280          UBFX     r2,r0,#6,#1
000104  7662              STRB     r2,[r4,#0x19]
;;;518      SD_csd->EraseGrMul = (CSD_Tab[10] & 0x3F) << 1;
000106  0680              LSLS     r0,r0,#26
000108  0e40              LSRS     r0,r0,#25
00010a  76a0              STRB     r0,[r4,#0x1a]
;;;519    
;;;520      /*!< Byte 11 */
;;;521      SD_csd->EraseGrMul |= (CSD_Tab[11] & 0x80) >> 7;
00010c  7ea2              LDRB     r2,[r4,#0x1a]
00010e  f89d000b          LDRB     r0,[sp,#0xb]
000112  ea4212d0          ORR      r2,r2,r0,LSR #7
000116  76a2              STRB     r2,[r4,#0x1a]
;;;522      SD_csd->WrProtectGrSize = (CSD_Tab[11] & 0x7F);
000118  f000007f          AND      r0,r0,#0x7f
00011c  76e0              STRB     r0,[r4,#0x1b]
;;;523    
;;;524      /*!< Byte 12 */
;;;525      SD_csd->WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
00011e  f89d000c          LDRB     r0,[sp,#0xc]
000122  09c2              LSRS     r2,r0,#7
000124  7722              STRB     r2,[r4,#0x1c]
;;;526      SD_csd->ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
000126  f3c01241          UBFX     r2,r0,#5,#2
00012a  7762              STRB     r2,[r4,#0x1d]
;;;527      SD_csd->WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
00012c  f3c00282          UBFX     r2,r0,#2,#3
000130  77a2              STRB     r2,[r4,#0x1e]
;;;528      SD_csd->MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
000132  0780              LSLS     r0,r0,#30
000134  0f00              LSRS     r0,r0,#28
000136  77e0              STRB     r0,[r4,#0x1f]
;;;529    
;;;530      /*!< Byte 13 */
;;;531      SD_csd->MaxWrBlockLen |= (CSD_Tab[13] & 0xC0) >> 6;
000138  7fe2              LDRB     r2,[r4,#0x1f]
00013a  f89d000d          LDRB     r0,[sp,#0xd]
00013e  ea421290          ORR      r2,r2,r0,LSR #6
000142  77e2              STRB     r2,[r4,#0x1f]
;;;532      SD_csd->WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
000144  f3c01240          UBFX     r2,r0,#5,#1
000148  f8842020          STRB     r2,[r4,#0x20]
;;;533      SD_csd->Reserved3 = 0;
00014c  f8841021          STRB     r1,[r4,#0x21]
;;;534      SD_csd->ContentProtectAppli = (CSD_Tab[13] & 0x01);
000150  f0000001          AND      r0,r0,#1
000154  f8840022          STRB     r0,[r4,#0x22]
;;;535    
;;;536      /*!< Byte 14 */
;;;537      SD_csd->FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
000158  f89d000e          LDRB     r0,[sp,#0xe]
00015c  09c1              LSRS     r1,r0,#7
00015e  f8841023          STRB     r1,[r4,#0x23]
;;;538      SD_csd->CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
000162  f3c01180          UBFX     r1,r0,#6,#1
000166  f8841024          STRB     r1,[r4,#0x24]
;;;539      SD_csd->PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
00016a  f3c01140          UBFX     r1,r0,#5,#1
00016e  f8841025          STRB     r1,[r4,#0x25]
;;;540      SD_csd->TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
000172  f3c01100          UBFX     r1,r0,#4,#1
000176  f8841026          STRB     r1,[r4,#0x26]
;;;541      SD_csd->FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
00017a  f3c00181          UBFX     r1,r0,#2,#2
00017e  f8841027          STRB     r1,[r4,#0x27]
;;;542      SD_csd->ECC = (CSD_Tab[14] & 0x03);
000182  f0000003          AND      r0,r0,#3
000186  f8840028          STRB     r0,[r4,#0x28]
;;;543    
;;;544      /*!< Byte 15 */
;;;545      SD_csd->CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
00018a  f89d000f          LDRB     r0,[sp,#0xf]
00018e  0840              LSRS     r0,r0,#1
000190  f8840029          STRB     r0,[r4,#0x29]
;;;546      SD_csd->Reserved4 = 1;
000194  2001              MOVS     r0,#1
000196  f884002a          STRB     r0,[r4,#0x2a]
;;;547    
;;;548      /*!< Return the reponse */
;;;549      return rvalue;
;;;550    }
00019a  b004              ADD      sp,sp,#0x10
00019c  4628              MOV      r0,r5                 ;549
00019e  e8bd81f0          POP      {r4-r8,pc}
;;;551    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L4.420|
                          DCD      0x48001000

                          AREA ||i.SD_GetCardInfo||, CODE, READONLY, ALIGN=1

                  SD_GetCardInfo PROC
;;;179      */
;;;180    SD_Error SD_GetCardInfo(SD_CardInfo *cardinfo)
000000  b510              PUSH     {r4,lr}
;;;181    {
000002  4604              MOV      r4,r0
;;;182      SD_Error status = SD_RESPONSE_FAILURE;
;;;183    
;;;184      SD_GetCSDRegister(&(cardinfo->SD_csd));
000004  f7fffffe          BL       SD_GetCSDRegister
;;;185      status = SD_GetCIDRegister(&(cardinfo->SD_cid));
000008  f104002c          ADD      r0,r4,#0x2c
00000c  f7fffffe          BL       SD_GetCIDRegister
000010  4602              MOV      r2,r0
;;;186      cardinfo->CardCapacity = (cardinfo->SD_csd.DeviceSize + 1) ;
000012  6920              LDR      r0,[r4,#0x10]
;;;187      cardinfo->CardCapacity *= (1 << (cardinfo->SD_csd.DeviceSizeMul + 2));
000014  7e21              LDRB     r1,[r4,#0x18]
000016  1c40              ADDS     r0,r0,#1
000018  1c89              ADDS     r1,r1,#2
;;;188      cardinfo->CardBlockSize = 1 << (cardinfo->SD_csd.RdBlockLen);
00001a  7a23              LDRB     r3,[r4,#8]
00001c  4088              LSLS     r0,r0,r1              ;187
00001e  2101              MOVS     r1,#1
000020  4099              LSLS     r1,r1,r3
;;;189      cardinfo->CardCapacity *= cardinfo->CardBlockSize;
000022  4348              MULS     r0,r1,r0
;;;190    
;;;191      /*!< Returns the reponse */
;;;192      return status;
000024  e9c40111          STRD     r0,r1,[r4,#0x44]
000028  4610              MOV      r0,r2
;;;193    }
00002a  bd10              POP      {r4,pc}
;;;194    
                          ENDP


                          AREA ||i.SD_GetDataResponse||, CODE, READONLY, ALIGN=1

                  SD_GetDataResponse PROC
;;;688      */
;;;689    uint8_t SD_GetDataResponse(void)
000000  b570              PUSH     {r4-r6,lr}
;;;690    {
;;;691      uint32_t i = 0;
000002  2400              MOVS     r4,#0
                  |L6.4|
;;;692      uint8_t response, rvalue;
;;;693    
;;;694      while (i <= 64)
;;;695      {
;;;696        /*!< Read resonse */
;;;697        response = SD_ReadByte();
000004  f7fffffe          BL       SD_ReadByte
;;;698        /*!< Mask unused bits */
;;;699        response &= 0x1F;
000008  f000051f          AND      r5,r0,#0x1f
;;;700        switch (response)
00000c  2d05              CMP      r5,#5
00000e  d006              BEQ      |L6.30|
000010  2d0b              CMP      r5,#0xb
000012  d00a              BEQ      |L6.42|
000014  2d0d              CMP      r5,#0xd
000016  d00a              BEQ      |L6.46|
000018  1c64              ADDS     r4,r4,#1
00001a  2c40              CMP      r4,#0x40              ;694
;;;701        {
;;;702          case SD_DATA_OK:
;;;703          {
;;;704            rvalue = SD_DATA_OK;
;;;705            break;
;;;706          }
;;;707          case SD_DATA_CRC_ERROR:
;;;708            return SD_DATA_CRC_ERROR;
;;;709          case SD_DATA_WRITE_ERROR:
;;;710            return SD_DATA_WRITE_ERROR;
;;;711          default:
;;;712          {
;;;713            rvalue = SD_DATA_OTHER_ERROR;
;;;714            break;
00001c  d9f2              BLS      |L6.4|
                  |L6.30|
;;;715          }
;;;716        }
;;;717        /*!< Exit loop in case of data ok */
;;;718        if (rvalue == SD_DATA_OK)
;;;719          break;
;;;720        /*!< Increment loop counter */
;;;721        i++;
;;;722      }
;;;723    
;;;724      /*!< Wait null data */
;;;725      while (SD_ReadByte() == 0);
00001e  f7fffffe          BL       SD_ReadByte
000022  2800              CMP      r0,#0
000024  d0fb              BEQ      |L6.30|
;;;726    
;;;727      /*!< Return response */
;;;728      return response;
000026  4628              MOV      r0,r5
;;;729    }
000028  bd70              POP      {r4-r6,pc}
                  |L6.42|
00002a  200b              MOVS     r0,#0xb               ;708
00002c  bd70              POP      {r4-r6,pc}
                  |L6.46|
00002e  200d              MOVS     r0,#0xd               ;710
000030  bd70              POP      {r4-r6,pc}
;;;730    
                          ENDP


                          AREA ||i.SD_GetResponse||, CODE, READONLY, ALIGN=1

                  SD_GetResponse PROC
;;;737      */
;;;738    SD_Error SD_GetResponse(uint8_t Response)
000000  b570              PUSH     {r4-r6,lr}
;;;739    {
000002  4605              MOV      r5,r0
;;;740      uint32_t Count = 0xFFF;
000004  f64074ff          MOV      r4,#0xfff
000008  e000              B        |L7.12|
                  |L7.10|
00000a  1e64              SUBS     r4,r4,#1              ;739
                  |L7.12|
;;;741    
;;;742      /* Check if response is got or a timeout is happen */
;;;743      while ((SD_ReadByte() != Response) && Count)
00000c  f7fffffe          BL       SD_ReadByte
000010  42a8              CMP      r0,r5
000012  d002              BEQ      |L7.26|
000014  2c00              CMP      r4,#0
000016  d1f8              BNE      |L7.10|
000018  e002              B        |L7.32|
                  |L7.26|
;;;744      {
;;;745        Count--;
;;;746      }
;;;747    
;;;748      if (Count == 0)
00001a  b10c              CBZ      r4,|L7.32|
;;;749      {
;;;750        /* After time out */
;;;751        return SD_RESPONSE_FAILURE;
;;;752      }
;;;753      else
;;;754      {
;;;755        /* Right response got */
;;;756        return SD_RESPONSE_NO_ERROR;
00001c  2000              MOVS     r0,#0
;;;757      }
;;;758    }
00001e  bd70              POP      {r4-r6,pc}
                  |L7.32|
000020  20ff              MOVS     r0,#0xff              ;751
000022  bd70              POP      {r4-r6,pc}
;;;759    
                          ENDP


                          AREA ||i.SD_GetStatus||, CODE, READONLY, ALIGN=2

                  SD_GetStatus PROC
;;;764      */
;;;765    uint16_t SD_GetStatus(void)
000000  b570              PUSH     {r4-r6,lr}
;;;766    {
;;;767      uint16_t Status = 0;
;;;768    
;;;769      /*!< SD chip select low */
;;;770      SD_CS_LOW();
000002  4d0d              LDR      r5,|L8.56|
000004  2104              MOVS     r1,#4
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       GPIO_ResetBits
;;;771    
;;;772      /*!< Send CMD13 (SD_SEND_STATUS) to get SD status */
;;;773      SD_SendCmd(SD_CMD_SEND_STATUS, 0, 0xFF);
00000c  22ff              MOVS     r2,#0xff
00000e  2100              MOVS     r1,#0
000010  200d              MOVS     r0,#0xd
000012  f7fffffe          BL       SD_SendCmd
;;;774    
;;;775      Status = SD_ReadByte();
000016  f7fffffe          BL       SD_ReadByte
00001a  4604              MOV      r4,r0
;;;776      Status |= (uint16_t)(SD_ReadByte() << 8);
00001c  f7fffffe          BL       SD_ReadByte
000020  ea442400          ORR      r4,r4,r0,LSL #8
;;;777    
;;;778      /*!< SD chip select high */
;;;779      SD_CS_HIGH();
000024  2104              MOVS     r1,#4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       GPIO_SetBits
;;;780    
;;;781      /*!< Send dummy byte 0xFF */
;;;782      SD_WriteByte(SD_DUMMY_BYTE);
00002c  20ff              MOVS     r0,#0xff
00002e  f7fffffe          BL       SD_WriteByte
;;;783    
;;;784      return Status;
000032  4620              MOV      r0,r4
;;;785    }
000034  bd70              POP      {r4-r6,pc}
;;;786    
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      0x48001000

                          AREA ||i.SD_GoIdleState||, CODE, READONLY, ALIGN=2

                  SD_GoIdleState PROC
;;;793      */
;;;794    SD_Error SD_GoIdleState(void)
000000  b510              PUSH     {r4,lr}
;;;795    {
;;;796      /*!< SD chip select low */
;;;797      SD_CS_LOW();
000002  4c17              LDR      r4,|L9.96|
000004  2104              MOVS     r1,#4
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;798      
;;;799      /*!< Send CMD0 (SD_CMD_GO_IDLE_STATE) to put SD in SPI mode */
;;;800      SD_SendCmd(SD_CMD_GO_IDLE_STATE, 0, 0x95);
00000c  2100              MOVS     r1,#0
00000e  2295              MOVS     r2,#0x95
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       SD_SendCmd
;;;801      
;;;802      /*!< Wait for In Idle State Response (R1 Format) equal to 0x01 */
;;;803      if (SD_GetResponse(SD_IN_IDLE_STATE))
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       SD_GetResponse
00001c  b108              CBZ      r0,|L9.34|
;;;804      {
;;;805        /*!< No Idle State Response: return response failue */
;;;806        return SD_RESPONSE_FAILURE;
00001e  20ff              MOVS     r0,#0xff
;;;807      }
;;;808      /*----------Activates the card initialization process-----------*/
;;;809      do
;;;810      {
;;;811        /*!< SD chip select high */
;;;812        SD_CS_HIGH();
;;;813        
;;;814        /*!< Send Dummy byte 0xFF */
;;;815        SD_WriteByte(SD_DUMMY_BYTE);
;;;816        
;;;817        /*!< SD chip select low */
;;;818        SD_CS_LOW();
;;;819        
;;;820        /*!< Send CMD1 (Activates the card process) until response equal to 0x0 */
;;;821        SD_SendCmd(SD_CMD_SEND_OP_COND, 0, 0xFF);
;;;822        /*!< Wait for no error Response (R1 Format) equal to 0x00 */
;;;823      }
;;;824      while (SD_GetResponse(SD_RESPONSE_NO_ERROR));
;;;825      
;;;826      /*!< SD chip select high */
;;;827      SD_CS_HIGH();
;;;828      
;;;829      /*!< Send dummy byte 0xFF */
;;;830      SD_WriteByte(SD_DUMMY_BYTE);
;;;831      
;;;832      return SD_RESPONSE_NO_ERROR;
;;;833    }
000020  bd10              POP      {r4,pc}
                  |L9.34|
000022  2104              MOVS     r1,#4                 ;812
000024  4620              MOV      r0,r4                 ;812
000026  f7fffffe          BL       GPIO_SetBits
00002a  20ff              MOVS     r0,#0xff              ;815
00002c  f7fffffe          BL       SD_WriteByte
000030  2104              MOVS     r1,#4                 ;818
000032  4620              MOV      r0,r4                 ;818
000034  f7fffffe          BL       GPIO_ResetBits
000038  22ff              MOVS     r2,#0xff              ;821
00003a  2100              MOVS     r1,#0                 ;821
00003c  2001              MOVS     r0,#1                 ;821
00003e  f7fffffe          BL       SD_SendCmd
000042  2000              MOVS     r0,#0                 ;824
000044  f7fffffe          BL       SD_GetResponse
000048  2800              CMP      r0,#0                 ;824
00004a  d1ea              BNE      |L9.34|
00004c  2104              MOVS     r1,#4                 ;827
00004e  4620              MOV      r0,r4                 ;827
000050  f7fffffe          BL       GPIO_SetBits
000054  20ff              MOVS     r0,#0xff              ;830
000056  f7fffffe          BL       SD_WriteByte
00005a  2000              MOVS     r0,#0                 ;832
00005c  bd10              POP      {r4,pc}
;;;834    
                          ENDP

00005e  0000              DCW      0x0000
                  |L9.96|
                          DCD      0x48001000

                          AREA ||i.SD_Init||, CODE, READONLY, ALIGN=2

                  SD_Init PROC
;;;131      */
;;;132    SD_Error SD_Init(void)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134      uint32_t i = 0;
000002  2400              MOVS     r4,#0
;;;135    
;;;136      /*!< Initialize SD_SPI */
;;;137      SD_LowLevel_Init(); 
000004  f7fffffe          BL       SD_LowLevel_Init
;;;138    
;;;139      /*!< SD chip select high */
;;;140      SD_CS_HIGH();
000008  2104              MOVS     r1,#4
00000a  4806              LDR      r0,|L10.36|
00000c  f7fffffe          BL       GPIO_SetBits
                  |L10.16|
;;;141    
;;;142      /*!< Send dummy byte 0xFF, 10 times with CS high */
;;;143      /*!< Rise CS and MOSI for 80 clocks cycles */
;;;144      for (i = 0; i <= 9; i++)
;;;145      {
;;;146        /*!< Send dummy byte 0xFF */
;;;147        SD_WriteByte(SD_DUMMY_BYTE);
000010  20ff              MOVS     r0,#0xff
000012  f7fffffe          BL       SD_WriteByte
000016  1c64              ADDS     r4,r4,#1
000018  2c09              CMP      r4,#9                 ;144
00001a  d9f9              BLS      |L10.16|
;;;148      }
;;;149      
;;;150      /*------------Put SD in SPI mode--------------*/
;;;151      /*!< SD initialized and set to SPI mode properly */
;;;152      return (SD_GoIdleState());
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      SD_GoIdleState
;;;153    }
;;;154    
                          ENDP

                  |L10.36|
                          DCD      0x48001000

                          AREA ||i.SD_ReadBlock||, CODE, READONLY, ALIGN=2

                  SD_ReadBlock PROC
;;;204      */
;;;205    SD_Error SD_ReadBlock(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;206    {
;;;207      uint32_t i = 0;
;;;208      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;209      
;;;210      /*!< SD chip select low */
;;;211      SD_CS_LOW();
000004  f8df905c          LDR      r9,|L11.100|
000008  4688              MOV      r8,r1                 ;206
00000a  4605              MOV      r5,r0                 ;206
00000c  4617              MOV      r7,r2                 ;206
00000e  2400              MOVS     r4,#0                 ;207
000010  26ff              MOVS     r6,#0xff              ;208
000012  2104              MOVS     r1,#4
000014  4648              MOV      r0,r9
000016  f7fffffe          BL       GPIO_ResetBits
;;;212      
;;;213      /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
;;;214      SD_SendCmd(SD_CMD_READ_SINGLE_BLOCK, ReadAddr, 0xFF);
00001a  22ff              MOVS     r2,#0xff
00001c  4641              MOV      r1,r8
00001e  2011              MOVS     r0,#0x11
000020  f7fffffe          BL       SD_SendCmd
;;;215      
;;;216      /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
;;;217      if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       SD_GetResponse
00002a  b988              CBNZ     r0,|L11.80|
;;;218      {
;;;219        /*!< Now look for the data token to signify the start of the data */
;;;220        if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
00002c  20fe              MOVS     r0,#0xfe
00002e  f7fffffe          BL       SD_GetResponse
000032  b130              CBZ      r0,|L11.66|
000034  e00c              B        |L11.80|
;;;221        {
;;;222          /*!< Read the SD block data : read NumByteToRead data */
;;;223          for (i = 0; i < BlockSize; i++)
;;;224          {
;;;225            /*!< Save the received data */
;;;226            *pBuffer = SD_ReadByte();
000036  bf00              NOP      
                  |L11.56|
000038  f7fffffe          BL       SD_ReadByte
00003c  f8050b01          STRB     r0,[r5],#1
000040  1c64              ADDS     r4,r4,#1
                  |L11.66|
000042  42bc              CMP      r4,r7                 ;223
000044  d3f8              BCC      |L11.56|
;;;227           
;;;228            /*!< Point to the next location where the byte read will be saved */
;;;229            pBuffer++;
;;;230          }
;;;231          /*!< Get CRC bytes (not really needed by us, but required by SD) */
;;;232          SD_ReadByte();
000046  f7fffffe          BL       SD_ReadByte
;;;233          SD_ReadByte();
00004a  f7fffffe          BL       SD_ReadByte
;;;234          /*!< Set response value to success */
;;;235          rvalue = SD_RESPONSE_NO_ERROR;
00004e  2600              MOVS     r6,#0
                  |L11.80|
;;;236        }
;;;237      }
;;;238      /*!< SD chip select high */
;;;239      SD_CS_HIGH();
000050  2104              MOVS     r1,#4
000052  4648              MOV      r0,r9
000054  f7fffffe          BL       GPIO_SetBits
;;;240      
;;;241      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;242      SD_WriteByte(SD_DUMMY_BYTE);
000058  20ff              MOVS     r0,#0xff
00005a  f7fffffe          BL       SD_WriteByte
;;;243      
;;;244      /*!< Returns the reponse */
;;;245      return rvalue;
00005e  4630              MOV      r0,r6
;;;246    }
000060  e8bd87f0          POP      {r4-r10,pc}
;;;247    
                          ENDP

                  |L11.100|
                          DCD      0x48001000

                          AREA ||i.SD_ReadByte||, CODE, READONLY, ALIGN=2

                  SD_ReadByte PROC
;;;863      */
;;;864    uint8_t SD_ReadByte(void)
000000  b510              PUSH     {r4,lr}
;;;865    {
;;;866      uint8_t Data = 0;
;;;867      
;;;868      /*!< Wait until the transmit buffer is empty */
;;;869      while (SPI_I2S_GetFlagStatus(SD_SPI, SPI_I2S_FLAG_TXE) == RESET)
000002  4c0b              LDR      r4,|L12.48|
                  |L12.4|
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L12.4|
;;;870      {
;;;871      }
;;;872      /*!< Send the byte */
;;;873      SPI_SendData8(SD_SPI, SD_DUMMY_BYTE);
000010  21ff              MOVS     r1,#0xff
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       SPI_SendData8
                  |L12.24|
;;;874    
;;;875      /*!< Wait until a data is received */
;;;876      while (SPI_I2S_GetFlagStatus(SD_SPI, SPI_I2S_FLAG_RXNE) == RESET)
000018  2101              MOVS     r1,#1
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_I2S_GetFlagStatus
000020  2800              CMP      r0,#0
000022  d0f9              BEQ      |L12.24|
;;;877      {
;;;878      }
;;;879      /*!< Get the received data */
;;;880      Data = SPI_ReceiveData8(SD_SPI);
000024  4620              MOV      r0,r4
000026  e8bd4010          POP      {r4,lr}
00002a  f7ffbffe          B.W      SPI_ReceiveData8
;;;881    
;;;882      /*!< Return the shifted data */
;;;883      return Data;
;;;884    }
;;;885    
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x40003c00

                          AREA ||i.SD_ReadMultiBlocks||, CODE, READONLY, ALIGN=2

                  SD_ReadMultiBlocks PROC
;;;258      */
;;;259    SD_Error SD_ReadMultiBlocks(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;260    {
;;;261      uint32_t i = 0, Offset = 0;
;;;262      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;263      
;;;264      /*!< SD chip select low */
;;;265      SD_CS_LOW();
000004  f8dfa078          LDR      r10,|L13.128|
000008  4689              MOV      r9,r1                 ;260
00000a  4605              MOV      r5,r0                 ;260
00000c  461e              MOV      r6,r3                 ;260
00000e  4617              MOV      r7,r2                 ;260
000010  f04f0800          MOV      r8,#0                 ;261
000014  24ff              MOVS     r4,#0xff              ;262
000016  2104              MOVS     r1,#4
000018  4650              MOV      r0,r10
00001a  f7fffffe          BL       GPIO_ResetBits
;;;266      /*!< Data transfer */
;;;267      while (NumberOfBlocks--)
00001e  e011              B        |L13.68|
                  |L13.32|
;;;268      {
;;;269        /*!< Send CMD17 (SD_CMD_READ_SINGLE_BLOCK) to read one block */
;;;270        SD_SendCmd (SD_CMD_READ_SINGLE_BLOCK, ReadAddr + Offset, 0xFF);
000020  eb090108          ADD      r1,r9,r8
000024  22ff              MOVS     r2,#0xff
000026  2011              MOVS     r0,#0x11
000028  f7fffffe          BL       SD_SendCmd
;;;271        /*!< Check if the SD acknowledged the read block command: R1 response (0x00: no errors) */
;;;272        if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SD_GetResponse
000032  b110              CBZ      r0,|L13.58|
;;;273        {
;;;274          return  SD_RESPONSE_FAILURE;
000034  20ff              MOVS     r0,#0xff
                  |L13.54|
;;;275        }
;;;276        /*!< Now look for the data token to signify the start of the data */
;;;277        if (!SD_GetResponse(SD_START_DATA_SINGLE_BLOCK_READ))
;;;278        {
;;;279          /*!< Read the SD block data : read NumByteToRead data */
;;;280          for (i = 0; i < BlockSize; i++)
;;;281          {
;;;282            /*!< Read the pointed data */
;;;283            *pBuffer = SD_ReadByte();
;;;284            /*!< Point to the next location where the byte read will be saved */
;;;285            pBuffer++;
;;;286          }
;;;287          /*!< Set next read address*/
;;;288          Offset += 512;
;;;289          /*!< get CRC bytes (not really needed by us, but required by SD) */
;;;290          SD_ReadByte();
;;;291          SD_ReadByte();
;;;292          /*!< Set response value to success */
;;;293          rvalue = SD_RESPONSE_NO_ERROR;
;;;294        }
;;;295        else
;;;296        {
;;;297          /*!< Set response value to failure */
;;;298          rvalue = SD_RESPONSE_FAILURE;
;;;299        }
;;;300      }
;;;301      /*!< SD chip select high */
;;;302      SD_CS_HIGH();
;;;303      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;304      SD_WriteByte(SD_DUMMY_BYTE);
;;;305      /*!< Returns the reponse */
;;;306      return rvalue;
;;;307    }
000036  e8bd87f0          POP      {r4-r10,pc}
                  |L13.58|
00003a  20fe              MOVS     r0,#0xfe              ;277
00003c  f7fffffe          BL       SD_GetResponse
000040  b158              CBZ      r0,|L13.90|
000042  24ff              MOVS     r4,#0xff              ;298
                  |L13.68|
000044  1e76              SUBS     r6,r6,#1              ;298
000046  d2eb              BCS      |L13.32|
000048  2104              MOVS     r1,#4                 ;302
00004a  4650              MOV      r0,r10                ;302
00004c  f7fffffe          BL       GPIO_SetBits
000050  20ff              MOVS     r0,#0xff              ;304
000052  f7fffffe          BL       SD_WriteByte
000056  4620              MOV      r0,r4                 ;306
000058  e7ed              B        |L13.54|
                  |L13.90|
00005a  2400              MOVS     r4,#0                 ;280
00005c  e005              B        |L13.106|
00005e  bf00              NOP                            ;283
                  |L13.96|
000060  f7fffffe          BL       SD_ReadByte
000064  f8050b01          STRB     r0,[r5],#1            ;283
000068  1c64              ADDS     r4,r4,#1              ;283
                  |L13.106|
00006a  42bc              CMP      r4,r7                 ;280
00006c  d3f8              BCC      |L13.96|
00006e  f5087800          ADD      r8,r8,#0x200          ;288
000072  f7fffffe          BL       SD_ReadByte
000076  f7fffffe          BL       SD_ReadByte
00007a  2400              MOVS     r4,#0                 ;293
00007c  e7e2              B        |L13.68|
;;;308    
                          ENDP

00007e  0000              DCW      0x0000
                  |L13.128|
                          DCD      0x48001000

                          AREA ||i.SD_SendCmd||, CODE, READONLY, ALIGN=1

                  SD_SendCmd PROC
;;;655      */
;;;656    void SD_SendCmd(uint8_t Cmd, uint32_t Arg, uint8_t Crc)
000000  b57c              PUSH     {r2-r6,lr}
;;;657    {
;;;658      uint32_t i = 0x00;
;;;659      
;;;660      uint8_t Frame[6];
;;;661      
;;;662      Frame[0] = (Cmd | 0x40); /*!< Construct byte 1 */
000002  f0400040          ORR      r0,r0,#0x40
000006  f88d0000          STRB     r0,[sp,#0]
;;;663      
;;;664      Frame[1] = (uint8_t)(Arg >> 24); /*!< Construct byte 2 */
00000a  0e08              LSRS     r0,r1,#24
00000c  f88d0001          STRB     r0,[sp,#1]
;;;665      
;;;666      Frame[2] = (uint8_t)(Arg >> 16); /*!< Construct byte 3 */
000010  0c08              LSRS     r0,r1,#16
000012  2400              MOVS     r4,#0                 ;658
000014  f88d0002          STRB     r0,[sp,#2]
;;;667      
;;;668      Frame[3] = (uint8_t)(Arg >> 8); /*!< Construct byte 4 */
000018  0a08              LSRS     r0,r1,#8
;;;669      
;;;670      Frame[4] = (uint8_t)(Arg); /*!< Construct byte 5 */
00001a  f88d1004          STRB     r1,[sp,#4]
00001e  f88d0003          STRB     r0,[sp,#3]            ;668
;;;671      
;;;672      Frame[5] = (Crc); /*!< Construct CRC: byte 6 */
000022  f88d2005          STRB     r2,[sp,#5]
000026  466d              MOV      r5,sp                 ;660
                  |L14.40|
;;;673      
;;;674      for (i = 0; i < 6; i++)
;;;675      {
;;;676        SD_WriteByte(Frame[i]); /*!< Send the Cmd bytes */
000028  5d28              LDRB     r0,[r5,r4]
00002a  f7fffffe          BL       SD_WriteByte
00002e  1c64              ADDS     r4,r4,#1
000030  2c06              CMP      r4,#6                 ;674
000032  d3f9              BCC      |L14.40|
;;;677      }
;;;678    }
000034  bd7c              POP      {r2-r6,pc}
;;;679    
                          ENDP


                          AREA ||i.SD_WriteBlock||, CODE, READONLY, ALIGN=2

                  SD_WriteBlock PROC
;;;318      */
;;;319    SD_Error SD_WriteBlock(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;320    {
;;;321      uint32_t i = 0;
;;;322      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;323    
;;;324      /*!< SD chip select low */
;;;325      SD_CS_LOW();
000004  f8df9068          LDR      r9,|L15.112|
000008  4688              MOV      r8,r1                 ;320
00000a  4605              MOV      r5,r0                 ;320
00000c  4617              MOV      r7,r2                 ;320
00000e  2400              MOVS     r4,#0                 ;321
000010  26ff              MOVS     r6,#0xff              ;322
000012  2104              MOVS     r1,#4
000014  4648              MOV      r0,r9
000016  f7fffffe          BL       GPIO_ResetBits
;;;326    
;;;327      /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write multiple block */
;;;328      SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr, 0xFF);
00001a  22ff              MOVS     r2,#0xff
00001c  4641              MOV      r1,r8
00001e  2018              MOVS     r0,#0x18
000020  f7fffffe          BL       SD_SendCmd
;;;329      
;;;330      /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
;;;331      if (!SD_GetResponse(SD_RESPONSE_NO_ERROR))
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       SD_GetResponse
00002a  b9b0              CBNZ     r0,|L15.90|
;;;332      {
;;;333        /*!< Send a dummy byte */
;;;334        SD_WriteByte(SD_DUMMY_BYTE);
00002c  20ff              MOVS     r0,#0xff
00002e  f7fffffe          BL       SD_WriteByte
;;;335    
;;;336        /*!< Send the data token to signify the start of the data */
;;;337        SD_WriteByte(0xFE);
000032  20fe              MOVS     r0,#0xfe
000034  f7fffffe          BL       SD_WriteByte
;;;338    
;;;339        /*!< Write the block data to SD : write count data by block */
;;;340        for (i = 0; i < BlockSize; i++)
000038  e004              B        |L15.68|
                  |L15.58|
;;;341        {
;;;342          /*!< Send the pointed byte */
;;;343          SD_WriteByte(*pBuffer);
00003a  7828              LDRB     r0,[r5,#0]
00003c  f7fffffe          BL       SD_WriteByte
000040  1c64              ADDS     r4,r4,#1
000042  1c6d              ADDS     r5,r5,#1
                  |L15.68|
000044  42bc              CMP      r4,r7                 ;340
000046  d3f8              BCC      |L15.58|
;;;344          /*!< Point to the next location where the byte read will be saved */
;;;345          pBuffer++;
;;;346        }
;;;347        /*!< Put CRC bytes (not really needed by us, but required by SD) */
;;;348        SD_ReadByte();
000048  f7fffffe          BL       SD_ReadByte
;;;349        SD_ReadByte();
00004c  f7fffffe          BL       SD_ReadByte
;;;350        /*!< Read data response */
;;;351        if (SD_GetDataResponse() == SD_DATA_OK)
000050  f7fffffe          BL       SD_GetDataResponse
000054  2805              CMP      r0,#5
000056  d100              BNE      |L15.90|
;;;352        {
;;;353          rvalue = SD_RESPONSE_NO_ERROR;
000058  2600              MOVS     r6,#0
                  |L15.90|
;;;354        }
;;;355      }
;;;356      /*!< SD chip select high */
;;;357      SD_CS_HIGH();
00005a  2104              MOVS     r1,#4
00005c  4648              MOV      r0,r9
00005e  f7fffffe          BL       GPIO_SetBits
;;;358      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;359      SD_WriteByte(SD_DUMMY_BYTE);
000062  20ff              MOVS     r0,#0xff
000064  f7fffffe          BL       SD_WriteByte
;;;360    
;;;361      /*!< Returns the reponse */
;;;362      return rvalue;
000068  4630              MOV      r0,r6
;;;363    }
00006a  e8bd87f0          POP      {r4-r10,pc}
;;;364    
                          ENDP

00006e  0000              DCW      0x0000
                  |L15.112|
                          DCD      0x48001000

                          AREA ||i.SD_WriteByte||, CODE, READONLY, ALIGN=2

                  SD_WriteByte PROC
;;;839      */
;;;840    uint8_t SD_WriteByte(uint8_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;841    {
;;;842      /*!< Wait until the transmit buffer is empty */
;;;843      while(SPI_I2S_GetFlagStatus(SD_SPI, SPI_I2S_FLAG_TXE) == RESET)
000002  4c0b              LDR      r4,|L16.48|
000004  4605              MOV      r5,r0                 ;841
                  |L16.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L16.6|
;;;844      {
;;;845      }
;;;846      
;;;847      /*!< Send the byte */
;;;848      SPI_SendData8(SD_SPI, Data);
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_SendData8
                  |L16.26|
;;;849      
;;;850      /*!< Wait to receive a byte*/
;;;851      while(SPI_I2S_GetFlagStatus(SD_SPI, SPI_I2S_FLAG_RXNE) == RESET)
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L16.26|
;;;852      {
;;;853      }
;;;854      
;;;855      /*!< Return the byte read from the SPI bus */ 
;;;856      return SPI_ReceiveData8(SD_SPI);
000026  4620              MOV      r0,r4
000028  e8bd4070          POP      {r4-r6,lr}
00002c  f7ffbffe          B.W      SPI_ReceiveData8
;;;857    }
;;;858    
                          ENDP

                  |L16.48|
                          DCD      0x40003c00

                          AREA ||i.SD_WriteMultiBlocks||, CODE, READONLY, ALIGN=2

                  SD_WriteMultiBlocks PROC
;;;375      */
;;;376    SD_Error SD_WriteMultiBlocks(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t BlockSize, uint32_t NumberOfBlocks)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;377    {
;;;378      uint32_t i = 0, Offset = 0;
;;;379      SD_Error rvalue = SD_RESPONSE_FAILURE;
;;;380    
;;;381      /*!< SD chip select low */
;;;382      SD_CS_LOW();
000004  f8dfa080          LDR      r10,|L17.136|
000008  4689              MOV      r9,r1                 ;377
00000a  4605              MOV      r5,r0                 ;377
00000c  461e              MOV      r6,r3                 ;377
00000e  4617              MOV      r7,r2                 ;377
000010  f04f0800          MOV      r8,#0                 ;378
000014  24ff              MOVS     r4,#0xff              ;379
000016  2104              MOVS     r1,#4
000018  4650              MOV      r0,r10
00001a  f7fffffe          BL       GPIO_ResetBits
;;;383      /*!< Data transfer */
;;;384      while (NumberOfBlocks--)
00001e  e025              B        |L17.108|
                  |L17.32|
;;;385      {
;;;386        /*!< Send CMD24 (SD_CMD_WRITE_SINGLE_BLOCK) to write blocks */
;;;387        SD_SendCmd(SD_CMD_WRITE_SINGLE_BLOCK, WriteAddr + Offset, 0xFF);
000020  eb090108          ADD      r1,r9,r8
000024  22ff              MOVS     r2,#0xff
000026  2018              MOVS     r0,#0x18
000028  f7fffffe          BL       SD_SendCmd
;;;388        /*!< Check if the SD acknowledged the write block command: R1 response (0x00: no errors) */
;;;389        if (SD_GetResponse(SD_RESPONSE_NO_ERROR))
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SD_GetResponse
000032  2800              CMP      r0,#0
;;;390        {
;;;391          return SD_RESPONSE_FAILURE;
;;;392        }
;;;393        /*!< Send dummy byte */
;;;394        SD_WriteByte(SD_DUMMY_BYTE);
000034  f04f00ff          MOV      r0,#0xff
000038  d122              BNE      |L17.128|
00003a  f7fffffe          BL       SD_WriteByte
;;;395        /*!< Send the data token to signify the start of the data */
;;;396        SD_WriteByte(SD_START_DATA_SINGLE_BLOCK_WRITE);
00003e  20fe              MOVS     r0,#0xfe
000040  f7fffffe          BL       SD_WriteByte
;;;397        /*!< Write the block data to SD : write count data by block */
;;;398        for (i = 0; i < BlockSize; i++)
000044  2400              MOVS     r4,#0
000046  e004              B        |L17.82|
                  |L17.72|
;;;399        {
;;;400          /*!< Send the pointed byte */
;;;401          SD_WriteByte(*pBuffer);
000048  7828              LDRB     r0,[r5,#0]
00004a  f7fffffe          BL       SD_WriteByte
00004e  1c64              ADDS     r4,r4,#1
000050  1c6d              ADDS     r5,r5,#1
                  |L17.82|
000052  42bc              CMP      r4,r7                 ;398
000054  d3f8              BCC      |L17.72|
;;;402          /*!< Point to the next location where the byte read will be saved */
;;;403          pBuffer++;
;;;404        }
;;;405        /*!< Set next write address */
;;;406        Offset += 512;
000056  f5087800          ADD      r8,r8,#0x200
;;;407        /*!< Put CRC bytes (not really needed by us, but required by SD) */
;;;408        SD_ReadByte();
00005a  f7fffffe          BL       SD_ReadByte
;;;409        SD_ReadByte();
00005e  f7fffffe          BL       SD_ReadByte
;;;410        /*!< Read data response */
;;;411        if (SD_GetDataResponse() == SD_DATA_OK)
000062  f7fffffe          BL       SD_GetDataResponse
000066  2805              CMP      r0,#5
000068  d00c              BEQ      |L17.132|
;;;412        {
;;;413          /*!< Set response value to success */
;;;414          rvalue = SD_RESPONSE_NO_ERROR;
;;;415        }
;;;416        else
;;;417        {
;;;418          /*!< Set response value to failure */
;;;419          rvalue = SD_RESPONSE_FAILURE;
00006a  24ff              MOVS     r4,#0xff
                  |L17.108|
00006c  1e76              SUBS     r6,r6,#1
00006e  d2d7              BCS      |L17.32|
;;;420        }
;;;421      }
;;;422      /*!< SD chip select high */
;;;423      SD_CS_HIGH();
000070  2104              MOVS     r1,#4
000072  4650              MOV      r0,r10
000074  f7fffffe          BL       GPIO_SetBits
;;;424      /*!< Send dummy byte: 8 Clock pulses of delay */
;;;425      SD_WriteByte(SD_DUMMY_BYTE);
000078  20ff              MOVS     r0,#0xff
00007a  f7fffffe          BL       SD_WriteByte
;;;426      /*!< Returns the reponse */
;;;427      return rvalue;
00007e  4620              MOV      r0,r4
                  |L17.128|
;;;428    }
000080  e8bd87f0          POP      {r4-r10,pc}
                  |L17.132|
000084  2400              MOVS     r4,#0                 ;414
000086  e7f1              B        |L17.108|
;;;429    
                          ENDP

                  |L17.136|
                          DCD      0x48001000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Utilities\\STM32_EVAL\\STM32373C_EVAL\\stm32373c_eval_spi_sd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_stm32373c_eval_spi_sd_c_57851845____REV16|
#line 138 "D:\\MDK\\install\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___23_stm32373c_eval_spi_sd_c_57851845____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_stm32373c_eval_spi_sd_c_57851845____REVSH|
#line 153
|__asm___23_stm32373c_eval_spi_sd_c_57851845____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_stm32373c_eval_spi_sd_c_57851845____RRX|
#line 328
|__asm___23_stm32373c_eval_spi_sd_c_57851845____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
