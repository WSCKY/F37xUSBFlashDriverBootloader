; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32373c_eval\usb_pwr.o --asm_dir=.\STM32373C_EVAL\ --list_dir=.\STM32373C_EVAL\ --depend=.\stm32373c_eval\usb_pwr.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F37x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F37x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32373C_EVAL -IE:\STM32F373_USB_BootLoader\Projects\Mass_Storage_RAM\MDK-ARM\RTE -ID:\MDK\install\ARM\PACK\ARM\CMSIS\4.3.0\CMSIS\Include -ID:\MDK\install\ARM\PACK\Keil\STM32F3xx_DFP\1.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F37X -DUSE_STDPERIPH_DRIVER -DSTM32F37X -DUSE_STM32373C_EVAL --omf_browse=.\stm32373c_eval\usb_pwr.crf ..\src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;93     *******************************************************************************/
;;;94     RESULT PowerOff()
000000  b570              PUSH     {r4-r6,lr}
;;;95     {
;;;96       /* disable all interrupts and force USB reset */
;;;97       _SetCNTR(CNTR_FRES);
000002  4c07              LDR      r4,|L1.32|
000004  2001              MOVS     r0,#1
000006  6020              STR      r0,[r4,#0]
;;;98       /* clear interrupt status register */
;;;99       _SetISTR(0);
000008  2500              MOVS     r5,#0
00000a  1d20              ADDS     r0,r4,#4
00000c  6005              STR      r5,[r0,#0]
;;;100      /* Disable the Pull-Up*/
;;;101      USB_Cable_Config(DISABLE);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       USB_Cable_Config
;;;102      /* switch-off device */
;;;103      _SetCNTR(CNTR_FRES + CNTR_PDWN);
000014  2003              MOVS     r0,#3
000016  6020              STR      r0,[r4,#0]
;;;104      /* sw variables reset */
;;;105      /* ... */
;;;106      bDeviceState = UNCONNECTED;
000018  4802              LDR      r0,|L1.36|
00001a  6045              STR      r5,[r0,#4]  ; bDeviceState
;;;107      return USB_SUCCESS;
00001c  2000              MOVS     r0,#0
;;;108    }
00001e  bd70              POP      {r4-r6,pc}
;;;109    
                          ENDP

                  |L1.32|
                          DCD      0x40005c40
                  |L1.36|
                          DCD      ||.data||

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;63     *******************************************************************************/
;;;64     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66       uint16_t wRegVal;
;;;67     
;;;68       /*** cable plugged-in ? ***/
;;;69       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;70     
;;;71       /*** CNTR_PWDN = 0 ***/
;;;72       wRegVal = CNTR_FRES;
;;;73       _SetCNTR(wRegVal);
000008  4806              LDR      r0,|L2.36|
00000a  2101              MOVS     r1,#1                 ;72
00000c  6001              STR      r1,[r0,#0]
;;;74     
;;;75       /*** CNTR_FRES = 0 ***/
;;;76       wInterrupt_Mask = 0;
00000e  2100              MOVS     r1,#0
000010  4a05              LDR      r2,|L2.40|
;;;77       _SetCNTR(wInterrupt_Mask);
000012  6001              STR      r1,[r0,#0]
;;;78       /*** Clear pending interrupts ***/
;;;79       _SetISTR(0);
000014  1d03              ADDS     r3,r0,#4
000016  6019              STR      r1,[r3,#0]
;;;80       /*** Set interrupt mask ***/
;;;81       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000018  f44f51e0          MOV      r1,#0x1c00
00001c  8011              STRH     r1,[r2,#0]
;;;82       _SetCNTR(wInterrupt_Mask);
00001e  6001              STR      r1,[r0,#0]
;;;83       
;;;84       return USB_SUCCESS;
000020  2000              MOVS     r0,#0
;;;85     }
000022  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  |L2.36|
                          DCD      0x40005c40
                  |L2.40|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;258    *******************************************************************************/
;;;259    void Resume(RESUME_STATE eResumeSetVal)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;260    {
;;;261      uint16_t wCNTR;
;;;262    
;;;263      if (eResumeSetVal != RESUME_ESOF)
;;;264        ResumeS.eState = eResumeSetVal;
000004  4c21              LDR      r4,|L3.140|
000006  2807              CMP      r0,#7                 ;263
000008  d000              BEQ      |L3.12|
00000a  7020              STRB     r0,[r4,#0]
                  |L3.12|
;;;265      switch (ResumeS.eState)
00000c  7822              LDRB     r2,[r4,#0]  ; ResumeS
;;;266      {
;;;267        case RESUME_EXTERNAL:
;;;268          if (remotewakeupon ==0)
00000e  4d1f              LDR      r5,|L3.140|
;;;269          {
;;;270            Resume_Init();
;;;271            ResumeS.eState = RESUME_OFF;
000010  2706              MOVS     r7,#6
;;;272          }
;;;273          else /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/
;;;274          {
;;;275            ResumeS.eState = RESUME_ON;
000012  2105              MOVS     r1,#5
;;;276          }
;;;277          break;
;;;278        case RESUME_INTERNAL:
;;;279          Resume_Init();
;;;280          ResumeS.eState = RESUME_START;
000014  2604              MOVS     r6,#4
;;;281          remotewakeupon = 1;
;;;282          break;
;;;283        case RESUME_LATER:
;;;284          ResumeS.bESOFcnt = 2;
;;;285          ResumeS.eState = RESUME_WAIT;
;;;286          break;
;;;287        case RESUME_WAIT:
;;;288          ResumeS.bESOFcnt--;
;;;289          if (ResumeS.bESOFcnt == 0)
;;;290            ResumeS.eState = RESUME_START;
;;;291          break;
;;;292        case RESUME_START:
;;;293          wCNTR = _GetCNTR();
000016  481e              LDR      r0,|L3.144|
000018  2a06              CMP      r2,#6                 ;265
00001a  d20b              BCS      |L3.52|
00001c  e8dff002          TBB      [pc,r2]               ;265
000020  030c1116          DCB      0x03,0x0c,0x11,0x16
000024  1e27              DCB      0x1e,0x27
000026  68a8              LDR      r0,[r5,#8]            ;268  ; remotewakeupon
000028  b110              CBZ      r0,|L3.48|
00002a  7021              STRB     r1,[r4,#0]            ;275
                  |L3.44|
;;;294          wCNTR |= CNTR_RESUME;
;;;295          _SetCNTR(wCNTR);
;;;296          ResumeS.eState = RESUME_ON;
;;;297          ResumeS.bESOFcnt = 10;
;;;298          break;
;;;299        case RESUME_ON:    
;;;300          ResumeS.bESOFcnt--;
;;;301          if (ResumeS.bESOFcnt == 0)
;;;302          {
;;;303            wCNTR = _GetCNTR();
;;;304            wCNTR &= (~CNTR_RESUME);
;;;305            _SetCNTR(wCNTR);
;;;306            ResumeS.eState = RESUME_OFF;
;;;307            remotewakeupon = 0;
;;;308          }
;;;309          break;
;;;310        case RESUME_OFF:
;;;311        case RESUME_ESOF:
;;;312        default:
;;;313          ResumeS.eState = RESUME_OFF;
;;;314          break;
;;;315      }
;;;316    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L3.48|
000030  f7fffffe          BL       Resume_Init
                  |L3.52|
000034  7027              STRB     r7,[r4,#0]            ;313
000036  e7f9              B        |L3.44|
000038  f7fffffe          BL       Resume_Init
00003c  7026              STRB     r6,[r4,#0]            ;280
00003e  2001              MOVS     r0,#1                 ;281
000040  e022              B        |L3.136|
000042  2002              MOVS     r0,#2                 ;284
000044  7060              STRB     r0,[r4,#1]            ;284
000046  2003              MOVS     r0,#3                 ;285
000048  7020              STRB     r0,[r4,#0]            ;285
00004a  e7ef              B        |L3.44|
00004c  7860              LDRB     r0,[r4,#1]            ;288  ; ResumeS
00004e  1e40              SUBS     r0,r0,#1              ;288
000050  7060              STRB     r0,[r4,#1]            ;288
000052  7860              LDRB     r0,[r4,#1]            ;289  ; ResumeS
000054  2800              CMP      r0,#0                 ;289
000056  d1e9              BNE      |L3.44|
000058  7026              STRB     r6,[r4,#0]            ;290
00005a  e7e7              B        |L3.44|
00005c  6802              LDR      r2,[r0,#0]            ;293
00005e  b292              UXTH     r2,r2                 ;293
000060  f0420210          ORR      r2,r2,#0x10           ;294
000064  6002              STR      r2,[r0,#0]            ;295
000066  7021              STRB     r1,[r4,#0]            ;296
000068  200a              MOVS     r0,#0xa               ;297
00006a  7060              STRB     r0,[r4,#1]            ;297
00006c  e7de              B        |L3.44|
00006e  7861              LDRB     r1,[r4,#1]            ;300  ; ResumeS
000070  1e49              SUBS     r1,r1,#1              ;300
000072  7061              STRB     r1,[r4,#1]            ;300
000074  7861              LDRB     r1,[r4,#1]            ;301  ; ResumeS
000076  2900              CMP      r1,#0                 ;301
000078  d1d8              BNE      |L3.44|
00007a  6801              LDR      r1,[r0,#0]            ;303
00007c  b289              UXTH     r1,r1                 ;303
00007e  f0210110          BIC      r1,r1,#0x10           ;304
000082  6001              STR      r1,[r0,#0]            ;305
000084  7027              STRB     r7,[r4,#0]            ;306
000086  2000              MOVS     r0,#0                 ;307
                  |L3.136|
000088  60a8              STR      r0,[r5,#8]            ;281  ; remotewakeupon
00008a  e7cf              B        |L3.44|
;;;317    
                          ENDP

                  |L3.140|
                          DCD      ||.data||
                  |L3.144|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;221    *******************************************************************************/
;;;222    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224      uint16_t wCNTR;
;;;225      
;;;226      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;227      /* restart the clocks */
;;;228      /* ...  */
;;;229    
;;;230      /* CNTR_LPMODE = 0 */
;;;231      wCNTR = _GetCNTR();
000002  4c06              LDR      r4,|L4.28|
000004  6820              LDR      r0,[r4,#0]
000006  b280              UXTH     r0,r0
;;;232      wCNTR &= (~CNTR_LPMODE);
000008  f0200004          BIC      r0,r0,#4
;;;233      _SetCNTR(wCNTR);    
00000c  6020              STR      r0,[r4,#0]
;;;234      
;;;235      /* restore full power */
;;;236      /* ... on connected devices */
;;;237      Leave_LowPowerMode();
00000e  f7fffffe          BL       Leave_LowPowerMode
;;;238    
;;;239      /* reset FSUSP bit */
;;;240      _SetCNTR(IMR_MSK);
000012  f44f403f          MOV      r0,#0xbf00
000016  6020              STR      r0,[r4,#0]
;;;241    
;;;242      /* reverse suspend preparation */
;;;243      /* ... */ 
;;;244    
;;;245    }
000018  bd10              POP      {r4,pc}
;;;246    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;116    *******************************************************************************/
;;;117    void Suspend(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;118    {
;;;119    	uint32_t i =0;
;;;120    	uint16_t wCNTR;
;;;121    	uint32_t tmpreg = 0;
;;;122      __IO uint32_t savePWR_CR=0;
;;;123    	/* suspend preparation */
;;;124    	/* ... */
;;;125    	
;;;126    	/*Store CNTR value */
;;;127    	wCNTR = _GetCNTR();  
000002  4925              LDR      r1,|L5.152|
000004  2000              MOVS     r0,#0                 ;119
000006  9000              STR      r0,[sp,#0]
000008  680a              LDR      r2,[r1,#0]
;;;128    
;;;129        /* This a sequence to apply a force RESET to handle a robustness case */
;;;130        
;;;131    	/*Store endpoints registers status */
;;;132        for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
00000a  4c24              LDR      r4,|L5.156|
00000c  4d24              LDR      r5,|L5.160|
00000e  b292              UXTH     r2,r2                 ;127
                  |L5.16|
000010  eb040380          ADD      r3,r4,r0,LSL #2
000014  f8d33c00          LDR      r3,[r3,#0xc00]
000018  b29b              UXTH     r3,r3
00001a  f8453020          STR      r3,[r5,r0,LSL #2]
00001e  1c40              ADDS     r0,r0,#1
000020  2808              CMP      r0,#8
000022  d3f5              BCC      |L5.16|
;;;133    	
;;;134    	/* unmask RESET flag */
;;;135    	wCNTR|=CNTR_RESETM;
000024  f4426080          ORR      r0,r2,#0x400
;;;136    	_SetCNTR(wCNTR);
000028  6008              STR      r0,[r1,#0]
;;;137    	
;;;138    	/*apply FRES */
;;;139    	wCNTR|=CNTR_FRES;
00002a  f0400001          ORR      r0,r0,#1
;;;140    	_SetCNTR(wCNTR);
00002e  6008              STR      r0,[r1,#0]
;;;141    	
;;;142    	/*clear FRES*/
;;;143    	wCNTR&=~CNTR_FRES;
000030  f0200301          BIC      r3,r0,#1
;;;144    	_SetCNTR(wCNTR);
000034  600b              STR      r3,[r1,#0]
;;;145    	
;;;146    	/*poll for RESET flag in ISTR*/
;;;147    	while((_GetISTR()&ISTR_RESET) == 0);
000036  4a18              LDR      r2,|L5.152|
000038  1d12              ADDS     r2,r2,#4
                  |L5.58|
00003a  6810              LDR      r0,[r2,#0]
00003c  0540              LSLS     r0,r0,#21
00003e  d5fc              BPL      |L5.58|
;;;148    	
;;;149    	/* clear RESET flag in ISTR */
;;;150    	_SetISTR((uint16_t)CLR_RESET);
000040  f64f30ff          MOV      r0,#0xfbff
000044  6010              STR      r0,[r2,#0]
;;;151    	
;;;152    	/*restore Enpoints*/
;;;153    	for (i=0;i<8;i++)
000046  2000              MOVS     r0,#0
                  |L5.72|
;;;154    	_SetENDPOINT(i, EP[i]);
000048  f8556020          LDR      r6,[r5,r0,LSL #2]
00004c  eb040780          ADD      r7,r4,r0,LSL #2
000050  b2b6              UXTH     r6,r6
000052  f8c76c00          STR      r6,[r7,#0xc00]
000056  1c40              ADDS     r0,r0,#1
000058  2808              CMP      r0,#8                 ;153
00005a  d3f5              BCC      |L5.72|
;;;155    	
;;;156    	/* Now it is safe to enter macrocell in suspend mode */
;;;157    	wCNTR |= CNTR_FSUSP;
00005c  f0430008          ORR      r0,r3,#8
;;;158    	_SetCNTR(wCNTR);
000060  6008              STR      r0,[r1,#0]
;;;159    	
;;;160    	/* force low-power mode in the macrocell */
;;;161    	wCNTR = _GetCNTR();
000062  6808              LDR      r0,[r1,#0]
000064  b280              UXTH     r0,r0
;;;162    	wCNTR |= CNTR_LPMODE;
000066  f0400004          ORR      r0,r0,#4
;;;163    	_SetCNTR(wCNTR);
00006a  6008              STR      r0,[r1,#0]
;;;164    	
;;;165    	/*prepare entry in low power mode (STOP mode)*/
;;;166    	/* Select the regulator state in STOP mode*/
;;;167    	savePWR_CR = PWR->CR;
00006c  480d              LDR      r0,|L5.164|
00006e  6803              LDR      r3,[r0,#0]
;;;168    	tmpreg = PWR->CR;
000070  9300              STR      r3,[sp,#0]
000072  6803              LDR      r3,[r0,#0]
;;;169    	/* Clear PDDS and LPDS bits */
;;;170    	tmpreg &= ((uint32_t)0xFFFFFFFC);
000074  f0230303          BIC      r3,r3,#3
;;;171    	/* Set LPDS bit according to PWR_Regulator value */
;;;172    	tmpreg |= PWR_Regulator_LowPower;
000078  f0430301          ORR      r3,r3,#1
;;;173    	/* Store the new value */
;;;174    	PWR->CR = tmpreg;
00007c  6003              STR      r3,[r0,#0]
;;;175    //	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;176    //#if defined (STM32F30X) || defined (STM32F37X)
;;;177    //        SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
;;;178    //#else
;;;179    //        SCB->SCR |= SCB_SCR_SLEEPDEEP;       
;;;180    //#endif
;;;181    	
;;;182    	/* enter system in STOP mode, only when wakeup flag in not set */
;;;183    	if((_GetISTR()&ISTR_WKUP)==0)
00007e  6810              LDR      r0,[r2,#0]
000080  04c0              LSLS     r0,r0,#19
000082  d507              BPL      |L5.148|
;;;184    	{
;;;185    //		__WFI();
;;;186    //		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;187    //#if defined (STM32F30X) || defined (STM32F37X)
;;;188    //                SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk); 
;;;189    //#else
;;;190    //                SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); 
;;;191    //#endif
;;;192    	}
;;;193    	else
;;;194    	{
;;;195    		/* Clear Wakeup flag */
;;;196    		_SetISTR(CLR_WKUP);
000084  f64e70ff          MOV      r0,#0xefff
000088  6010              STR      r0,[r2,#0]
;;;197    		/* clear FSUSP to abort entry in suspend mode  */
;;;198                    wCNTR = _GetCNTR();
00008a  6808              LDR      r0,[r1,#0]
00008c  b280              UXTH     r0,r0
;;;199                    wCNTR&=~CNTR_FSUSP;
00008e  f0200008          BIC      r0,r0,#8
;;;200                    _SetCNTR(wCNTR);
000092  6008              STR      r0,[r1,#0]
                  |L5.148|
;;;201    		
;;;202    //		/*restore sleep mode configuration */ 
;;;203    //		/* restore Power regulator config in sleep mode*/
;;;204    //		PWR->CR = savePWR_CR;
;;;205    //		
;;;206    //		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;207    //#if defined (STM32F30X) || defined (STM32F37X)		
;;;208    //                SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
;;;209    //#else
;;;210    //                SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
;;;211    //#endif
;;;212        }
;;;213    }
000094  bdf8              POP      {r3-r7,pc}
;;;214    
                          ENDP

000096  0000              DCW      0x0000
                  |L5.152|
                          DCD      0x40005c40
                  |L5.156|
                          DCD      0x40005000
                  |L5.160|
                          DCD      ||.bss||
                  |L5.164|
                          DCD      0x40007000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||EP||
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  ResumeS
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  bDeviceState
                          DCD      0x00000000
                  remotewakeupon
                          DCD      0x00000000

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  fSuspendEnabled
000000  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 138 "D:\\MDK\\install\\ARM\\PACK\\ARM\\CMSIS\\4.3.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 139

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 153
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 154

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____RRX|
#line 328
|__asm___9_usb_pwr_c_e4e9521d____RRX| PROC
#line 329

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
